Java: A Beginner's Guide, Eighth Edition
Authors: Herbert Schildt
Published: October 12th 2018
Edition: 8
ISBN: 9781260440218
Format: Print
Pages: 720
Availability: In stock
$40.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	1260440214
ISBN	9781260440218
PREVIOUS EDITION'S ISBN	No
FORMAT	Print
BINDING	Paperback / softback
STOCK DUE	Mar 11, 2020
EDITION	8
AUTHORS	Herbert Schildt
SERIES	PROGRAMMING & WEB DEVE - OMG
DIVISION	PBG
BLINK DIVISION	No
PUBLISHED	Oct 12, 2018
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

Publisher's Note: Products purchased from Third Party sellers are not guaranteed by the publisher for quality, authenticity, or access to any online entitlements included with the product.

Up-to-Date, Essential Java Programming Skills—Made Easy!
Fully updated for Java Platform, Standard Edition 11 (Java SE 11), Java: A Beginner’s Guide, Eighth Edition gets you started programming in Java right away. Best-selling programming author Herb Schildt begins with the basics, such as how to create, compile, and run a Java program. He then moves on to the keywords, syntax, and constructs that form the core of the Java language. The book also covers some of Java’s more advanced features, including multithreaded programming, generics, lambda expressions, modules, and Swing. As an added bonus, an introduction to JShell, Java’s interactive programming tool, is included. Best of all, it’s written in the clear, crisp, uncompromising style that has made Schildt the choice of millions worldwide.

Designed for Easy Learning:

• Key Skills and Concepts—Chapter-opening lists of specific skills covered in the chapter
• Ask the Expert—Q&A sections filled with bonus information and helpful tips
• Try This—Hands-on exercises that show you how to apply your skills
• Self Tests—End-of-chapter quizzes to reinforce your skills
• Annotated Syntax—Example code with commentary that describes the programming techniques being illustrated

[6th Edition]
Essential Java Programming Skills--Made Easy!
Fully updated for Java Platform, Standard Edition 8 (Java SE 8), Java: A Beginner's Guide, Sixth Edition gets you started programming in Java right away. Bestselling programming author Herb Schildt begins with the basics, such as how to create, compile, and run a Java program. He then moves on to the keywords, syntax, and constructs that form the core of the Java language. This Oracle Press resource also covers some of Java's more advanced features, including multithreaded programming, generics, and Swing. Of course, new Java SE 8 features such as lambda expressions and default interface methods are described. An introduction to JavaFX, Java's newest GUI, concludes this step-by-step tutorial.

Designed for Easy Learning:

Key Skills & Concepts -- Chapter-opening lists of specific skills covered in the chapter
       Ask the Expert -- Q&A sections filled with bonus information and helpful tips
             Try This -- Hands-on exercises that show you how to apply your skills
           Self Tests -- End-of-chapter quizzes to reinforce your skills
     Annotated Syntax -- Example code with commentary that describes the programming techniques being illustrated

The book's code examples are available FREE for download.
[/6th Edition]

[Contents]

Chapter  1: Java Fundamentals
Chapter  2: Introducing Data Types and Operators
Chapter  3: Program Control Statements
Chapter  4: Introducing Classes, Objects, and Methods
Chapter  5: More Data Types and Operators
Chapter  6: A Closer Look at Methods and Classes
Chapter  7: Inheritance
Chapter  8: Packages and Interfaces
Chapter  9: Exception Handling
Chapter 10: Using I/O
Chapter 11: Multithreaded Programming
Chapter 12: Enumerations, Autoboxing, Static Import and Annotations
Chapter 13: Generics
Chapter 14: Lambda Expressions and Method References
Chapter 15: Modules
Chapter 16: Introducing Swing
Appendix A: Answers to Self Tests
Appendix B: Using Java's Documentation Comments
Appendix C: Compiling and Running Single-File Programs in One Step
Appendix D: Introducing Jshell
Appendix E: More Java Keywords

Java Code
[Downloads & Resources]
--0--

Java: The Complete Reference, Eleventh Edition
Authors: Herbert Schildt
Published: November 21st 2018
Edition: 11
ISBN: 9781260440232
Format: Print
Pages: 1248
Availability: In stock
$60.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	1260440230
ISBN	9781260440232
PREVIOUS EDITION'S ISBN	No
FORMAT	Print
BINDING	Paperback / softback
STOCK DUE	Jan 7, 2020
EDITION	11
AUTHORS	Herbert Schildt
SERIES	PROGRAMMING & WEB DEVE - OMG
DIVISION	PBG
BLINK DIVISION	No
PUBLISHED	Nov 21, 2018
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

Publisher's Note: Products purchased from Third Party sellers are not guaranteed by the publisher for quality, authenticity, or access to any online entitlements included with the product.

The Definitive Java Programming Guide
Fully updated for Java SE 11, Java: The Complete Reference, Eleventh Edition explains how to develop, compile, debug, and run Java programs. Best-selling programming author Herb Schildt covers the entire Java language, including its syntax, keywords, and fundamental programming principles. You’ll also find information on key portions of the Java API library, such as I/O, the Collections Framework, the stream library, and the concurrency utilities. Swing, JavaBeans, and servlets are examined and numerous examples demonstrate Java in action. Of course, the very important module system is discussed in detail. This Oracle Press resource also offers an introduction to JShell, Java’s interactive programming tool. Best of all, the book is written in the clear, crisp, uncompromising style that has made Schildt the choice of millions worldwide.

Coverage includes:

• Data types, variables, arrays, and operators
• Control statements
• Classes, objects, and methods
• Method overloading and overriding
• Inheritance
• Local variable type inference
• Interfaces and packages
• Exception handling
• Multithreaded programming
• Enumerations, autoboxing, and annotations
• The I/O classes
• Generics
• Lambda expressions
• Modules
• String handling
• The Collections Framework
• Networking
• Event handling
• AWT
• Swing
• The Concurrent API
• The Stream API
• Regular expressions
• JavaBeans
• Servlets
• Much, much more.

Code examples in the book are available for download at www.OraclePressBooks.com.

[Contents]

PART I: The Java Language

Chapter  1: The History and Evolution of Java
Chapter  2: An Overview of Java
Chapter  3: Data Types, Variables, and Arrays
Chapter  4: Operators
Chapter  5: Control Statements
Chapter  6: Introducing Classes
Chapter  7: A Closer Look at Methods and Classes
Chapter  8: Inheritance
Chapter  9: Packages and Interfaces
Chapter 10: Exception Handling
Chapter 11: Multithreaded Programming
Chapter 12: Enumerations, Autoboxing, and Annotations (Metadata)
Chapter 13: I/O, Try-with-Resources, and Other Topics
Chapter 14: Generics
Chapter 15: Lambda Expressions
Chapter 16: Modules

PART II: The Java Library

Chapter 17: Spring Handling
Chapter 18: Exploring java.lang
Chapter 19: java.util Part I: The Collections Framework
Chapter 20: java.util Part 2: More Utility Classes
Chapter 21: Input/Output: Exploring java.io
Chapter 22: Exploring NIO
Chapter 23: Networking
Chapter 24: Event Handling
Chapter 25: Introducing the AWT: Workign with Windows, Graphics, and Text
Chapter 26: Using AWT Controls, Layout Managers, and Menus
Chapter 27: Images
Chapter 28: The Concurrency Utilities
Chapter 29: The Stream API
Chapter 30: Regular Expressions and Other Packages

PART III: Introducing GUI Programming with Swing

Chapter 31: Introducing Swing
Chapter 32: Exploring Swing
Chapter 33: Introducing Swing Menus

PART IV: Applying Java

Chapter 34: Java Beans
Chapter 35: Introducing Servlets

PART V: Appendices

Appendix A: Using Java's Documentation Comments
Appendix B: Introducing JShell
Appendix C: Compile and Run Simple, Single-File programs in One Step 

[Downloads & Resources]
Code Package
--0--

OCA Java SE 7 Programmer I Study Guide (Exam 1Z0-803)
Authors: Robert Liguori, Edward G. Finegan
Published: September 1st 2012
Edition: 2
ISBN: 9780071789448
Format: eBook
Pages: 576
Availability: In stock
$50.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	0071789448
ISBN	9780071789448
PREVIOUS EDITION'S ISBN	N/A
FORMAT	eBook
BINDING	Electronic book text
STOCK DUE	N/A
EDITION	2
AUTHORS	Robert Liguori, Edward G. Finegan
SERIES	Oracle Press
DIVISION	PBG
BLINK DIVISION	N/A
PUBLISHED	Sep 1, 2012
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

A Proven Study System for Oracle Certified Associate Exam 1Z0-803
Prepare for the Oracle Certified Associate Java SE 7 Programmer I exam with help from this exclusive Oracle Press guide. In each chapter, you'll find challenging exercises, practice questions, a two-minute drill, and a chapter summary to highlight what you've learned. This authoritative guide will help you pass the test and will also serve as your essential on-the-job reference. Get complete coverage of all OCA objectives for exam 1Z0-803, including:

Packaging, compiling, and interpreting Java code
Programming with Java statements
Programming with Java operators and strings
Working with basic classes and variables
Understanding variable scope and class construction
Programming with arrays
Understanding class inheritance
Understanding polymorphism and casts
Handling exceptions
Working with classes and their relationships

Electronic content includes:

One full practice exam
Detailed answers and explanations
Score report performance assessment tool
Free with online registration:
Bonus exam

[Contents]

Part I: Fundamental Java Elements

          CH 1: Packaging, Compiling and Interpreting Java Code

          CH 2: Programming with Java Statements

          CH 3: Programming with Java Operators and Strings

Part II: Object-oriented Basic Concepts

          CH 4: Working with Basic Classes and Variables

          CH 5: Understanding Variable Scope and Class Construction

          CH 6: Working with Classes and their Relationships

          CH 7: Understanding Class Inheritance

          CH 8: Understanding Polymorhpism

          CH 9: Representing Object-oriented Concepts with UML

Part III: Java-Related Platforms and Technologies

          CH 10: Understanding Java Related Platforms and Integration Technologies

          CH 11: Understanding Client-side Technologies

          CH 12: Understanding Server-side Technologies
--0--

OCA/OCP Java SE 7 Programmer I & II Study Guide (Exams 1Z0-803 & 1Z0-804)
Authors: Kathy Sierra, Bert Bates
Published: October 7th 2014
Edition: 1
ISBN: 9780071771993
Format: eBook
Pages: 888
Availability: In stock
$50.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	0071771999
ISBN	9780071771993
PREVIOUS EDITION'S ISBN	N/A
FORMAT	eBook
BINDING	Electronic book text
STOCK DUE	N/A
EDITION	1
AUTHORS	Kathy Sierra, Bert Bates
SERIES	CERTIFICATION & CAREER - OMG
DIVISION	PBG
BLINK DIVISION	N/A
PUBLISHED	Oct 7, 2014
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

A complete update to the definitive, bestselling guide to the #1 certification for Java programmers

Written and revised by the co-developers of the original SCJP exam and now published in the Oracle Press brand
Includes two complete practice exams—250+ practice exam questions in book and via electronic content
Replaces SCJP Sun Certified Programmer for Java Study Guide—150,000 copies sold

[Contents]

Chapter  1 - Declarations and Access Control

Chapter  2 - Object Orientation

Chapter  3 - Assignments

Chapter  4 - Operators

Chapter  5 - Flow Control, Exceptions, and Assertions

Chapter  6 - Strings, I/O, Formatting, and Parsing

Chapter  7 - Generics and Collections

Chapter  8 - Inner Classes

Chapter  9 - Threads

Chapter 10 - Development

Appendix: About the CD

Index
--0--

SCJP Sun Certified Programmer For Java 6 Study Guide
Authors: Kathy Sierra, Bert Bates
Published: May 24th 2008
Edition: 1
ISBN: 9780071591072
Format: eBook
Pages: 851
Availability: In stock
$55.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	0071591079
ISBN	9780071591072
PREVIOUS EDITION'S ISBN	N/A
FORMAT	eBook
BINDING	Electronic book text
STOCK DUE	N/A
EDITION	1
AUTHORS	Kathy Sierra, Bert Bates
SERIES	CERTIFICATION & CAREER - OMG
DIVISION	PBG
BLINK DIVISION	N/A
PUBLISHED	May 24, 2008
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

The Best Fully Integrated Study System Available--Written by the Lead Developers of Exam 310-065

With hundreds of practice questions and hands-on exercises, SCJP Sun Certified Programmer for Java 6 Study Guide covers what you need to know--and shows you how to prepare--for this challenging exam.

100% complete coverage of all official objectives for exam 310-065
Exam Objective Highlights in every chapter point out certification objectives to ensure you're focused on passing the exam
Exam Watch sections in every chapter highlight key exam topics covered
Simulated exam questions match the format, tone, topics, and difficulty of the real exam

Covers all SCJP exam topics, including:

· Declarations and Access Control 
· Object Orientation 
· Assignments 
· Operators 
· Flow Control, Exceptions, and Assertions 
· Strings, I/O, Formatting, and Parsing 
· Generics and Collections 
· Inner Classes 
· Threads 
· Development

CD-ROM includes:

Complete MasterExam practice testing engine, featuring: Two full practice exams; Detailed answers with explanations; Score Report performance assessment tool
Electronic book for studying on the go
Bonus coverage of the SCJD exam included!
Bonus downloadable MasterExam practice test with free online registration.

[Contents]

Chapter  1 - Declarations and Access Control

Chapter  2 - Object Orientation

Chapter  3 - Assignments

Chapter  4 - Operators

Chapter  5 - Flow Control, Exceptions, and Assertions

Chapter  6 - Strings, I/O, Formatting, and Parsing

Chapter  7 - Generics and Collections

Chapter  8 - Inner Classes

Chapter  9 - Threads

Chapter 10 - Development

Appendix: About the CD

Index
--0--

OCA/OCP Java SE 8 Programmer Certification Bundle (Exams 1Z0-808 And 1Z0-809)
Authors: Kathy Sierra, Bert Bates, Elisabeth Robson
Published: September 18th 2018
Edition: 1
ISBN: 9781260452198
Format: Print
Availability: In stock
$85.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	1260452190
ISBN	9781260452198
PREVIOUS EDITION'S ISBN	No
FORMAT	Print
BINDING	Mixed media product
STOCK DUE	Mar 13, 2020
EDITION	1
AUTHORS	Kathy Sierra, Bert Bates, Elisabeth Robson
SERIES	CERTIFICATION & CAREER - OMG
DIVISION	PBG
BLINK DIVISION	No
PUBLISHED	Sep 18, 2018
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

Publisher's Note: Products purchased from Third Party sellers are not guaranteed by the publisher for quality, authenticity, or access to any online entitlements included with the product.

Prepare for the Java SE 8 OCA and OCP Programmer exams with this money-saving, comprehensive study package

Designed as a complete self-study program, this collection offers a variety of proven, exam-focused resources to use in preparation for for OCA and OCP certification exams 1Z0-808 and 1Z0-809. Comprised of OCA Java SE 8 Programmer I Exam Guide and OCP Java SE 8 Programmer II Exam Guide, this bundle thoroughly covers every topic on both exams—all at a discount of 23% off MSRP.

OCA/OCP Java SE 8 Programmer Certification Bundle (Exams 1Z0-808 & 1Z0-809) contains hundreds of practice questions that match those on the live exams in content, style, tone, format, and difficulty. Step-by-step exercises; self-tests; and “Exam Watch,” “Inside the Exam,” and “On the Job” sections highlight salient points and aid in learning. You will get real-world examples, professional insights, and concise explanations. This authoritative, cost-effective bundle serves both as a study tool AND a valuable on-the-job reference.
 
• This bundle is 23% cheaper than purchasing the books individually 
• Written by a team of Java OCA and OCP experts
• Electronic content includes 330 practice exam questions in a fully-customizable test engine

[Contents]

OCA Java SE 8 Programmer I Exam Guide (Exam 1Z0-808)

Chapter  1: Declarations and Access Control
Chapter  2: Object Orientation
Chapter  3: Assignments
Chapter  4: Operators
Chapter  5: Flow Control and Exceptions
Chapter  6: Working with Strings, Arrays, and ArrayLists


OCP Java SE 8 Programmer II Exam Guide (Exam 1Z0-809)

Chapter  1: Declarations, Access Control, and Enums
Chapter  2: Object Orientation
Chapter  3: Assertions and Exceptions
Chapter  4: Dates, Times, Locales, and Resource Bundles
Chapter  5: I/O and NIO
Chapter  6: Generics and Collections
Chapter  7: Inner Classes
Chapter  8: Lambda Expressions and Functional Interfaces
Chapter  9: Streams
Chapter 10: Threads
Chapter 11: Concurrency
Chapter 12: JDBC
--0--

OCA Java SE 8 Programmer I Exam Guide (Exams 1Z0-808)
Authors: Kathy Sierra, Bert Bates
Published: April 21st 2017
Edition: 1
ISBN: 9781260011388
Format: eBook
Availability: In stock
$50.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	1260011380
ISBN	9781260011388
PREVIOUS EDITION'S ISBN	N/A
FORMAT	eBook
BINDING	Electronic book text
STOCK DUE	N/A
EDITION	1
AUTHORS	Kathy Sierra, Bert Bates
SERIES	CERTIFICATION & CAREER - OMG
DIVISION	PBG
BLINK DIVISION	N/A
PUBLISHED	Apr 21, 2017
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

Up-to-date coverage of every topic on the Java 8 SE Programmer I exam

Prepare for the OCA Java SE 8 Programmer I exam using this effective self-study system from Oracle Press. Written by developers of the original Sun Certified Java Programmer exam, OCA Java SE 8 Programmer I Exam Guide (Exam 1Z0-808) includes two complete, accurate practice exams. In all, you will get more than 200 practice questions that mirror those on the actual test in content, tone, and format. Beyond fully preparing you for the challenging exam, the book also serves as an ideal on-the-job reference.

Clearly explains every topic on Exam IZ0-808, including:

• Declarations
• Access control
• Object orientation
• Assignments
• Operators
• Flow control
• Exceptions
• Strings
• Arrays
• ArrayLists
 
Electronic content includes:

• 200+ practice exam questions
• Fully customizable test engine
• Secured book PDF

[Contents]

Chapter  1: Declarations and Access Control
Chapter  2: Object Orientation
Chapter  3: Assignments
Chapter  4: Operators
Chapter  5: Flow Control and Exceptions
Chapter  6: Working with Strings, Arrays, and ArrayLists
Appendix A: About the CD
--0--

OCP Java SE 8 Programmer II Exam Guide (Exam 1Z0-809)
Authors: Kathy Sierra, Bert Bates, Elisabeth Robson
Published: April 20th 2018
Edition: 7
ISBN: 9781260117370
Format: eBook
Pages: 976
Availability: In stock
$60.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	1260117375
ISBN	9781260117370
PREVIOUS EDITION'S ISBN	N/A
FORMAT	eBook
BINDING	Electronic book text
STOCK DUE	N/A
EDITION	7
AUTHORS	Kathy Sierra, Bert Bates, Elisabeth Robson
SERIES	CERTIFICATION & CAREER - OMG
DIVISION	PBG
BLINK DIVISION	N/A
PUBLISHED	Apr 20, 2018
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

Description

A Complete, Integrated Study System for OCP Exam 1Z0-809
Study for the OCP Java SE 8 Programmer II exam using this effective exam preparation guide from Oracle Press. Written by a team of experts, including two developers of the original exam, OCP Java SE 8 Programmer II Exam Guide (Exam 1Z0-809) offers comprehensive coverage of every subject on the test and lays out essential Java programming skills. Throughout, step-by-step exercises; self-tests; and “Exam Watch,” “Inside the Exam,” and “On the Job” sections highlight salient points and aid in learning. In all, the book and accompanying digital content feature more than 350 practice questions that mirror those on the live test in tone, format, and content.

Clearly explains every topic on Exam 1Z0-809, including:

• Declarations, access control, and enums
• Object orientation
• Assertions and exceptions
• Dates, times, locales, and resource bundles
• I/O and NIO
• Generics and collections
• Inner classes
• Lambda expressions and functional interfaces
• Streams
• Threads
• Concurrency
• JDBC

Electronic content includes:

• 170 practice exam questions
• Fully customizable test engine
• Secured book PDF

For questions regarding content or to report errata, e-mail hep_customer-service@mheducation.com

Chapter  1: Declarations, Access Control, and Enums
Chapter  2: Object Orientation
Chapter  3: Assertions and Exceptions
Chapter  4: Dates, Times, Locales, and Resource Bundles
Chapter  5: I/O and NIO
Chapter  6: Generics and Collections
Chapter  7: Inner Classes
Chapter  8: Lambda Expressions and Functional Interfaces
Chapter  9: Streams
Chapter 10: Threads
Chapter 11: Concurrency
Chapter 12: JDBC

[Downloads & Resources]
Study Guide Code
--0--

Java Programming
Authors: Poornachandra Sarang
Published: January 20th 2012
Edition: 1
ISBN: 9780071633604
Format: Print
Pages: 672
Availability: In stock
$50.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	007163360X
ISBN	9780071633604
PREVIOUS EDITION'S ISBN	N/A
FORMAT	Print
BINDING	Paperback / softback
STOCK DUE	N/A
EDITION	1
AUTHORS	Poornachandra Sarang
SERIES	Oracle Press
DIVISION	PBG
BLINK DIVISION	N/A
PUBLISHED	Jan 20, 2012
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

Publisher's Note: Products purchased from Third Party sellers are not guaranteed by the publisher for quality, authenticity, or access to any online entitlements included with the product.

Develop, Compile, and Debug High-Performance Java Applications
Take your Java skills to the next level using the expert programming techniques contained in this Oracle Press guide. Featuring real-world code samples and detailed instructions, Java Programming demonstrates how to fully utilize the powerful features of Java SE 7. Find out how to design multithreaded and network applications, integrate structured exception handling, use Java libraries, and develop Swing-based GUIs and applets. Inheritance, generics, and utility classes are are covered in this practical resource.

      Create custom classes, methods, arrays, and operators
      Control program flow using conditional statements
      Handle multithreaded, network, and I/O programming
      Learn new constructs in multithreading
      Incorporate enums, annotations, and autoboxing
      Recover from errors, input failures, and exceptions
      Use Java Swing to build lightweight GUIs and applets
      Cut development time using the collections framework
      Work with the latest Java libraries and utility classes

[Contents]

Chapter  1. Introduction to Java
Chapter  2. Arrays
Chapter  3. Classes
Chapter  4. Inheritance
Chapter  5. Object Creation and Member Visibility
Chapter  6. Static Modifier and Interfaces
Chapter  7. Nested Classes
Chapter  8. Exception Handling
Chapter  9. Java I/O
Chapter 10. Advanced I/O
Chapter 11. Enums, Autoboxing, and Annotations
Chapter 12. Generics
Chapter 13. Event Processing and GUI Building
Chapter 14. Creating Layouts
Chapter 15. Graphics and User Gestures Processing
Chapter 16. Collections
Chapter 17. Threads
Chapter 18. Blocking Queues and Synchronizers
Chapter 19. Callables, Futures, Executors, and Fork/Join
Chapter 20. Network Programming
Chapter 21. Utility Classes
Index
--0--

Java The Complete Reference, 8th Edition
Authors: Herbert Schildt
Published: June 22nd 2011
Edition: 8
ISBN: 9780071606301
Format: Print
Pages: 1152
Availability: In stock
$63.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	0071606300
ISBN	9780071606301
PREVIOUS EDITION'S ISBN	N/A
FORMAT	Print
BINDING	Paperback / softback
STOCK DUE	N/A
EDITION	8
AUTHORS	Herbert Schildt
SERIES	The Complete Reference
DIVISION	PBG
BLINK DIVISION	N/A
PUBLISHED	Jun 22, 2011
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

Publisher's Note: Products purchased from Third Party sellers are not guaranteed by the publisher for quality, authenticity, or access to any online entitlements included with the product.

The Definitive Java Programming Guide
In Java: The Complete Reference, Eighth Edition, bestselling programming author Herb Schildt shows you everything you need to develop, compile, debug, and run Java programs. Updated for Java Platform, Standard Edition 7 (Java SE 7), this comprehensive volume covers the entire Java language, including its syntax, keywords, and fundamental programming principles. You'll also find information on key elements of the Java API library. JavaBeans, servlets, applets, and Swing are examined and real-world examples demonstrate Java in action. In addition, new Java SE 7 features such as try-with-resources, strings in switch, type inference with the diamond operator, NIO.2, and the Fork/Join Framework are discussed in detail.

Coverage includes:

Data types and operators
Control statements
Classes and objects
Constructors and methods
Method overloading and overriding
Interfaces and packages
Inheritance
Exception handling
Generics
Autoboxing
Enumerations
Annotations
The try-with-resources statement
Varargs
Multithreading
The I/O classes
Networking
The Collections Framework
Applets and servlets
JavaBeans
AWT and Swing
The Concurrent API
Much, much more

[Contents]

Part I: The Java Language

 1. The History and Evolution of Java
 2. An Overview of Java
 3. Data Types, Variables, and Arrays
 4. Operators
 5. Control Statements
 6. Introducing Classes
 7. A Closer Look at Methods and Classes
 8. Inheritance
 9. Packages and Interfaces
10. Exception Handling
11. Multithreaded Programming
12. Enumerations, Autoboxing, and Annotations (Metadata)
13. I/O, Applets, and Other Topics
14. Generics

Part II: The Java Library

15. String Handling
16. Exploring java.lang
17. java.util Part 1: The Collections Framework
18. java.util Part 2: More Utility Classes
19. Input/Output: Exploring java.io
20. Exploring NIO
21. Networking
22. The Applet Class
23. Event Handling
24. Introducing the AWT: Working with Windows, Graphics, and Text
25. Using AWT Controls, Layout Managers, and Menus
26. Images
27. The Concurrency Utilities
28. Regular Expressions and Other Packages

Part III: Software Development Using Java

29. Java Beans
30. Introducing Swing
31. Exploring Swing
32. Servlets

Part IV: Applying Java

33. Financial Applets and Servlets
34. Creating a Download Manager in Java

Appendix: Using Java's Documentation Comments

Index
--0--

HTML: A Beginner's Guide, Fifth Edition
Authors: Wendy Willard
Published: March 13th 2013
Edition: 5
ISBN: 9780071809276
Format: Print
Pages: 512
Availability: In stock
$37.00

ADDITIONAL INFORMATION
AVAILABILITY TYPE	None
ISBN (10-DIGIT)	0071809279
ISBN	9780071809276
PREVIOUS EDITION'S ISBN	N/A
FORMAT	Print
BINDING	Paperback / softback
STOCK DUE	N/A
EDITION	5
AUTHORS	Wendy Willard
SERIES	Beginner's Guide
DIVISION	PBG
BLINK DIVISION	N/A
PUBLISHED	Mar 13, 2013
PUBLICATION STATUS	IN PUBLICATION - ACTIVE

[Description]

Publisher's Note: Products purchased from Third Party sellers are not guaranteed by the publisher for quality, authenticity, or access to any online entitlements included with the product.

Essential HTML skills—made easy!

Thoroughly updated and revised, HTML: A Beginners Guide, Fifth Edition shows you, step by step, how to create dynamic websites with HTML. The book covers new HTML5 features, including video, audio, and canvas elements. Learn how to structure a page, place images, format text, create links, add color, work with multimedia, and use forms. You'll also go beyond the basics and find out how to work with Cascading Style Sheets (CSS), create dynamic web content with JavaScript, upload your site to the web, and code HTML emails. By the end of the book you'll be able to build custom websites using the latest HTML techniques.

Chapters include:

Key Skills & Concepts--Chapter-opening lists of specific skills covered in the chapter
       Ask the Expert--Q & A sections filled with bonus information and helpful tips
             Try This--Hands-on exercises that show you how to apply your skills
                Notes--Extra information related to the topic being covered
                 Tips--Helpful reminders or alternate ways of doing things
           Self-Tests--End-of-chapter reviews to test your knowledge
     Annotated syntax--Example code with commentary that describes the programming techniques being illustrated

[Contents]

Part I: HTML Basics

       1. Getting Started
       2. Document Setup
       3. Style Sheet Setup
       4. Working with Text
       5. Page Structure
       6. Positioning Page Elements
       7. Working with Links
       8. Working with Images
       9. Working with Multimedia
      10. Creating Lists
      11. Using Tables
      12. Creating Forms
      13. Forming & Styling Forms

Part II: Beyond HTML

      14. Beyond Static HTML
      15. Making Pages Available to Others
      16. HTML for Email
      
Part III: Appendixes

       A. Answers to Self Tests
       B. HTML/CSS Reference Table
       C. Troubleshooting
       D. Special Characters
       E. File Types
--0--

Java Quick Syntax Reference, Second Edition
Mikael Olsson
Hammarland, Länsi-Suomi, Finland
ISBN-13 (pbk): 978-1-4842-3440-2		
https://doi.org/10.1007/978-1-4842-3441-9
ISBN-13 (electronic): 978-1-4842-3441-9
Library of Congress Control Number: 2018932355
Copyright (c) 2018 by Mikael Olsson

              [Table of Contents]

              About the Author 
              About the Technical Reviewer 
              Introduction 
Chapter  1:   Hello World 
Chapter  2:   Compile and Run 
Chapter  3:   Variables 
Chapter  4:   Operators 
Chapter  5:   String 
Chapter  6:   Arrays 
Chapter  7:   Conditionals 
Chapter  8:   Loops 
Chapter  9:   Methods 
Chapter 10:   Class 
Chapter 11:   Static 
Chapter 12:   Inheritance 
Chapter 13:   Overriding 
Chapter 14:   Packages and Import 
Chapter 15:   Access Levels 
Chapter 16:   Constants 
Chapter 17:   Interface 
Chapter 18:   Abstract 
Chapter 19:   Enum 
Chapter 20:   Exception Handling 
Chapter 21:   Boxing and Unboxing 
Chapter 22:   Generics 
Chapter 23:   Lambda Expressions 
              Index


Table of Contents

About the Author                                             
About the Technical Reviewer                                 
Introduction                                             

Chapter 1:   Hello World      /* Java Code or Program Structure */                                 

             Installing                                  
             Creating a project                          
             Hello World                                 
             Code hints                                  

Chapter 2:   Compile and Run  /* All about JDK tools */                           

             Running from the IDE                        
             Running from a console window               
             Comments                                    

Chapter 3:   Variables         /* Java Language Data Types */                          

             Data types                             
             Declaring variables                    
             Assigning variables                    
             Using variables                        
             Integer types                          
             Floating-point types                   
             Char type                              
             Boolean type                           
             Variable scope                         
             Anonymous block                        

Chapter 4:   Operators        /* Java Language Operators */                      

             Arithmetic operators                   
             Assignment operators                   
             Combined assignment operators          
             Increment and decrement operators 
             Comparison operators              
             Logical operators                 
             Bitwise operators                 
             Operator precedence               

Chapter 5:   String                                             

             Combining strings                                  
             Escape characters                                  
             String compare                                     
             StringBuffer class                                 

Chapter 6:   Arrays                                             

             Array declaration                                  
             Array allocation                                   
             Array assignment                                   
             Multi-dimensional arrays                           
             ArrayList class                                    

Chapter 7:   Conditionals        /* Control Statement  */                                    

             If statement                                       
             Switch statement                                   
             Ternary operator                                   

Chapter 8:   Loops               /* Control Statement  */                             

             While loop                                       
             Do while loop                                    
             For loop                                         
             For-each loop                                    
             Break and continue                               
             Labeled block                                    

Chapter 9:   Methods              /* Function or procedure */                            

             Defining methods                                 
             Calling methods                                  
             Method parameters                                
             Return statement                                 
             Method overloading                               
             Passing arguments                                

Chapter 10:  Class                  /* Object creation */                          

             Object creation                                  
             Accessing object members                         
             Constructor                                      
             This keyword                                     
             Constructor overloading                          
             Constructor chaining                             
             Initial field values                             
             Default constructor                              
             Null                                             
             Default values                                   
             Garbage collector                                

Chapter 11:  Static                                           

             Accessing static members                         
             Static methods                                   
             Static fields                                    
             Static initialization blocks                     
             Instance initialization blocks                   

Chapter 12:  Inheritance                                      

             Object                                           
             Upcasting                                        
             Downcasting                                      
             Instanceof operator                              

Chapter 13:  Overriding                                       

             Overriding members                               
             Override annotation                              
             Hiding members                                   
             Preventing method inheritance                    
             Accessing overridden methods                     
             Calling parent constructor                       

Chapter 14:  Packages and Import                              

             Accessing packages                               

Chapter 15:  Access Levels                                    

             Private access                                   
             Package-private access                           
             Protected access                                 
             Public access                                    
             Top-level access                                 
             Nested class access                              
             Access level guideline                           

Chapter 16:  Constants                                        

             Local constants                                  
             Constant fields                                  
             Constant method parameters                       
             Compile-time and runtime constants 
             Constant guideline                 

Chapter 17:  Interface                          

             Interface members                  
             Interface example                  
             Functionality interface            
             Class interface                    
             Interface classes                  
             Interface methods                  

Chapter 18:  Abstract                           

             Abstract class example             
             Abstract classes and interfaces    

Chapter 19:  Enum                               

             Enum class                         

Chapter 20:  Exception Handling                 

             Try-catch                          
             Catch block                        
             Finally block                      
             Throwing exceptions                
             Checked and unchecked exceptions   
             Exception hierarchy                

Chapter 21:  Boxing and Unboxing                

             Autoboxing and autounboxing        
             Primitive and wrapper guideline    

Chapter 22:  Generics                           

             Generic classes                    
             Generic methods                    
             Calling generic methods            
             Generic interfaces                 
             Generic type parameters            
             Generic variable usages            
             Bounded type parameters            
             Generics and Object                

Chapter 23:  Lambda Expressions                 

             Lambda objects                     
             Lambda parameters                  

Index                                           
 
/**********************************************/ 
/* (Java Quick Syntax Reference - Source Code */
/**********************************************/

*** Hello World ***
 
public class MyApp 
{
  public static void main(String[] args) 
  {
    System.out.print("Hello World");
  }
}
 
*** Compile and Run ***
 
// single-line comment
 
/* multi-line
   comment */

/** javadoc
    comment */
 
*** Variables ***
 
public class MyApp 
{
  public static void main(String[] args) 
  {
    // Declaration
    int myInt;

    // Assignment
    myInt = 10;

    // Output
    System.out.print(myInt); // "10"
  }
}
 
 
public class MyApp 
{
  public static void main(String[] args) 
  {
    byte  myInt8  = 2;  // -128   to +127
    short myInt16 = 1;  // -32768 to +32767
    int   myInt32 = 0;  // -2^31  to +2^31-1
    long  myInt64 = -1; // -2^63  to +2^63-1

    double myDouble = 3.14;
           myDouble = 3e2; // 3*10^2 = 300

    float myFloat = 3.14F;
          myFloat = (float)3.14;

    char myChar = 'A';
         myChar = '\u0000'; // \u0000 to \uFFFF

    boolean myBool = false;
  }
}

 
// Anonymous block
public static void main(String[] args) 
{
  // Anonymous code block
  {
    int localVar = 10;
  }
  // localVar is unavailable from here
}

*** Operators ***
 
// Arithmetic operators
float f = 3+2; // 5 // addition
      f = 3-2; // 1 // subtraction
      f = 3*2; // 6 // multiplication
      f = 3/2; // 1 // division
      f = 3%2; // 1 // modulus (division remainder)

// Combined assignment operators
int i = 0;
    i += 5; // i = i+5;
    i -= 5; // i = i-5;
    i *= 5; // i = i*5; 
    i /= 5; // i = i/5;
    i %= 5; // i = i%5;

// Increment and decrement operators
++i; // i += 1
--i; // i -= 1

++i; // pre-increment
--i; // pre-decrement     
i++; // post-increment
i--; // post-decrement

int j;
i = 5; j = i++; // j=5, i=6   
i = 5; j = ++i; // j=6, i=6

// Comparison operators
boolean b = (2==3); // false // equal to
        b = (2!=3); // true  // not equal to
        b = (2>3);  // false // greater than
        b = (2<3);  // true  // less than
        b = (2>=3); // false // greater than or equal to
        b = (2<=3); // true  // less than or equal to

// Logical operators
b = (true && false); // false // logical and
        b = (true || false); // true  // logical or
        b = !(true);         // false // logical not

// Bitwise operators
i = 5 & 4; // 101 & 100 = 100 (4) // and
i = 5 | 4; // 101 | 100 = 101 (5) // or
i = 5 ^ 4; // 101 ^ 100 = 001 (1) // xor
i = 4 << 1;// 100 << 1  =1000 (8) // left shift
i = 4 >> 1;// 100 >> 1  =  10 (2) // right shift
i = 4 >>>1;// 100 >>>1  =  10 (2) // zero-fill 
                                  // right shift
i = ~4;    // ~00000100 = 11111011 (-5) // invert

i=5; i  &= 4; // 101 & 100 = 100 (4) // and
i=5; i  |= 4; // 101 | 100 = 101 (5) // or
i=5; i  ^= 4; // 101 ^ 100 = 001 (1) // xor
i=5; i <<= 1; // 101 << 1  =1010 (10)// left shift
i=5; i >>= 1; // 101 >> 1  =  10 (2) // right shift
i=5; i>>>= 1; // 101 >> 1  =  10 (2) // zero-fill
                                     // right shift
 
*** String ***
 
String a = "Hello";
String b = new String(" World");

String c = a+b; // Hello World
       a += b;  // Hello World

// String compare
boolean x = a.equals(b); // compares string
boolean y = (a == b);    // compares address
boolean z = "Hello".equals(a);

// StringBuffer class
StringBuffer sb = new StringBuffer("Hello");

sb.append(" World");   // add to end of string
sb.delete(0, 5);       // remove 5 first characters
sb.insert(0, "Hello"); // insert string at beginning

String s = sb.toString();
 
*** Arrays ***
 
// Array declaration 
int[] x;
int y[];

// Array allocation
int y[] = new int[3];

// Array assignment
y[0] = 1;
y[1] = 2;
y[2] = 3;

int[] x = new int[] {1,2,3};
int[] x = {1,2,3};

// Array access
System.out.print(x[0] + x[1] + x[2]); // "6"

// Multi-dimensional arrays
String[][] x = {{"00","01"},{"10","11"}};
String[][] y = new String[2][2];
 
y[0][0] = "00";
y[0][1] = "01";
y[1][0] = "10";
y[1][1] = "11";
 
System.out.print(x[0][0] + x[1][1]); // "0011"

int x[] = new int[3];
int size = x.length; // 3

// ArrayList class
java.util.ArrayList a = new java.util.ArrayList();

a.add("Hi");       // add an element
a.set(0, "Hello"); // change first element
a.remove(0);       // remove first element

a.add("Hello World");
String s = (String)a.get(0); // Hello World
 
*** Conditionals ***
 
// If statement 
if (x < 1) {
  System.out.print(x + " < 1");
}
else if (x > 1) {
  System.out.print(x + " > 1");
}
else {
  System.out.print(x + " == 1");
}

if (x < 1)
  System.out.print(x + " < 1");
else if (x > 1)
  System.out.print(x + " > 1");
else
  System.out.print(x + " == 1");

// Switch statement
switch (y)
{
  case 0: System.out.print(y + " is 0"); break;
  case 1: System.out.print(y + " is 1"); break;
  default:System.out.print(y + " is something else");
}

// Ternary operator (?:)
x = (x < 0.5) ? 0 : 1;

*** Loops ***
 
int i = 0;
while (i < 10) { System.out.print(i++); }

int i = 0;
do { System.out.print(i++); } while (i < 10);

for (int i = 0; i < 10; i++)
{ System.out.print(i); }

for (int k = 0, l = 10; k < 10; k++, l--)
{ System.out.print(k + l); }

for (int k = 0, l = 10; k < 10;)
{ System.out.print(k + l); k++; l--; }

int[] array = { 1,2,3 };
for (int element : array) { System.out.print(element); }

// Break and continue
myLoop: for (int i = 0, j = 0; i < 10; i++)
        {
          while (++j < 10)
          {
            break myLoop;    // end for
            continue myLoop; // start next for                
          }
        }
 
 
// Labeled block
validation:
{
  if(true)
    break validation;
}
 
*** Methods ***
 
class MyApp
{
  void myPrint()
  {
    System.out.print("Hello");
  }

  void myPrint(String s)
  {
    System.out.print(s);
  }

  public static void main(String[] args)
  {
    MyApp m = new MyApp();
    m.myPrint();        // "Hello"
    m.myPrint("Hello"); // "Hello"
  }
}
 
 
String getPrint()
{
  return "Hello";
}

public static void main(String[] args)
{
  MyApp m = new MyApp();
  System.out.print( m.getPrint() ); // "Hello"
}
 
 
// Passing arguments
public static void main(String[] args)
{
  MyApp m = new MyApp();
  int x = 0;              // value data type
  m.set(x);               // value is passed
  System.out.print(x);    // "0"
 
  int[] y = {0};          // reference data type
  m.set(y);               // address is passed
  System.out.print(y[0]); // "10"
}
 
void set(int a) { a = 10; }
void set(int[] a) { a[0] = 10; }
 
*** Class ***
 
class MyRectangle
{
  public int x = 10, y = 20;
  public int getArea() { return x * y; }

  public MyRectangle()      { this(10,20);  }
  public MyRectangle(int a) { this(a,a);    }

  public MyRectangle(int x, int y)
  {
    this.x = x; 
    this.y = y;
  }

}

class MyApp
{
  public static void main(String[] args)
 {
    // Create an object of MyRectangle
    MyRectangle r = new MyRectangle();
    r.x = 10;
    r.y = 5;
    int z = r.getArea(); // 50 (5*10)
  }
}

*** Static ***
 
class MyCircle
{
  float r = 10;            // instance field
  static float pi = 3.14F; // static/class field
 
  // Instance method
  float getArea() { return newArea(r); }
 
  // Static/class method
  static float newArea(float a) { return pi*a*a; }
}

class MyApp
{
  public static void main(String[] args)
  {
    float f = MyCircle.pi;
    MyCircle c = new MyCircle();
    float g = c.r;
    double pi = Math.PI;
  }
}
 
 
// Static fields
class MyCircle
{
  static void dummy() { count++; }
  static int count = 0;
}
 
 
// Static initialization blocks
static int[] array = new int[5];
static
{
  int i = 0;
  for(int element : array)
    element = i++;
}
 
 
// Initialization blocks
int[] array = new int[5];
{
  int i = 0;
  for(int element : array) element = i++;
}

*** Inheritance ***
 
// Superclass (parent class)
class Fruit
{
  public String flavor;
}
 
// Subclass (child class)
class Apple extends Fruit
{
  public String variety;
}

class MyApp
{
  public static void main(String[] args)
  {
    // Upcast and downcast
    Apple a = new Apple();
    Fruit f = a;
    f.flavor = "Sweet";
    Apple b = (Apple)f;
    Apple c = (f instanceof Apple) ? (Apple)f : null;
  }
}

*** Overriding ***
 
class Rectangle
{
  public int w = 10, h = 10;

  public int getArea() { 
    return w * h; 
  }

  public static int newArea(int a, int b) {
    return a * b;
  }
}
 
class Triangle extends Rectangle
{
  @Override public int getArea() {
    return w * h / 2;
  }

  public static int newArea(int a, int b) {
    return a * b / 2;
  }
}

class MyApp
{
  public static void main(String[] args)
  {
    Triangle o1 = new Triangle();
    o1.getArea(); // (50) calls Triangle's version

    Rectangle o2 = new Triangle();
    o2.getArea(); // (50) calls Triangle's version

    Triangle o3 = new Triangle();
    o3.newArea(10,10); // (50) calls Triangle's version
 
    Rectangle r = o3;
    r.newArea(10,10); // (100) calls Rectangle's version
  }
}
 
 
// Preventing method inheritance
public final int getArea() { return w * h; }
 
 
// Accessing overridden methods
@Override public int getArea()
{
  return super.getArea() / 2;
}
 
 
// Calling parent constructor
public Triangle(int a, int b) { super(a,b); }
public Triangle() { super(); }
 
*** Packages and Import ***

package mypackage; // this file belongs to mypackage

// Import specific class
import mypackage.sub.MyClass;
//
MyClass m;

// Import package
import java.util.*;

// Import static
import static java.lang.Math.*;
//
double pi = PI; // Math.PI
Access Levels
 
 
package mypackage;
public class MyApp
{
  public    int myPublic;   // unrestricted access
  protected int myProtected;// package or subclass access
            int myPackage;  // package access
  private   int myPrivate;  // class access
 
  void test()
  {
    myPublic    = 0; // allowed
    myProtected = 0; // allowed
    myPackage   = 0; // allowed
    myPrivate   = 0; // allowed
  }
}

class MyClass
{
  void test(MyApp m)
  {
    m.myPublic    = 0; // allowed
    m.myProtected = 0; // allowed
    m.myPackage   = 0; // allowed
    m.myPrivate   = 0; // inaccessible
  }
}
 

package newpackage;
import mypackage.MyApp;
 
class MyClass extends MyApp
{
  void test()
  {
    myPublic    = 0; // allowed
    myProtected = 0; // allowed
    myPackage   = 0; // inaccessible
    myPrivate   = 0; // inaccessible
  }
}

class MyClass
{
  void test(MyApp m)
  {
    m.myPublic    = 0; // allowed
    m.myProtected = 0; // inaccessible
    m.myPackage   = 0; // inaccessible
    m.myPrivate   = 0; // inaccessible
  }
}

 
// Accessible only from containing package
class PackagePrivateClass {}
 
// Accessible from any package
public class PublicClass {}
 
 
// Nested class access
class MyClass
{
  // Only accessible within MyClass
  private class PrivateNestedClass {}
}

*** Constants ***
 
class MyApp
{
  public static void main(String[] args)
  {
    // Local constant
    final double PI = 3.14;
  }
}

// Constant fields
class MyClass
{
  final double E;
  static final double C;
 
  public MyClass() { E = 2.72; }
  static { C = 3e8; }
}

class MyClass
{
  // Constant method parameter
  void f(final int A) {}

  final double E = 2.72;         // run-time constant
 
  final static double C = 3e8;   // compile-time constant
 
  final static int RND = (new
  java.util.Random()).nextInt(); // run-time constant
}

*** Interface ***
 
interface MyInterface 
{
  int myMethod(); // method signature

  int c = 10; // constant

  // Types
  class Class {}
  interface Interface {}
  enum Enum {}
}
 
 
// Functionality interface
interface Comparable
{
  int compare(Object o);
}

class Circle implements Comparable
{
  public int r;

  public int compare(Object o) {
    return r - ( (Circle)o ).r;
  }

  public static Object largest(Comparable a, Comparable b)
  {
    return (a.compare(b) > 0) ? a : b;
  }
}
 
 
// Class interface
interface MyInterface
{
  void exposed();
}
 
class MyClass implements MyInterface
{
  public void exposed() {}
  public void hidden() {}
}

class MyApp
{
  public static void main(String[] args)
  {
    MyInterface i = new MyClass();
  }
}

*** Abstract ***
 
abstract class Shape
{
  public int x = 100, y = 100;
  public abstract int getArea();
}

class Rectangle extends Shape
{
  @Override public int getArea() 
  { 
    return x * y; 
  }
}

abstract class Shape
{
  public int x = 100, y = 100;
  public Shape(int a, int b) { x = a; y = b; }
}

class Rectangle extends Shape
{
  public Rectangle(int a, int b) { super(a,b); }
}

*** Enum ***
 
enum Speed
{
  STOP, SLOW, NORMAL, FAST
}
 
 
enum Speed
{
  STOP(0), SLOW(5), NORMAL(10), FAST(20);
  public int speed;
 
  Speed(int s) { speed = s; }
}

class MyApp
{
  public static void main(String[] args)
  {
    Speed[] a = Speed.values();
    Speed s = Speed.valueOf(a[0].toString()); // Speed.STOP
  }
}

*** Exception Handling ***
 
import java.io.*;

class MyApp
{
  public static void main(String[] args)
  {
    try 
    {
      FileReader in = new FileReader("Missing.file");
    }
    catch(FileNotFoundException e) 
    {
      System.out.print(e.getMessage());
    }
    catch(Exception e) 
    {
      System.out.print(e.getMessage());
    }
  }
}
 
 
// Finally block
import java.io.*;

class MyApp
{
  public static void main(String[] args)
  {
    FileReader in = null;
    try {
      in = new FileReader("Missing.file");
    }
    catch(FileNotFoundException e) {
      System.out.print(e.getMessage());
    }
    finally {
      if (in != null) {
        try { in.close(); }
        catch(IOException e) {}
      }
    }
  }
}
 
 
// Throwing exceptions
static void MakeException() throws Throwable
{
  throw new Throwable("My Throwable");
}
 
 
// Specifying exceptions
import java.io.*;

class MyApp
{
  static void MakeException() throws IOException,
                                     ArithmeticException
  {
    throw new IOException("My IO exception");
    //
    throw new ArithmeticException("Division by zero");
  }
}

*** Boxing and Unboxing ***
 
class MyApp
{
  public static void main(String[] args)
  {
    int iPrimitive = 5;
    Integer iWrapper = new Integer(iPrimitive); // boxing
    iPrimitive = iWrapper.intValue(); // unboxing

    Integer iWrapper2 = iPrimitive; // autoboxing
    iPrimitive = iWrapper2;         // autounboxing

    Integer iWrapper3 = Integer.valueOf(iPrimitive);
    iPrimitive = iWrapper3.intValue();

    java.util.ArrayList a = new java.util.ArrayList();
    a.add(Integer.valueOf(5)); // boxing
    a.add(10);                 // autoboxing
  }
}

*** Generics ***
 
// Generic class
class MyBox<T> { public T box; }

class MyApp
{
  public static void main(String[] args)
  {
    MyBox<Integer> iBox  = new MyBox<Integer>();
    MyBox<Integer> iBox2 = new MyBox<>();

    iBox.box = 5;
    Integer i = iBox.box;
  }
}
 
 
// Generic methods
class MyClass
{
  public static <T> void printArray(T[] array)
  {
    for (T element : array)
      System.out.print(element + " ");
  }
}

class MyApp
{
  public static void main(String[] args)
  {
    Integer[] iArray = { 1, 2, 3 };
    MyClass.printArray(iArray); // "1 2 3"
    MyClass.<Integer>printArray(iArray); // "1 2 3" 
  }
}

 
// Generic functionality interface
interface IGenericCollection<T>
{
  public void store(T t);
}
 
// Non-generic class implementing generic interface
class Box implements IGenericCollection<Integer>
{
  public Integer myBox;
  public void store(Integer i) { myBox = i; }
}
 
// Generic class implementing generic interface
class GenericBox<T> implements IGenericCollection<T>
{
  public T myBox;
  public void store(T t) { myBox = t; }
}
 
 
// Generic variable usages
class MyClass<T>
{
  public void myMethod(Object o)
  {
    T t1;                            // allowed
    t1 = null;                       // allowed
    System.out.print(t1.toString()); // allowed
    if (o instanceof T) {}           // invalid
    T t2 = new T();                  // invalid
  }
}
 
 
// Bounded type parameters
// T must be or inherit from superclass A
class B<T extends A> {}
class A {}

// T must be or implement interface I
class C<T extends I> {}
interface I {}

class D<T extends A & I> {}

class E<T extends A & I, U extends A & I> {}
 
 
class Fruit
{
  public String name;
}
 
class FruitBox<T extends Fruit>
{
  private T box;
  public void FruitBox(T t) { box = t; }
  public String getFruitName()
  {
    // Use of Fruit member allowed since T extends Fruit
    return box.name;
  }
}
 
 
// Generics and Object
import java.util.ArrayList;

class MyApp
{
  public static void main(String[] args)
  {
    // Object ArrayList
    ArrayList a = new ArrayList();
    a.add("Hello World");
    //
    Integer b = (Integer)a.get(0); // run-time error
  }
}
 

import java.util.ArrayList;

class MyApp
{
  public static void main(String[] args)
  {
    // Generic ArrayList (recommended)
    ArrayList<String> a = new ArrayList<String>();
    a.add("Hello World");
    //
    Integer b = (Integer)a.get(0); // compile-time error
  }
}
--0--

/*     Java: A Beginner's Guide, 4th Edition     */

     
     
listing 1
/* 
   This is a simple Java program. 
 
   Call this file Example.java. 
*/ 
class Example { 
  // A Java program begins with a call to main(). 
  public static void main(String args[]) { 
    System.out.println("Java drives the Web."); 
  } 
}

listing 2
/*   
   This demonstrates a variable.  
 
   Call this file Example2.java.  
*/   
class Example2 {   
  public static void main(String args[]) {   
    int var1; // this declares a variable  
    int var2; // this declares another variable  
  
    var1 = 1024; // this assigns 1024 to var1  
  
    System.out.println("var1 contains " + var1);   
  
    var2 = var1 / 2;  
  
    System.out.print("var2 contains var1 / 2: ");  
    System.out.println(var2);  
  }   
}

listing 3
/*  
   This program illustrates the differences 
   between int and double. 
 
   Call this file Example3.java. 
*/  
class Example3 {  
  public static void main(String args[]) {  
    int var;  // this declares an int variable 
    double x; // this declares a floating-point variable 
 
    var = 10; // assign var the value 10 
    
    x = 10.0; // assign x the value 10.0 
 
    System.out.println("Original value of var: " + var); 
    System.out.println("Original value of x: " + x); 
 
    System.out.println(); // print a blank line 
 
    // now, divide both by 4 
    var = var / 4;  
    x = x / 4; 
 
    System.out.println("var after division: " + var); 
    System.out.println("x after division: " + x); 
  }  
}

listing 4
/*  
   Project 1-1 
 
   This program converts gallons to liters. 
 
   Call this program GalToLit.java. 
*/  
class GalToLit {  
  public static void main(String args[]) {  
    double gallons; // holds the number of gallons 
    double liters;  // holds conversion to liters 
 
    gallons = 10; // start with 10 gallons 
 
    liters = gallons * 3.7854; // convert to liters 
 
    System.out.println(gallons + " gallons is " + liters + " liters."); 
  }  
}

listing 5
/*  
  Demonstrate the if.  
  
  Call this file IfDemo.java.  
*/  
class IfDemo {  
  public static void main(String args[]) {  
    int a, b, c;  
  
    a = 2;  
    b = 3;  
  
    if(a < b) System.out.println("a is less than b"); 
 
    // this won't display anything  
    if(a == b) System.out.println("you won't see this");  
 
    System.out.println(); 
 
    c = a - b; // c contains -1 
 
    System.out.println("c contains -1"); 
    if(c >= 0) System.out.println("c is non-negative"); 
    if(c < 0) System.out.println("c is negative"); 
 
    System.out.println(); 
 
    c = b - a; // c now contains 1 
    System.out.println("c contains 1"); 
    if(c >= 0) System.out.println("c is non-negative"); 
    if(c < 0) System.out.println("c is negative"); 
 
  }  
}

listing 6
/* 
  Demonstrate the for loop. 
 
  Call this file ForDemo.java. 
*/ 
class ForDemo { 
  public static void main(String args[]) { 
    int count; 
 
    for(count = 0; count < 5; count = count+1) 
      System.out.println("This is count: " + count); 
 
    System.out.println("Done!"); 
  } 
}

listing 7
/* 
  Demonstrate a block of code. 
 
  Call this file BlockDemo.java. 
*/ 
class BlockDemo { 
  public static void main(String args[]) { 
    double i, j, d; 
 
    i = 5; 
    j = 10; 
 
    // the target of this if is a block 
    if(i != 0) { 
      System.out.println("i does not equal zero"); 
      d = j / i; 
      System.out.print("j / i is " + d); 
    } 
  } 
}

listing 8
/*  
   Project 1-2 
 
   This program displays a conversion  
   table of gallons to liters. 
 
   Call this program "GalToLitTable.java". 
*/  
class GalToLitTable {  
  public static void main(String args[]) {  
    double gallons, liters; 
    int counter; 
 
    counter = 0; 
    for(gallons = 1; gallons <= 100; gallons++) { 
      liters = gallons * 3.7854; // convert to liters 
      System.out.println(gallons + " gallons is " + 
                         liters + " liters."); 
 
      counter++; 
      // every 10th line, print a blank line        
      if(counter == 10) { 
        System.out.println(); 
        counter = 0; // reset the line counter 
      } 
    } 
  }  
}

listing 1
/*    
   Compute the number of cubic inches 
   in 1 cubic mile. 
*/    
class Inches {    
  public static void main(String args[]) {    
    long ci; 
    long im; 
   
    im = 5280 * 12; 
 
    ci = im * im * im; 
   
    System.out.println("There are " + ci + 
                       " cubic inches in cubic mile."); 
   
  }    
}

listing 2
/*    
   Use the Pythagorean theorem to find 
   find the length of the hypotenuse 
   given the lengths of the two opposing 
   sides. 
*/    
class Hypot {    
  public static void main(String args[]) {    
    double x, y, z; 
 
    x = 3; 
    y = 4; 
 
    z = Math.sqrt(x*x + y*y); 
 
    System.out.println("Hypotenuse is " +z); 
  }    
}

listing 3
// Character variables can be handled like integers.  
class CharArithDemo { 
  public static void main(String args[]) { 
    char ch; 
 
    ch = 'X'; 
    System.out.println("ch contains " + ch); 
 
    ch++; // increment ch 
    System.out.println("ch is now " + ch); 
 
    ch = 90; // give ch the value Z 
    System.out.println("ch is now " + ch); 
  } 
}

listing 4
// Demonstrate boolean values. 
class BoolDemo { 
  public static void main(String args[]) { 
    boolean b; 
 
    b = false; 
    System.out.println("b is " + b); 
    b = true; 
    System.out.println("b is " + b); 
 
    // a boolean value can control the if statement 
    if(b) System.out.println("This is executed."); 
 
    b = false; 
    if(b) System.out.println("This is not executed."); 
 
    // outcome of a relational operator is a boolean value 
    System.out.println("10 > 9 is " + (10 > 9)); 
  } 
}

listing 5
/* 
   Project 2-1 
 
   Compute the distance to a lightening 
   strke whose sound takes 7.2 seconds 
   to reach you. 
*/     
class Sound {     
  public static void main(String args[]) {     
    double dist; 
 
    dist = 7.2 * 1100; 
 
    System.out.println("The lightening is " + dist +  
                       " feet away.");  
    
  }     
}

listing 6
// Demonstrate escape sequences in strings. 
class StrDemo {    
  public static void main(String args[]) {    
    System.out.println("First line\nSecond line"); 
    System.out.println("A\tB\tC"); 
    System.out.println("D\tE\tF"); 
  }    
}

listing 7
// Demonstrate dynamic initialization. 
class DynInit { 
    public static void main(String args[]) { 
      double radius = 4, height = 5; 
 
      // dynamically initializ volume 
      double volume = 3.1416 * radius * radius * height; 
 
      System.out.println("Volume is " + volume); 
    } 
}

listing 8
// Demonstrate block scope. 
class ScopeDemo { 
  public static void main(String args[]) { 
    int x; // known to all code within main 
 
    x = 10; 
    if(x == 10) { // start new scope
      int y = 20; // known only to this block 
 
       // x and y both known here. 
       System.out.println("x and y: " + x + " " + y); 
       x = y * 2; 
    } 
    // y = 100; // Error! y not known here  
 
    // x is still known here. 
    System.out.println("x is " + x); 
  } 
}

listing 9
// Demonstrate lifetime of a variable. 
class VarInitDemo { 
  public static void main(String args[]) { 
    int x;  
 
    for(x = 0; x < 3; x++) { 
      int y = -1; // y is initialized each time block is entered 
      System.out.println("y is: " + y); // this always prints -1 
      y = 100;  
      System.out.println("y is now: " + y); 
    } 
  } 
}

listing 10
/*  
   This program attempts to declared a variable 
   in an inner scope with the same name as one 
   defined in an outer scope. 
 
   *** This program will not compile. *** 
*/  
class NestVar {  
  public static void main(String args[]) {  
    int count;  
 
    for(count = 0; count < 10; count = count+1) { 
      System.out.println("This is count: " + count);  
     
      int count; // illegal!!! 
      for(count = 0; count < 2; count++) 
        System.out.println("This program is in error!"); 
    } 
  }  
}

listing 11
// Demonstrate the % operator. 
class ModDemo {    
  public static void main(String args[]) {    
    int iresult, irem; 
    double dresult, drem; 
 
    iresult = 10 / 3; 
    irem = 10 % 3; 
 
    dresult = 10.0 / 3.0; 
    drem = 10.0 % 3.0;  
 
    System.out.println("Result and remainder of 10 / 3: " + 
                       iresult + " " + irem); 
    System.out.println("Result and remainder of 10.0 / 3.0: " + 
                       dresult + " " + drem); 
 
  }    
}

listing 12
// Demonstrate the relational and logical operators. 
class RelLogOps {    
  public static void main(String args[]) {    
    int i, j; 
    boolean b1, b2; 
 
    i = 10; 
    j = 11; 
    if(i < j) System.out.println("i < j"); 
    if(i <= j) System.out.println("i <= j"); 
    if(i != j) System.out.println("i != j"); 
    if(i == j) System.out.println("this won't execute"); 
    if(i >= j) System.out.println("this won't execute"); 
    if(i > j) System.out.println("this won't execute"); 
 
    b1 = true; 
    b2 = false; 
    if(b1 & b2) System.out.println("this won't execute"); 
    if(!(b1 & b2)) System.out.println("!(b1 & b2) is true"); 
    if(b1 | b2) System.out.println("b1 | b2 is true"); 
    if(b1 ^ b2) System.out.println("b1 ^ b2 is true"); 
  }    
}

listing 13
// Demonstrate the short-circuit operators. 
class SCops {    
  public static void main(String args[]) {    
    int n, d, q; 
 
    n = 10; 
    d = 2; 
    if(d != 0 && (n % d) == 0) 
      System.out.println(d + " is a factor of " + n); 
 
    d = 0; // now, set d to zero 
 
    // Since d is zero, the second operand is not evaluated. 
    if(d != 0 && (n % d) == 0) 
      System.out.println(d + " is a factor of " + n);  
     
    /* Now, try same thing without short-circuit operator. 
       This will cause a divide-by-zero error. 
    */ 
    if(d != 0 & (n % d) == 0) 
      System.out.println(d + " is a factor of " + n); 
  }    
}

listing 14
// Side-effects can be important. 
class SideEffects {    
  public static void main(String args[]) {    
    int i; 
 
    i = 0; 
 
    /* Here, i is still incremented even though 
       the if statement fails. */ 
    if(false & (++i < 100)) 
       System.out.println("this won't be displayed"); 
    System.out.println("if statements executed: " + i); // displays 1 
 
    /* In this case, i is not incremented because 
       the short-circuit operator skips the increment. */ 
    if(false && (++i < 100)) 
      System.out.println("this won't be displayed"); 
    System.out.println("if statements executed: " + i); // still 1 !! 
  }    
}

listing 15
// Demonstate automatic conversion from long to double. 
class LtoD {    
  public static void main(String args[]) {    
    long L; 
    double D; 
   
    L = 100123285L; 
    D = L; 
   
    System.out.println("L and D: " + L + " " + D); 
   
  }    
}

listing 16
// *** This program will not compile. *** 
class LtoD {    
  public static void main(String args[]) {    
    long L; 
    double D; 
   
    D = 100123285.0; 
    L = D; // Illegal!!! 
   
    System.out.println("L and D: " + L + " " + D); 
   
  }    
}

listing 17
// Demonstrate casting.    
class CastDemo {    
  public static void main(String args[]) {    
    double x, y; 
    byte b; 
    int i; 
    char ch; 
 
    x = 10.0; 
    y = 3.0; 
 
    i = (int) (x / y); // cast double to int 
    System.out.println("Integer outcome of x / y: " + i); 
 
    i = 100; 
    b = (byte) i;  
    System.out.println("Value of b: " + b); 
 
    i = 257; 
    b = (byte) i;  
    System.out.println("Value of b: " + b); 
 
    b = 88; // ASCII code for X 
    ch = (char) b; 
    System.out.println("ch: " + ch);  
  }    
}

listing 18
/* 
   Project 2-2 
 
   Print a truth table for the logical operators. 
*/ 
class LogicalOpTable {    
  public static void main(String args[]) {    
 
    boolean p, q; 
 
    System.out.println("P\tQ\tAND\tOR\tXOR\tNOT"); 
 
    p = true; q = true; 
    System.out.print(p + "\t" + q +"\t"); 
    System.out.print((p&q) + "\t" + (p|q) + "\t"); 
    System.out.println((p^q) + "\t" + (!p)); 
 
    p = true; q = false; 
    System.out.print(p + "\t" + q +"\t"); 
    System.out.print((p&q) + "\t" + (p|q) + "\t"); 
    System.out.println((p^q) + "\t" + (!p)); 
 
    p = false; q = true; 
    System.out.print(p + "\t" + q +"\t"); 
    System.out.print((p&q) + "\t" + (p|q) + "\t"); 
    System.out.println((p^q) + "\t" + (!p)); 
 
    p = false; q = false; 
    System.out.print(p + "\t" + q +"\t"); 
    System.out.print((p&q) + "\t" + (p|q) + "\t"); 
    System.out.println((p^q) + "\t" + (!p)); 
  }    
}

listing 19
// A promotion surprise! 
class PromDemo {    
  public static void main(String args[]) {    
    byte b; 
    int i; 
   
    b = 10; 
    i = b * b; // OK, no cast needed 
 
    b = 10; 
    b = (byte) (b * b); // cast needed!! 
 
    System.out.println("i and b: " + i + " " + b); 
  }    
}

listing 20
// Using a cast. 
class UseCast {    
  public static void main(String args[]) {    
    int i; 
 
    for(i = 0; i < 5; i++) { 
      System.out.println(i + " / 3: " + i / 3); 
      System.out.println(i + " / 3 with fractions: " 
                         + (double) i / 3); 
      System.out.println(); 
    } 
  }    
}

listing 1
// Read a character from the keyboard. 
class KbIn {   
  public static void main(String args[])   
    throws java.io.IOException { 
 
    char ch; 
 
    System.out.print("Press a key followed by ENTER: "); 
 
    ch = (char) System.in.read(); // get a char 
    
    System.out.println("Your key is: " + ch); 
  }   
}

listing 2
// Guess the letter game.  
class Guess {   
  public static void main(String args[])   
    throws java.io.IOException { 
 
    char ch, answer = 'K'; 
 
    System.out.println("I'm thinking of a letter between A and Z."); 
    System.out.print("Can you guess it: "); 
 
    ch = (char) System.in.read(); // read a char from the keyboard 
    
    if(ch == answer) System.out.println("** Right **"); 
  }   
}

listing 3
// Guess the letter game, 2nd version.  
class Guess2 {   
  public static void main(String args[])   
    throws java.io.IOException { 
 
    char ch, answer = 'K'; 
 
    System.out.println("I'm thinking of a letter between A and Z."); 
    System.out.print("Can you guess it: "); 
 
    ch = (char) System.in.read(); // get a char 
    
    if(ch == answer) System.out.println("** Right **"); 
    else System.out.println("...Sorry, you're wrong."); 
  }   
}

listing 4
// Guess the letter game, 3rd version.  
class Guess3 {   
  public static void main(String args[])   
    throws java.io.IOException { 
 
    char ch, answer = 'K'; 
 
    System.out.println("I'm thinking of a letter between A and Z."); 
    System.out.print("Can you guess it: "); 
 
    ch = (char) System.in.read(); // get a char 
    
    if(ch == answer) System.out.println("** Right **"); 
    else { 
      System.out.print("...Sorry, you're "); 
 
      // a nested if 
      if(ch < answer) System.out.println("too low"); 
      else System.out.println("too high"); 
    } 
  }   
}

listing 5
// Demonstrate an if-else-if ladder.  
class Ladder {    
  public static void main(String args[]) {    
    int x; 
  
    for(x=0; x<6; x++) {  
      if(x==1) 
        System.out.println("x is one");  
      else if(x==2)  
        System.out.println("x is two"); 
      else if(x==3)  
        System.out.println("x is three");  
      else if(x==4)  
        System.out.println("x is four");  
      else  
        System.out.println("x is not between 1 and 4");  
    }  
  } 
}

listing 6
// Demonstrate the switch. 
class SwitchDemo {   
  public static void main(String args[]) { 
    int i; 
 
    for(i=0; i<10; i++) 
      switch(i) { 
        case 0:  
          System.out.println("i is zero"); 
          break; 
        case 1:  
          System.out.println("i is one"); 
          break; 
        case 2:  
          System.out.println("i is two"); 
          break; 
        case 3:  
          System.out.println("i is three"); 
          break; 
        case 4:  
          System.out.println("i is four"); 
          break; 
        default:  
          System.out.println("i is five or more"); 
      } 
      
  }   
}

listing 7
// Demonstrate the switch without break statements. 
class NoBreak {   
  public static void main(String args[]) { 
    int i; 
 
    for(i=0; i<=5; i++) { 
      switch(i) { 
        case 0:  
          System.out.println("i is less than one"); 
        case 1:  
          System.out.println("i is less than two"); 
        case 2:  
          System.out.println("i is less than three"); 
        case 3:  
          System.out.println("i is less than four"); 
        case 4:  
          System.out.println("i is less than five"); 
      } 
      System.out.println(); 
    } 
  }   
}

listing 8
switch(i) { 
  case 1: 
  case 2: 
  case 3: System.out.println("i is 1, 2 or 3"); 
    break; 
  case 4: System.out.println("i is 4"); 
    break; 
}

listing 9
switch(ch1) { 
  case 'A': System.out.println("This A is part of outer switch."); 
    switch(ch2) { 
      case 'A':  
        System.out.println("This A is part of inner switch"); 
        break; 
      case 'B': // ... 
    } // end of inner switch 
    break; 
  case 'B': // ...

listing 10
/* 
   Project 3-1 
 
   A simple help system. 
*/ 
class Help { 
  public static void main(String args[])  
    throws java.io.IOException { 
    char choice; 
 
    System.out.println("Help on:"); 
    System.out.println("  1. if"); 
    System.out.println("  2. switch"); 
    System.out.print("Choose one: "); 
    choice = (char) System.in.read(); 
 
    System.out.println("\n"); 
  
    switch(choice) { 
      case '1': 
        System.out.println("The if:\n"); 
        System.out.println("if(condition) statement;"); 
        System.out.println("else statement;"); 
        break; 
      case '2': 
        System.out.println("The switch:\n"); 
        System.out.println("switch(expression) {"); 
        System.out.println("  case constant:"); 
        System.out.println("    statement sequence"); 
        System.out.println("    break;"); 
        System.out.println("  // ..."); 
        System.out.println("}"); 
        break; 
      default: 
        System.out.print("Selection not found."); 
    } 
  } 
}

listing 11
// Show square roots of 1 to 99 and the rounding error. 
class SqrRoot {     
  public static void main(String args[]) {     
    double num, sroot, rerr;  
 
    for(num = 1.0; num < 100.0; num++) {  
      sroot = Math.sqrt(num); 
      System.out.println("Square root of " + num + 
                          " is " + sroot); 
 
      // compute rounding error 
      rerr = num - (sroot * sroot); 
      System.out.println("Rounding error is " + rerr); 
      System.out.println(); 
    }  
  }     
}

listing 12
// A negatively running for loop. 
class DecrFor {     
  public static void main(String args[]) {     
    int x; 
 
    for(x = 100; x > -100; x -= 5) 
      System.out.println(x); 
  }     
}

listing 13
for(count=10; count < 5; count++) 
  x += count; // this statement will not execute

listing 14
// Use commas in a for statememt.    
class Comma {    
  public static void main(String args[]) {    
    int i, j; 
 
    for(i=0, j=10; i < j; i++, j--) 
      System.out.println("i and j: " + i + " " + j); 
 
   
  }    
}

listing 15
// Loop until an S is typed. 
class ForTest {   
  public static void main(String args[])   
    throws java.io.IOException { 
 
    int i; 
 
    System.out.println("Press S to stop."); 
 
    for(i = 0; (char) System.in.read() != 'S'; i++) 
      System.out.println("Pass #" + i); 
  }   
}

listing 16
// Parts of the for can be empty. 
class Empty {   
  public static void main(String args[]) { 
    int i; 
 
    for(i = 0; i < 10; ) { 
      System.out.println("Pass #" + i); 
      i++; // increment loop control var 
    } 
  }   
}

listing 17
// Move more out of the for loop. 
class Empty2 {   
  public static void main(String args[]) { 
    int i; 
 
    i = 0; // move initialization out of loop 
    for(; i < 10; ) { 
      System.out.println("Pass #" + i); 
      i++; // increment loop control var 
    } 
  }   
}

listing 18
// The body of a loop can be empty. 
class Empty3 {   
  public static void main(String args[]) { 
    int i; 
    int sum = 0; 
 
    // sum the numbers through 5  
    for(i = 1; i <= 5; sum += i++) ; 
 
    System.out.println("Sum is " + sum); 
  }   
}

listing 19
// Declare loop control variable inside the for. 
class ForVar {   
  public static void main(String args[]) { 
    int sum = 0; 
    int fact = 1; 
 
    // compute the factorial of the numbers through 5  
    for(int i = 1; i <= 5; i++) {  
      sum += i;  // i is known throughout the loop 
      fact *= i; 
    } 
 
    // but, i is not known here. 
 
    System.out.println("Sum is " + sum); 
    System.out.println("Factorial is " + fact); 
  }   
}

listing 20
// Demonstrate the while loop. 
class WhileDemo {   
  public static void main(String args[]) { 
    char ch; 
 
    // print the alphabet using a while loop 
    ch = 'a'; 
    while(ch <= 'z') { 
      System.out.print(ch); 
      ch++; 
    } 
  }   
}

listing 21
// Compute integer powers of 2. 
class Power {   
  public static void main(String args[]) { 
    int e; 
    int result; 
 
    for(int i=0; i < 10; i++) { 
      result = 1; 
      e = i; 
      while(e > 0) { 
        result *= 2; 
        e--; 
      } 
 
      System.out.println("2 to the " + i +  
                         " power is " + result);        
    } 
  }   
} 


listing 22
// Demonstrate the do-while loop. 
class DWDemo {   
  public static void main(String args[])   
    throws java.io.IOException { 
 
    char ch; 
 
    do { 
      System.out.print("Press a key following by ENTER: "); 
      ch = (char) System.in.read(); // get a char 
    } while(ch != 'q'); 
  }   
}

listing 23
// Guess the letter game, 4rd version.  
class Guess4 {   
  public static void main(String args[])   
    throws java.io.IOException { 
 
    char ch, answer = 'K'; 
 
    do { 
      System.out.println("I'm thinking of a letter between A and Z."); 
      System.out.print("Can you guess it: "); 
 
      // read a letter, but skip cr/lf 
      do { 
        ch = (char) System.in.read(); // get a char 
      } while(ch == '\n' | ch == '\r'); 
      
      if(ch == answer) System.out.println("** Right **"); 
      else { 
        System.out.print("...Sorry, you're "); 
        if(ch < answer) System.out.println("too low"); 
        else System.out.println("too high"); 
        System.out.println("Try again!\n"); 
      } 
    } while(answer != ch); 
  }   
}

listing 24
/* 
   Project 3-2 
 
   An improved Help system that uses a 
   a do-while to process a menu selection. 
*/ 
class Help2 { 
  public static void main(String args[])  
    throws java.io.IOException { 
    char choice; 
 
    do { 
      System.out.println("Help on:"); 
      System.out.println("  1. if"); 
      System.out.println("  2. switch"); 
      System.out.println("  3. for"); 
      System.out.println("  4. while"); 
      System.out.println("  5. do-while\n"); 
      System.out.print("Choose one: "); 
      do { 
        choice = (char) System.in.read(); 
      } while(choice == '\n' | choice == '\r');     
    } while( choice < '1' | choice > '5'); 
 
    System.out.println("\n"); 
  
    switch(choice) { 
      case '1': 
        System.out.println("The if:\n"); 
        System.out.println("if(condition) statement;"); 
        System.out.println("else statement;"); 
        break; 
      case '2': 
        System.out.println("The switch:\n"); 
        System.out.println("switch(expression) {"); 
        System.out.println("  case constant:"); 
        System.out.println("    statement sequence"); 
        System.out.println("    break;"); 
        System.out.println("  // ..."); 
        System.out.println("}"); 
        break; 
      case '3': 
        System.out.println("The for:\n"); 
        System.out.print("for(init; condition; iteration)"); 
        System.out.println(" statement;"); 
        break; 
      case '4': 
        System.out.println("The while:\n"); 
        System.out.println("while(condition) statement;"); 
        break; 
      case '5': 
        System.out.println("The do-while:\n"); 
        System.out.println("do {"); 
        System.out.println("  statement;"); 
        System.out.println("} while (condition);"); 
        break; 
    } 
  } 
}

listing 25
// Using break to exit a loop.   
class BreakDemo {  
  public static void main(String args[]) {  
    int num; 
 
    num = 100; 
 
    // loop while i-squared is less than num 
    for(int i=0; i < num; i++) {  
      if(i*i >= num) break; // terminate loop if i*i >= 100  
      System.out.print(i + " ");  
    }  
    System.out.println("Loop complete.");  
  }  
}

listing 26
// Read input until a q is received. 
class Break2 {   
  public static void main(String args[])   
    throws java.io.IOException { 
 
    char ch; 
 
    for( ; ; ) { 
      ch = (char) System.in.read(); // get a char 
      if(ch == 'q') break; 
    } 
    System.out.println("You pressed q!"); 
  }   
}

listing 27
// Using break with nested loops.  
class Break3 {  
  public static void main(String args[]) {  
  
    for(int i=0; i<3; i++) {  
      System.out.println("Outer loop count: " + i);  
      System.out.print("    Inner loop count: "); 
 
      int t = 0;             
      while(t < 100) {  
        if(t == 10) break; // terminate loop if t is 10  
        System.out.print(t + " ");  
        t++; 
      }  
      System.out.println();  
    }  
    System.out.println("Loops complete.");  
  }  
}

listing 28
// Using break with a  label. 
class Break4 {  
  public static void main(String args[]) {  
    int i; 
     
    for(i=1; i<4; i++) { 
one:  { 
two:    { 
three:    { 
            System.out.println("\ni is " + i); 
            if(i==1) break one; 
            if(i==2) break two; 
            if(i==3) break three; 
              
            // this is never reached 
            System.out.println("won't print"); 
          } 
          System.out.println("After block three."); 
        } 
        System.out.println("After block two."); 
      } 
      System.out.println("After block one."); 
    } 
    System.out.println("After for."); 
   
  }  
}

listing 29
// Another example of using break with a label. 
class Break5 {  
  public static void main(String args[]) {  
 
done: 
    for(int i=0; i<10; i++) { 
      for(int j=0; j<10; j++) { 
        for(int k=0; k<10; k++) { 
          System.out.println(k + " "); 
          if(k == 5) break done; // jump to done 
        } 
        System.out.println("After k loop"); // won't execute 
      } 
      System.out.println("After j loop"); // won't execute 
    } 
    System.out.println("After i loop");  
  }  
}

listing 30
// Where you put a label is important. 
class Break6 {  
  public static void main(String args[]) {  
    int x=0, y=0; 
 
// here, put label before for statement. 
stop1: for(x=0; x < 5; x++) { 
         for(y = 0; y < 5; y++) { 
           if(y == 2) break stop1; 
           System.out.println("x and y: " + x + " " + y);  
         } 
       } 
 
       System.out.println(); 
 
// now, put label immediately before { 
      for(x=0; x < 5; x++) 
stop2: { 
         for(y = 0; y < 5; y++) { 
           if(y == 2) break stop2; 
           System.out.println("x and y: " + x + " " + y);  
         } 
       } 
 
  }  
}

listing 31
// This program contains an error. 
class BreakErr { 
  public static void main(String args[]) { 
 
    one: for(int i=0; i<3; i++) { 
      System.out.print("Pass " + i + ": "); 
    } 
 
    for(int j=0; j<100; j++) { 
      if(j == 10) break one; // WRONG 
      System.out.print(j + " "); 
    } 
  } 
}

listing 32
// Use continue. 
class ContDemo {   
  public static void main(String args[]) { 
    int i; 
 
    // print even number between 0 and 100 
    for(i = 0; i<=100; i++) {  
      if((i%2) != 0) continue; // iterate 
      System.out.println(i); 
    } 
  }   
}

listing 33
// Use continue with a label. 
class ContToLabel {   
  public static void main(String args[]) { 
 
outerloop: 
    for(int i=1; i < 10; i++) { 
      System.out.print("\nOuter loop pass " + i + 
                       ", Inner loop: "); 
      for(int j = 1; j < 10; j++) { 
        if(j == 5) continue outerloop; // continue outer loop 
        System.out.print(j); 
      } 
    } 
  }   
}

listing 34
/* 
   Project 3-3 
 
   The finished Java statement Help system  
   that process multiple requests. 
*/ 
class Help3 { 
  public static void main(String args[])  
    throws java.io.IOException { 
    char choice; 
 
    for(;;) { 
      do { 
        System.out.println("Help on:"); 
        System.out.println("  1. if"); 
        System.out.println("  2. switch"); 
        System.out.println("  3. for"); 
        System.out.println("  4. while"); 
        System.out.println("  5. do-while"); 
        System.out.println("  6. break"); 
        System.out.println("  7. continue\n"); 
        System.out.print("Choose one (q to quit): "); 
        do { 
          choice = (char) System.in.read(); 
        } while(choice == '\n' | choice == '\r');     
      } while( choice < '1' | choice > '7' & choice != 'q'); 
 
      if(choice == 'q') break; 
 
      System.out.println("\n"); 
  
      switch(choice) { 
        case '1': 
          System.out.println("The if:\n"); 
          System.out.println("if(condition) statement;"); 
          System.out.println("else statement;"); 
          break; 
        case '2': 
          System.out.println("The switch:\n"); 
          System.out.println("switch(expression) {"); 
          System.out.println("  case constant:"); 
          System.out.println("    statement sequence"); 
          System.out.println("    break;"); 
          System.out.println("  // ..."); 
          System.out.println("}"); 
          break; 
        case '3': 
          System.out.println("The for:\n"); 
          System.out.print("for(init; condition; iteration)"); 
          System.out.println(" statement;"); 
          break; 
        case '4': 
          System.out.println("The while:\n"); 
          System.out.println("while(condition) statement;"); 
          break; 
        case '5': 
          System.out.println("The do-while:\n"); 
          System.out.println("do {"); 
          System.out.println("  statement;"); 
          System.out.println("} while (condition);"); 
          break; 
        case '6': 
          System.out.println("The break:\n"); 
          System.out.println("break; or break label;"); 
          break; 
        case '7': 
          System.out.println("The continue:\n"); 
          System.out.println("continue; or continue label;"); 
          break; 
      } 
      System.out.println(); 
    } 
  } 
}

listing 35
/*  
   Use nested loops to find factors of numbers 
   between 2 and 100. 
*/ 
class FindFac {   
  public static void main(String args[]) { 
 
    for(int i=2; i <= 100; i++) { 
      System.out.print("Factors of " + i + ": "); 
      for(int j = 2; j < i; j++) 
        if((i%j) == 0) System.out.print(j + " "); 
      System.out.println(); 
    } 
  }   
}

listing 1
/* A program that uses the Vehicle class.  
  
   Call this file VehicleDemo.java  
*/  
class Vehicle {  
  int passengers; // number of passengers  
  int fuelcap;    // fuel capacity in gallons 
  int mpg;        // fuel consumption in miles per gallon 
}  
  
// This class declares an object of type Vehicle.  
class VehicleDemo {  
  public static void main(String args[]) {  
    Vehicle minivan = new Vehicle();  
    int range;  
  
    // assign values to fields in minivan 
    minivan.passengers = 7; 
    minivan.fuelcap = 16; 
    minivan.mpg = 21; 
  
    // compute the range assuming a full tank of gas 
    range = minivan.fuelcap * minivan.mpg; 
  
    System.out.println("Minivan can carry " + minivan.passengers + 
                       " with a range of " + range);  
  }  
}

listing 2
// This program creates two Vehicle objects. 
 
class Vehicle {  
  int passengers; // number of passengers  
  int fuelcap;    // fuel capacity in gallons 
  int mpg;        // fuel consumption in miles per gallon 
}  
  
// This class declares an object of type Vehicle.  
class TwoVehicles {  
  public static void main(String args[]) {  
    Vehicle minivan = new Vehicle();  
    Vehicle sportscar = new Vehicle();  
 
    int range1, range2;  
  
    // assign values to fields in minivan 
    minivan.passengers = 7; 
    minivan.fuelcap = 16; 
    minivan.mpg = 21; 
  
    // assign values to fields in sportscar 
    sportscar.passengers = 2; 
    sportscar.fuelcap = 14; 
    sportscar.mpg = 12; 
  
    // compute the ranges assuming a full tank of gas 
    range1 = minivan.fuelcap * minivan.mpg; 
    range2 = sportscar.fuelcap * sportscar.mpg; 
  
    System.out.println("Minivan can carry " + minivan.passengers + 
                       " with a range of " + range1);  
 
    System.out.println("Sportscar can carry " + sportscar.passengers + 
                       " with a range of " + range2);  
  }  
}

listing 3
// Add range to Vehicle. 
 
class Vehicle {  
  int passengers; // number of passengers  
  int fuelcap;    // fuel capacity in gallons 
  int mpg;        // fuel consumption in miles per gallon 
 
  // Display the range. 
  void range() { 
    System.out.println("Range is " + fuelcap * mpg); 
  } 
}  
  
class AddMeth {  
  public static void main(String args[]) {  
    Vehicle minivan = new Vehicle();  
    Vehicle sportscar = new Vehicle();  
 
    int range1, range2;  
  
    // assign values to fields in minivan 
    minivan.passengers = 7; 
    minivan.fuelcap = 16; 
    minivan.mpg = 21; 
  
    // assign values to fields in sportscar 
    sportscar.passengers = 2; 
    sportscar.fuelcap = 14; 
    sportscar.mpg = 12; 
  
 
    System.out.print("Minivan can carry " + minivan.passengers + 
                     ". "); 
 
    minivan.range(); // display range of minivan 
 
    System.out.print("Sportscar can carry " + sportscar.passengers + 
                     ". "); 
     
    sportscar.range(); // display range of sportscar. 
  }  
}

listing 4
void myMeth() { 
  int i; 
 
  for(i=0; i<10; i++) { 
    if(i == 5) return; // stop at 5 
    System.out.println(); 
  } 
}

listing 5
// Use a return value. 
 
class Vehicle {  
  int passengers; // number of passengers  
  int fuelcap;    // fuel capacity in gallons 
  int mpg;        // fuel consumption in miles per gallon 
 
  // Return the range. 
  int range() { 
    return mpg * fuelcap; 
  } 
}  
  
class RetMeth {  
  public static void main(String args[]) {  
    Vehicle minivan = new Vehicle();  
    Vehicle sportscar = new Vehicle();  
 
    int range1, range2;  
  
    // assign values to fields in minivan 
    minivan.passengers = 7; 
    minivan.fuelcap = 16; 
    minivan.mpg = 21; 
  
    // assign values to fields in sportscar 
    sportscar.passengers = 2; 
    sportscar.fuelcap = 14; 
    sportscar.mpg = 12; 
  
    // get the ranges 
    range1 = minivan.range(); 
    range2 = sportscar.range(); 
 
 
    System.out.println("Minivan can carry " + minivan.passengers + 
                     " with range of " + range1 + " Miles"); 
 
 
    System.out.println("Sportscar can carry " + sportscar.passengers + 
                     " with range of " + range2 + " miles"); 
     
  }  
}

listing 6
// A simple example that uses a parameter. 
 
class ChkNum {  
  // return true if x is even 
  boolean isEven(int x) { 
    if((x%2) == 0) return true;  
    else return false; 
  } 
}  
  
class ParmDemo {  
  public static void main(String args[]) {  
    ChkNum e = new ChkNum(); 
 
    if(e.isEven(10)) System.out.println("10 is even."); 
 
    if(e.isEven(9)) System.out.println("9 is even."); 
 
    if(e.isEven(8)) System.out.println("8 is even."); 
 
  }  
}

listing 7
class Factor { 
  boolean isFactor(int a, int b) { 
    if( (b % a) == 0) return true; 
    else return false; 
  } 
} 
class IsFact {  
  public static void main(String args[]) {    
    Factor x = new Factor(); 
 
    if(x.isFactor(2, 20)) System.out.println("2 is factor"); 
    if(x.isFactor(3, 20)) System.out.println("this won't be displayed"); 
 
  } 
}

listing 8
/* 
   Add a parameterized method that computes the  
   fuel required for a given distince. 
*/ 
 
class Vehicle {  
  int passengers; // number of passengers  
  int fuelcap;    // fuel capacity in gallons 
  int mpg;        // fuel consumption in miles per gallon 
 
  // Return the range. 
  int range() { 
    return mpg * fuelcap; 
  } 
 
  // Compute fuel needed for a given distance. 
  double fuelneeded(int miles) { 
    return (double) miles / mpg; 
  } 
}  
  
class CompFuel {  
  public static void main(String args[]) {  
    Vehicle minivan = new Vehicle();  
    Vehicle sportscar = new Vehicle();  
    double gallons; 
    int dist = 252; 
 
     // assign values to fields in minivan 
    minivan.passengers = 7; 
    minivan.fuelcap = 16; 
    minivan.mpg = 21; 
  
    // assign values to fields in sportscar 
    sportscar.passengers = 2; 
    sportscar.fuelcap = 14; 
    sportscar.mpg = 12; 
 
    gallons = minivan.fuelneeded(dist);  
  
    System.out.println("To go " + dist + " miles minivan needs " + 
                       gallons + " gallons of fuel."); 
     
    gallons = sportscar.fuelneeded(dist);  
  
    System.out.println("To go " + dist + " miles sportscar needs " + 
                       gallons + " gallons of fuel."); 
     
  }  
}

listing 9
/*  
   Project 4-1  
  
   Convert the help system from Project 3-3 into  
   a Help class. 
*/  
 
class Help { 
  void helpon(int what) { 
    switch(what) {  
      case '1':  
        System.out.println("The if:\n");  
        System.out.println("if(condition) statement;");  
        System.out.println("else statement;");  
        break;  
      case '2':  
        System.out.println("The switch:\n");  
        System.out.println("switch(expression) {");  
        System.out.println("  case constant:");  
        System.out.println("    statement sequence");  
        System.out.println("    break;");  
        System.out.println("  // ...");  
        System.out.println("}");  
        break;  
      case '3':  
        System.out.println("The for:\n");  
        System.out.print("for(init; condition; iteration)");  
        System.out.println(" statement;");  
        break;  
      case '4':  
        System.out.println("The while:\n");  
        System.out.println("while(condition) statement;");  
        break;  
      case '5':  
        System.out.println("The do-while:\n");  
        System.out.println("do {");  
        System.out.println("  statement;");  
        System.out.println("} while (condition);");  
        break;  
      case '6':  
        System.out.println("The break:\n");  
        System.out.println("break; or break label;");  
        break;  
      case '7':  
        System.out.println("The continue:\n");  
        System.out.println("continue; or continue label;");  
        break;  
    }  
    System.out.println();  
  } 
 
  void showmenu() { 
    System.out.println("Help on:");  
    System.out.println("  1. if");  
    System.out.println("  2. switch");  
    System.out.println("  3. for");  
    System.out.println("  4. while");  
    System.out.println("  5. do-while");  
    System.out.println("  6. break");  
    System.out.println("  7. continue\n");  
    System.out.print("Choose one (q to quit): ");  
  } 
 
  boolean isvalid(int ch) { 
    if(ch < '1' | ch > '7' & ch != 'q') return false; 
    else return true; 
  } 
 
} 
 
class HelpClassDemo {  
  public static void main(String args[])   
    throws java.io.IOException {  
    char choice;  
    Help hlpobj = new Help(); 
 
    for(;;) {  
      do { 
        hlpobj.showmenu();  
        do {  
          choice = (char) System.in.read();  
        } while(choice == '\n' | choice == '\r');      
 
      } while( !hlpobj.isvalid(choice) );  
  
      if(choice == 'q') break;  
  
      System.out.println("\n");  
   
 
      hlpobj.helpon(choice); 
    } 
  } 
}

listing 10
// A simple constructor. 
  
class MyClass { 
  int x; 
 
  MyClass() { 
    x = 10; 
  }   
}   
   
class ConsDemo {   
  public static void main(String args[]) {   
    MyClass t1 = new MyClass(); 
    MyClass t2 = new MyClass(); 
 
    System.out.println(t1.x + " " + t2.x); 
  }   
}

listing 11
// A parameterized constructor. 
  
class MyClass { 
  int x; 
 
  MyClass(int i) { 
    x = i; 
  }   
}   
   
class ParmConsDemo {   
  public static void main(String args[]) {   
    MyClass t1 = new MyClass(10); 
    MyClass t2 = new MyClass(88); 
 
    System.out.println(t1.x + " " + t2.x); 
  }   
}

listing 12
// Add a constructor.  
  
class Vehicle {   
  int passengers; // number of passengers   
  int fuelcap;    // fuel capacity in gallons  
  int mpg;        // fuel consumption in miles per gallon  
  
  // This is a constructor for Vehicle. 
  Vehicle(int p, int f, int m) { 
    passengers = p; 
    fuelcap = f; 
    mpg = m; 
  } 
 
  // Return the range.  
  int range() {  
    return mpg * fuelcap;  
  }  
  
  // Compute fuel needed for a given distance. 
  double fuelneeded(int miles) {  
    return (double) miles / mpg;  
  }  
}   
   
class VehConsDemo {   
  public static void main(String args[]) {   
 
    // construct complete vehicles 
    Vehicle minivan = new Vehicle(7, 16, 21);   
    Vehicle sportscar = new Vehicle(2, 14, 12);   
    double gallons;  
    int dist = 252;  
  
    gallons = minivan.fuelneeded(dist);   
   
    System.out.println("To go " + dist + " miles minivan needs " +  
                       gallons + " gallons of fuel.");  
      
    gallons = sportscar.fuelneeded(dist);   
   
    System.out.println("To go " + dist + " miles sportscar needs " +  
                       gallons + " gallons of fuel.");  
      
  }   
}

listing 13
/* 
   Project 4-2 
   Demonstrate the finalize() method. 
*/ 
   
class FDemo {  
  int x;  
  
  FDemo(int i) {  
    x = i;  
  }    
 
  // called when object is recycled 
  protected void finalize() { 
    System.out.println("Finalizing " + x); 
  } 
   
  // generates an object that is immediately destroyed 
  void generator(int i) { 
    FDemo o = new FDemo(i); 
  } 
 
}    
    
class Finalize {    
  public static void main(String args[]) {    
    int count; 
 
    FDemo ob = new FDemo(0); 
 
    /* Now, generate a large number of objects.  At 
       some point, garbage collection will occur.  
       Note: you might need to increase the number 
       of objects generated in order to force 
       garbage collection. */ 
 
    for(count=1; count < 100000; count++) 
      ob.generator(count);  
  }    
}

listing 14
class Pwr { 
  double b; 
  int e; 
  double val; 
 
  Pwr(double base, int exp) { 
    b = base; 
    e = exp; 
 
    val = 1; 
    if(exp==0) return; 
    for( ; exp>0; exp--) val = val * base; 
  } 
 
  double get_pwr() { 
    return val; 
  } 
} 
  
class DemoPwr { 
  public static void main(String args[]) {   
    Pwr x = new Pwr(4.0, 2); 
    Pwr y = new Pwr(2.5, 1); 
    Pwr z = new Pwr(5.7, 0); 
 
    System.out.println(x.b + " raised to the " + x.e +  
                       " power is " + x.get_pwr()); 
    System.out.println(y.b + " raised to the " + y.e +  
                       " power is " + y.get_pwr()); 
    System.out.println(z.b + " raised to the " + z.e +  
                       " power is " + z.get_pwr()); 
  } 
}

listing 15
class Pwr { 
  double b; 
  int e; 
  double val; 
 
  Pwr(double base, int exp) { 
    this.b = base; 
    this.e = exp; 
 
    this.val = 1; 
    if(exp==0) return; 
    for( ; exp>0; exp--) this.val = this.val * base; 
  } 
 
  double get_pwr() { 
    return this.val; 
  } 
}

listing 16
Pwr(double b, int e) { 
  this.b = b; 
  this.e = e; 
 
  val = 1; 
  if(e==0) return; 
  for( ; e>0; e--) val = val * b; 
}

listing 1
// Demonstrate a one-dimensional array. 
class ArrayDemo {  
  public static void main(String args[]) {  
    int sample[] = new int[10]; 
    int i;  
  
    for(i = 0; i < 10; i = i+1)  
      sample[i] = i; 
 
    for(i = 0; i < 10; i = i+1)  
      System.out.println("This is sample[" + i + "]: " + 
                          sample[i]);  
  }  
}

listing 2
// Find the minimum and maximum values in an array. 
class MinMax {  
  public static void main(String args[]) {  
    int nums[] = new int[10]; 
    int min, max; 
 
    nums[0] = 99; 
    nums[1] = -10; 
    nums[2] = 100123; 
    nums[3] = 18; 
    nums[4] = -978; 
    nums[5] = 5623; 
    nums[6] = 463; 
    nums[7] = -9; 
    nums[8] = 287; 
    nums[9] = 49; 
 
    min = max = nums[0]; 
    for(int i=1; i < 10; i++) { 
      if(nums[i] < min) min = nums[i]; 
      if(nums[i] > max) max = nums[i]; 
    } 
    System.out.println("min and max: " + min + " " + max); 
  }  
}

listing 3
// Use array initializers. 
class MinMax2 {  
  public static void main(String args[]) {  
    int nums[] = { 99, -10, 100123, 18, -978, 
                   5623, 463, -9, 287, 49 }; 
    int min, max; 
 
    min = max = nums[0]; 
    for(int i=1; i < 10; i++) { 
      if(nums[i] < min) min = nums[i]; 
      if(nums[i] > max) max = nums[i]; 
    } 
    System.out.println("Min and max: " + min + " " + max); 
  }  
}

listing 4
// Demonstrate an array overrun. 
class ArrayErr {  
  public static void main(String args[]) {  
    int sample[] = new int[10]; 
    int i;  
  
    // generate an array overrun 
    for(i = 0; i < 100; i = i+1)  
      sample[i] = i; 
  }  
}

listing 5
/* 
   Project 5-1 
   Demonstrate the Bubble sort. 
*/ 
 
class Bubble {  
  public static void main(String args[]) {  
    int nums[] = { 99, -10, 100123, 18, -978, 
                   5623, 463, -9, 287, 49 }; 
    int a, b, t;  
    int size;  
  
    size = 10; // number of elements to sort  
  
    // display original array  
    System.out.print("Original array is:"); 
    for(int i=0; i < size; i++) 
      System.out.print(" " + nums[i]);  
    System.out.println();  
  
    // This is the bubble sort.  
    for(a=1; a < size; a++)  
      for(b=size-1; b >= a; b--) {  
        if(nums[b-1] > nums[b]) { // if out of order  
          // exchange elements   
          t = nums[b-1];  
          nums[b-1] = nums[b];  
          nums[b] = t;  
        }  
      }  
  
    // display sorted array  
    System.out.print("Sorted array is:");  
    for(int i=0; i < size; i++) 
      System.out.print(" " + nums[i]);  
    System.out.println(); 
  } 
}

listing 6
// Demonstrate a two-dimensional array.  
class TwoD {  
  public static void main(String args[]) {  
    int t, i; 
    int table[][] = new int[3][4];  
  
    for(t=0; t < 3; ++t) {  
      for(i=0; i < 4; ++i) {  
        table[t][i] = (t*4)+i+1;  
        System.out.print(table[t][i] + " ");  
      }  
      System.out.println(); 
    }  
  } 
}

listing 7
// Manually allocate differing size second dimensions.  
class Ragged {  
  public static void main(String args[]) {  
    int riders[][] = new int[7][];  
    riders[0] = new int[10];  
    riders[1] = new int[10];  
    riders[2] = new int[10];  
    riders[3] = new int[10];  
    riders[4] = new int[10];  
    riders[5] = new int[2];  
    riders[6] = new int[2];  
  
    int i, j; 
 
    // fabricate some fake data    
    for(i=0; i < 5; i++)   
      for(j=0; j < 10; j++)  
        riders[i][j] = i + j + 10;  
    for(i=5; i < 7; i++)   
      for(j=0; j < 2; j++)  
        riders[i][j] = i + j + 10;  
 
    System.out.println("Riders per trip during the week:"); 
    for(i=0; i < 5; i++) {  
      for(j=0; j < 10; j++)  
        System.out.print(riders[i][j] + " ");  
      System.out.println();  
    } 
    System.out.println(); 
 
    System.out.println("Riders per trip on the weekend:"); 
    for(i=5; i < 7; i++) {  
      for(j=0; j < 2; j++)  
        System.out.print(riders[i][j] + " ");   
      System.out.println();  
    }  
  }  
}

listing 8
// Initialize a two-dimensional array. 
class Squares {  
  public static void main(String args[]) {  
    int sqrs[][] = { 
      { 1, 1 }, 
      { 2, 4 }, 
      { 3, 9 }, 
      { 4, 16 }, 
      { 5, 25 }, 
      { 6, 36 }, 
      { 7, 49 }, 
      { 8, 64 }, 
      { 9, 81 }, 
      { 10, 100 } 
    }; 
    int i, j; 
 
    for(i=0; i < 10; i++) {  
      for(j=0; j < 2; j++)  
        System.out.print(sqrs[i][j] + " ");   
      System.out.println();  
    }  
  }  
}

listing 9
// Assigning array reference variables. 
class AssignARef {  
  public static void main(String args[]) {  
    int i; 
 
    int nums1[] = new int[10]; 
    int nums2[] = new int[10]; 
 
    for(i=0; i < 10; i++) 
      nums1[i] = i; 
 
    for(i=0; i < 10; i++) 
      nums2[i] = -i; 
 
    System.out.print("Here is nums1: "); 
    for(i=0; i < 10; i++) 
      System.out.print(nums1[i] + " ");   
    System.out.println(); 
 
    System.out.print("Here is nums2: "); 
    for(i=0; i < 10; i++) 
      System.out.print(nums2[i] + " ");   
    System.out.println(); 
 
    nums2 = nums1; // now nums2 refers to nums1 
 
    System.out.print("Here is nums2 after assignment: "); 
    for(i=0; i < 10; i++) 
      System.out.print(nums2[i] + " ");   
    System.out.println(); 
 
   // now operate on nums1 array through nums2 
   nums2[3] = 99; 
 
    System.out.print("Here is nums1 after change through nums2: "); 
    for(i=0; i < 10; i++) 
      System.out.print(nums1[i] + " ");   
    System.out.println(); 
  }  
}

listing 10
// Use the length array member.  
class LengthDemo {  
  public static void main(String args[]) {  
    int list[] = new int[10];  
    int nums[] = { 1, 2, 3 };  
    int table[][] = { // a variable-length table  
      {1, 2, 3},  
      {4, 5},  
      {6, 7, 8, 9}  
    };  
  
    System.out.println("length of list is " + list.length);  
    System.out.println("length of nums is " + nums.length);  
    System.out.println("length of table is " + table.length);  
    System.out.println("length of table[0] is " + table[0].length);  
    System.out.println("length of table[1] is " + table[1].length);  
    System.out.println("length of table[2] is " + table[2].length);  
    System.out.println(); 
  
    // use length to initialize list  
    for(int i=0; i < list.length; i++)  
      list[i] = i * i;  
  
    System.out.print("Here is list: "); 
    // now use length to display list  
    for(int i=0; i < list.length; i++)  
      System.out.print(list[i] + " ");  
    System.out.println(); 
  }  
}

listing 11
// Use length variable to help copy an array. 
class ACopy {  
  public static void main(String args[]) {  
    int i; 
    int nums1[] = new int[10]; 
    int nums2[] = new int[10]; 
 
    for(i=0; i < nums1.length; i++) 
      nums1[i] = i; 
 
    // copy nums1 to nums2 
    if(nums2.length >= nums1.length)  
      for(i = 0; i < nums2.length; i++) 
        nums2[i] = nums1[i]; 
 
    for(i=0; i < nums2.length; i++) 
      System.out.print(nums2[i] + " ");   
  } 
}

listing 12
/* 
   Project 5-2 
 
   A queue class for characters. 
*/ 
 
class Queue { 
  char q[]; // this array holds the queue 
  int putloc, getloc; // the put and get indices 
 
  Queue(int size) { 
    q = new char[size+1]; // allocate memory for queue 
    putloc = getloc = 0; 
  } 
 
  // put a characer into the queue 
  void put(char ch) { 
    if(putloc==q.length-1) { 
      System.out.println(" -- Queue is full."); 
      return; 
    } 
     
    putloc++; 
    q[putloc] = ch; 
  } 
 
  // get a character from the queue 
  char get() { 
    if(getloc == putloc) { 
      System.out.println(" -- Queue is empty."); 
      return (char) 0;  
    } 
   
    getloc++; 
    return q[getloc]; 
  } 
} 
 
// Demonstrate the Queue class. 
class QDemo { 
  public static void main(String args[]) { 
    Queue bigQ = new Queue(100); 
    Queue smallQ = new Queue(4); 
    char ch; 
    int i; 
 
    System.out.println("Using bigQ to store the alphabet."); 
    // put some numbers into bigQ 
    for(i=0; i < 26; i++) 
      bigQ.put((char) ('A' + i)); 
 
    // retrieve and display elements from bigQ 
    System.out.print("Contents of bigQ: "); 
    for(i=0; i < 26; i++) {  
      ch = bigQ.get(); 
      if(ch != (char) 0) System.out.print(ch); 
    } 
 
    System.out.println("\n"); 
 
 
    System.out.println("Using smallQ to generate erros."); 
    // Now, use smallQ to generate some errors 
    for(i=0; i < 5; i++) { 
      System.out.print("Attempting to store " + 
                       (char) ('Z' - i)); 
 
      smallQ.put((char) ('Z' - i)); 
 
      System.out.println(); 
    } 
    System.out.println(); 
 
    // more errors on smallQ 
    System.out.print("Contents of smallQ: "); 
    for(i=0; i < 5; i++) {  
      ch = smallQ.get(); 
 
      if(ch != (char) 0) System.out.print(ch); 
    } 
  } 
}

listing 13
// Use a for-each style for loop. 
class ForEach {  
  public static void main(String args[]) {  
    int nums[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };  
    int sum = 0;  
 
    // Use for-each style for to display and sum the values. 
    for(int x : nums) {  
      System.out.println("Value is: " + x); 
      sum += x;  
    }  
 
    System.out.println("Summation: " + sum); 
  }  
}

listing 14
// The for-each loop is essentially read-only. 
class NoChange {   
  public static void main(String args[]) {   
    int nums[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };   
  
    for(int x : nums) {   
      System.out.print(x + " ");  
      x = x * 10; // no effect on nums 
    }   
    
    System.out.println(); 
 
    for(int x : nums)  
      System.out.print(x + " ");  
 
    System.out.println(); 
  }   
}

listing 15
// Use for-each style for on a two-dimensional array.  
class ForEach2 {  
  public static void main(String args[]) {  
    int sum = 0;  
    int nums[][] = new int[3][5];  
  
    // give nums some values  
    for(int i = 0; i < 3; i++)   
      for(int j=0; j < 5; j++)  
        nums[i][j] = (i+1)*(j+1);  
  
    // Use for-each for loop to display and sum the values. 
    for(int x[] : nums) {  
      for(int y : x) { 
        System.out.println("Value is: " + y);  
        sum += y;  
      } 
    }  
    System.out.println("Summation: " + sum);  
  }  
}

listing 16
// Search an array using for-each style for.  
class Search {  
  public static void main(String args[]) {  
    int nums[] = { 6, 8, 3, 7, 5, 6, 1, 4 }; 
    int val = 5;  
    boolean found = false;  
 
    // Use for-each style for to search nums for val. 
    for(int x : nums) {  
      if(x == val) {  
        found = true;  
        break;  
      }  
    }  
  
    if(found)   
      System.out.println("Value found!");  
  }  
}


listing 17
// Introduce String. 
class StringDemo {  
  public static void main(String args[]) {  
    // declare strings in various ways 
    String str1 = new String("Java strings are objects."); 
    String str2 = "They are constructed various ways."; 
    String str3 = new String(str2); 
 
    System.out.println(str1); 
    System.out.println(str2); 
    System.out.println(str3); 
  }  
}

listing 18
// Some String operations. 
class StrOps {  
  public static void main(String args[]) {  
    String str1 = 
      "When it comes to Web programming, Java is #1.";  
    String str2 = new String(str1); 
    String str3 = "Java strings are powerful.";  
    int result, idx; 
    char ch; 
 
    System.out.println("Length of str1: " +  
                       str1.length());  
  
    // display str1, one char at a time. 
    for(int i=0; i < str1.length(); i++) 
      System.out.print(str1.charAt(i));  
    System.out.println();  
 
    if(str1.equals(str2))  
      System.out.println("str1 equals str2");  
    else  
      System.out.println("str1 does not equal str2");  
  
    if(str1.equals(str3))  
      System.out.println("str1 equals str3");  
    else  
      System.out.println("str1 does not equal str3");  
 
    result = str1.compareTo(str3); 
    if(result == 0) 
      System.out.println("str1 and str3 are equal"); 
    else if(result < 0) 
      System.out.println("str1 is less than str3"); 
    else 
      System.out.println("str1 is greater than str3"); 
 
 
    // assign a new string to str2 
    str2 = "One Two Three One"; 
 
    idx = str2.indexOf("One"); 
    System.out.println("Index of first occurence of One: " + idx); 
    idx = str2.lastIndexOf("One"); 
    System.out.println("Index of last occurence of One: " + idx); 
     
  }  
}

listing 19
// Demonstrate String arrays.  
class StringArrays {  
  public static void main(String args[]) {  
    String strs[] = { "This", "is", "a", "test." };  
  
    System.out.println("Original array: ");  
    for(String s : strs)
      System.out.print(s + " ");  
    System.out.println("\n");  
  
    // change a string  
    strs[1] = "was";  
    strs[3] = "test, too!";  
  
    System.out.println("Modified array: "); 
    for(String s : strs)
      System.out.print(s + " ");  
  }  
} 

listing 20
// Use substring(). 
class SubStr {  
  public static void main(String args[]) {  
    String orgstr = "Java makes the Web move."; 
 
    // construct a substring 
    String substr = orgstr.substring(5, 18); 
 
     
    System.out.println("orgstr: " + orgstr); 
    System.out.println("substr: " + substr); 
 
  }  
}

listing 21
// Display all command-line information. 
class CLDemo {  
  public static void main(String args[]) { 
    System.out.println("There are " + args.length + 
                       " command-line arguments."); 
 
    System.out.println("They are: "); 
    for(int i=0; i<args.length; i++)  
      System.out.println("arg[" + i + "]: " + args[i]);  
  }  
}

listing 22
// A simple automated telphone directory. 
class Phone {  
  public static void main(String args[]) {  
    String numbers[][] = { 
      { "Tom", "555-3322" }, 
      { "Mary", "555-8976" }, 
      { "Jon", "555-1037" }, 
      { "Rachel", "555-1400" } 
    }; 
    int i; 
 
    if(args.length != 1) 
      System.out.println("Usage: java Phone <name>"); 
    else { 
      for(i=0; i<numbers.length; i++) { 
        if(numbers[i][0].equals(args[0])) { 
          System.out.println(numbers[i][0] + ": " + 
                             numbers[i][1]); 
          break; 
        } 
      } 
      if(i == numbers.length) 
        System.out.println("Name not found."); 
    } 
  }  
}

listing 23
// Uppercase letters. 
class UpCase {  
  public static void main(String args[]) { 
    char ch;  
  
    for(int i=0; i < 10; i++) { 
      ch = (char) ('a' + i);  
      System.out.print(ch); 
 
      // This statement turns off the 6th bit.   
      ch = (char) ((int) ch & 65503); // ch is now uppercase  
  
      System.out.print(ch + " ");  
    } 
  } 
}

listing 24
// Display the bits within a byte.  
class ShowBits { 
  public static void main(String args[]) { 
    int t; 
    byte val;  
  
    val = 123; 
    for(t=128; t > 0; t = t/2) { 
      if((val & t) != 0) System.out.print("1 ");  
      else System.out.print("0 ");  
    } 
  } 
}

listing 25
// Lowercase letters. 
class LowCase {  
  public static void main(String args[]) { 
    char ch;  
  
    for(int i=0; i < 10; i++) { 
      ch = (char) ('A' + i);  
      System.out.print(ch); 
 
      // This statement turns on the 6th bit.   
      ch = (char) ((int) ch | 32); // ch is now lowercase  
  
      System.out.print(ch + " ");  
    } 
  } 
}

listing 26
// Use XOR to encode and decode a message. 
class Encode {  
  public static void main(String args[]) { 
    String msg = "This is a test";  
    String encmsg = ""; 
    String decmsg = ""; 
    int key = 88; 
 
    System.out.print("Original message: "); 
    System.out.println(msg); 
 
    // encode the message 
    for(int i=0; i < msg.length(); i++) 
      encmsg = encmsg + (char) (msg.charAt(i) ^ key); 
 
    System.out.print("Encoded message: "); 
    System.out.println(encmsg); 
 
    // decode the message 
    for(int i=0; i < msg.length(); i++) 
      decmsg = decmsg + (char) (encmsg.charAt(i) ^ key); 
    
    System.out.print("Decoded message: "); 
    System.out.println(decmsg); 
  } 
}

listing 27
// Demonstrate the bitwise NOT. 
class NotDemo { 
  public static void main(String args[]) { 
    byte b = -34; 
 
    for(int t=128; t > 0; t = t/2) { 
      if((b & t) != 0) System.out.print("1 ");  
      else System.out.print("0 ");  
    } 
    System.out.println(); 
 
    // reverse all bits 
    b = (byte) ~b; 
 
    for(int t=128; t > 0; t = t/2) { 
      if((b & t) != 0) System.out.print("1 ");  
      else System.out.print("0 ");  
    } 
  } 
} 

listing 28
// Demonstrate the shift << and >> operators. 
class ShiftDemo { 
  public static void main(String args[]) { 
    int val = 1; 
 
    for(int i = 0; i < 8; i++) {  
      for(int t=128; t > 0; t = t/2) { 
        if((val & t) != 0) System.out.print("1 ");  
        else System.out.print("0 ");  
      } 
      System.out.println(); 
      val = val << 1; // left shift 
    } 
    System.out.println(); 
 
    val = 128; 
    for(int i = 0; i < 8; i++) {  
      for(int t=128; t > 0; t = t/2) { 
        if((val & t) != 0) System.out.print("1 ");  
        else System.out.print("0 ");  
      } 
      System.out.println(); 
      val = val >> 1; // right shift 
    } 
  } 
}

listing 29
/* 
   Project 5-3 
 
   A class that displays the binary representation of a value. 
*/ 
 
class ShowBits { 
  int numbits; 
 
  ShowBits(int n) { 
    numbits = n; 
  } 
 
  void show(long val) { 
    long mask = 1; 
 
    // left-shit a 1 into the proper position 
    mask <<= numbits-1; 
 
    int spacer = 0; 
    for(; mask != 0; mask >>>= 1) { 
      if((val & mask) != 0) System.out.print("1"); 
      else System.out.print("0"); 
      spacer++; 
      if((spacer % 8) == 0) { 
        System.out.print(" "); 
        spacer = 0; 
      } 
    } 
    System.out.println(); 
  } 
} 
 
// Demonstrate ShowBits. 
class ShowBitsDemo { 
  public static void main(String args[]) { 
    ShowBits b = new ShowBits(8); 
    ShowBits i = new ShowBits(32); 
    ShowBits li = new ShowBits(64); 
 
    System.out.println("123 in binary: "); 
    b.show(123); 
 
    System.out.println("\n87987 in binary: "); 
    i.show(87987); 
 
    System.out.println("\n237658768 in binary: "); 
    li.show(237658768); 
 
 
    // you can also show low-order bits of any integer 
    System.out.println("\nLow order 8 bits of 87987 in binary: "); 
    b.show(87987);  
  } 
}

listing 30
// Prevent a division by zero using the ?. 
class NoZeroDiv { 
  public static void main(String args[]) { 
    int result; 
 
    for(int i = -5; i < 6; i++) { 
      result = i != 0 ? 100 / i : 0; 
      if(i != 0)  
        System.out.println("100 / " + i + " is " + result); 
    } 
  } 
} 

listing 31
// Prevent a division by zero using the ?. 
class NoZeroDiv2 { 
  public static void main(String args[]) { 
 
    for(int i = -5; i < 6; i++)  
      if(i != 0 ? true : false)  
        System.out.println("100 / " + i + 
                           " is " + 100 / i); 
  } 
}

 
listing 1
// Public vs private access. 
class MyClass {  
  private int alpha; // private access 
  public int beta; // public access 
  int gamma; // default access (essentially public) 
 
  /* Methods to access alpha.  It is OK for a 
     member of a class to access a private member 
     of the same class. 
  */ 
  void setAlpha(int a) { 
    alpha = a;  
  } 
 
  int getAlpha() { 
    return alpha; 
  } 
}  
  
class AccessDemo {  
  public static void main(String args[]) {  
    MyClass ob = new MyClass();  
  
    /* Access to alpha is allowed only through 
       its accessor methods. */ 
    ob.setAlpha(-99); 
    System.out.println("ob.alpha is " + ob.getAlpha()); 
 
    // You cannot access alpha like this: 
//  ob.alpha = 10; // Wrong! alpha is private! 
 
    // These are OK because beta and gamma are public. 
    ob.beta = 88;  
    ob.gamma = 99;  
   }  
}

listing 2
/* This class implements a "fail-soft" array which prevents 
   runtime errors. 
 */  
class FailSoftArray {  
  private int a[]; // reference to array 
  private int errval; // value to return if get() fails 
 
  public int length; // length is public 
   
  /* Construct array given its size and the value to 
     return if get() fails. */ 
  public FailSoftArray(int size, int errv) { 
    a = new int[size]; 
    errval = errv; 
    length = size;  
  } 
 
  // Return value at given index. 
  public int get(int index) { 
    if(ok(index)) return a[index]; 
    return errval; 
  } 
 
  // Put a value at an index. Return false on failure. 
  public boolean put(int index, int val) { 
    if(ok(index)) { 
      a[index] = val; 
      return true; 
    } 
    return false; 
  } 
 
  // Return true if index is within bounds. 
  private boolean ok(int index) { 
   if(index >= 0 & index < length) return true; 
   return false; 
  } 
}  
  
// Demonstrate the fail-soft array. 
class FSDemo {  
  public static void main(String args[]) {  
    FailSoftArray fs = new FailSoftArray(5, -1); 
    int x; 
 
    // show quiet failures 
    System.out.println("Fail quietly."); 
    for(int i=0; i < (fs.length * 2); i++) 
      fs.put(i, i*10); 
 
    for(int i=0; i < (fs.length * 2); i++) { 
      x = fs.get(i); 
      if(x != -1) System.out.print(x + " "); 
    } 
    System.out.println(""); 
 
    // now, handle failures 
    System.out.println("\nFail with error reports."); 
    for(int i=0; i < (fs.length * 2); i++) 
      if(!fs.put(i, i*10)) 
        System.out.println("Index " + i + " out-of-bounds"); 
 
    for(int i=0; i < (fs.length * 2); i++) { 
      x = fs.get(i); 
      if(x != -1) System.out.print(x + " "); 
      else 
        System.out.println("Index " + i + " out-of-bounds"); 
    } 
  } 
}

listing 3
// An improved queue class for characters.  
class Queue {  
  // these members are now private 
  private char q[]; // this array holds the queue  
  private int putloc, getloc; // the put and get indices  
  
  Queue(int size) {  
    q = new char[size+1]; // allocate memory for queue  
    putloc = getloc = 0;  
  }  
  
  // Put a characer into the queue. 
  void put(char ch) {  
    if(putloc==q.length-1) {  
      System.out.println(" -- Queue is full.");  
      return;  
    }  
      
    putloc++;  
    q[putloc] = ch;  
  }  
  
  // Get a character from the queue. 
  char get() {  
    if(getloc == putloc) {  
      System.out.println(" -- Queue is empty.");  
      return (char) 0;   
    }  
    
    getloc++;  
    return q[getloc];  
  }  
}

listing 4
// Objects can be passed to methods.  
class Block {  
  int a, b, c;  
  int volume; 
  
  Block(int i, int j, int k) {  
    a = i;  
    b = j;  
    c = k; 
    volume = a * b * c; 
  }  
  
  // Return true if ob defines same block. 
  boolean sameBlock(Block ob) {  
    if((ob.a == a) & (ob.b == b) & (ob.c == c)) return true;  
    else return false;  
  }  
 
  // Return true if ob has same volume. 
  boolean sameVolume(Block ob) { 
    if(ob.volume == volume) return true; 
    else return false; 
  } 
}  
  
class PassOb {  
  public static void main(String args[]) { 
    Block ob1 = new Block(10, 2, 5);  
    Block ob2 = new Block(10, 2, 5);  
    Block ob3 = new Block(4, 5, 5);  
  
    System.out.println("ob1 same dimensions as ob2: " + 
                       ob1.sameBlock(ob2));  
    System.out.println("ob1 same dimensions as ob3: " + 
                        ob1.sameBlock(ob3));  
    System.out.println("ob1 same volume as ob3: " + 
                       ob1.sameVolume(ob3));  
  }  
}

listing 5
// Simple types are passed by value. 
class Test { 
  /* This method causes no change to the arguments 
     used in the call. */ 
  void noChange(int i, int j) { 
    i = i + j; 
    j = -j; 
  } 
} 
 
class CallByValue { 
  public static void main(String args[]) { 
    Test ob = new Test(); 
 
    int a = 15, b = 20; 
 
    System.out.println("a and b before call: " + 
                       a + " " + b); 
 
    ob.noChange(a, b);  
 
    System.out.println("a and b after call: " + 
                       a + " " + b); 
  } 
}

listing 6
// Objects are passed by reference. 
class Test { 
  int a, b; 
 
  Test(int i, int j) { 
    a = i; 
    b = j; 
  }
  /* Pass an object. Now, ob.a and ob.b in object 
     used in the call will be changed. */ 
  void change(Test ob) { 
    ob.a = ob.a + ob.b; 
    ob.b = -ob.b; 
  } 
} 
 
class CallByRef { 
  public static void main(String args[]) { 
    Test ob = new Test(15, 20); 
 
    System.out.println("ob.a and ob.b before call: " + 
                       ob.a + " " + ob.b); 
 
    ob.change(ob); 
 
    System.out.println("ob.a and ob.b after call: " + 
                       ob.a + " " + ob.b); 
  } 
}

listing 7
// Return a String object. 
class ErrorMsg { 
  String msgs[] = { 
    "Output Error", 
    "Input Error", 
    "Disk Full", 
    "Index Out-Of-Bounds" 
  }; 
 
  // Return the error message. 
  String getErrorMsg(int i) { 
    if(i >=0 & i < msgs.length) 
      return msgs[i]; 
    else 
      return "Invalid Error Code"; 
  } 
} 
 
class ErrMsg { 
  public static void main(String args[]) { 
    ErrorMsg err = new ErrorMsg(); 
 
    System.out.println(err.getErrorMsg(2)); 
    System.out.println(err.getErrorMsg(19)); 
  } 
}

listing 8
// Return a programmer-defined object. 
class Err { 
  String msg; // error message 
  int severity; // code indicating severity of error 
 
  Err(String m, int s) { 
    msg = m; 
    severity  = s; 
  } 
} 
 
class ErrorInfo { 
  String msgs[] = { 
    "Output Error", 
    "Input Error", 
    "Disk Full", 
    "Index Out-Of-Bounds" 
  }; 
  int howbad[] = { 3, 3, 2, 4 }; 
 
  Err getErrorInfo(int i) { 
    if(i >=0 & i < msgs.length) 
      return new Err(msgs[i], howbad[i]); 
    else 
      return new Err("Invalid Error Code", 0); 
  } 
} 
 
class ErrInfo { 
  public static void main(String args[]) { 
    ErrorInfo err = new ErrorInfo(); 
    Err e; 
 
    e = err.getErrorInfo(2); 
    System.out.println(e.msg + " severity: " + e.severity); 
 
    e = err.getErrorInfo(19); 
    System.out.println(e.msg + " severity: " + e.severity); 
  } 
}

listing 9
// Demonstrate method overloading.  
class Overload {  
  void ovlDemo() {  
    System.out.println("No parameters");  
  }  
  
  // Overload ovlDemo for one integer parameter.  
  void ovlDemo(int a) {  
    System.out.println("One parameter: " + a);  
  }  
  
  // Overload ovlDemo for two integer parameters.  
  int ovlDemo(int a, int b) {  
    System.out.println("Two parameters: " + a + " " + b);  
    return a + b; 
  }  
  
  // Overload ovlDemo for two double parameters.  
  double ovlDemo(double a, double b) { 
    System.out.println("Two double parameters: " + 
                       a + " "+ b);  
    return a + b;  
  }  
}  
  
class OverloadDemo {  
  public static void main(String args[]) {  
    Overload ob = new Overload();  
    int resI; 
    double resD;      
  
    // call all versions of ovlDemo()  
    ob.ovlDemo();   
    System.out.println(); 
 
    ob.ovlDemo(2);  
    System.out.println(); 
 
    resI = ob.ovlDemo(4, 6);  
    System.out.println("Result of ob.ovlDemo(4, 6): " + 
                       resI);  
    System.out.println(); 
 
 
    resD = ob.ovlDemo(1.1, 2.32);  
    System.out.println("Result of ob.ovlDemo(1.1, 2.2): " + 
                       resD);  
  }  
}

listing 10
/* Automatic type conversions can affect 
   overloaded method resolution. 
*/ 
class Overload2 { 
  void f(int x) { 
    System.out.println("Inside f(int): " + x); 
  } 
 
  void f(double x) { 
    System.out.println("Inside f(double): " + x); 
  } 
} 
 
class TypeConv { 
  public static void main(String args[]) { 
    Overload2 ob = new Overload2(); 
 
    int i = 10; 
    double d = 10.1; 
 
    byte b = 99; 
    short s = 10; 
    float f = 11.5F; 
 
 
    ob.f(i); // calls ob.f(int) 
    ob.f(d); // calls ob.f(double) 
 
    ob.f(b); // calls ob.f(int) -- type conversion 
    ob.f(s); // calls ob.f(int) -- type conversion 
    ob.f(f); // calls ob.f(double) -- type conversion 
  } 
}

listing 11
// Add f(byte). 
class Overload2 { 
  void f(byte x) { 
    System.out.println("Inside f(byte): " + x); 
  } 
 
  void f(int x) { 
    System.out.println("Inside f(int): " + x); 
  } 
 
  void f(double x) { 
    System.out.println("Inside f(double): " + x); 
  } 
} 
 
class TypeConv { 
  public static void main(String args[]) { 
    Overload2 ob = new Overload2(); 
 
    int i = 10; 
    double d = 10.1; 
 
    byte b = 99; 
    short s = 10; 
    float f = 11.5F; 
 
 
    ob.f(i); // calls ob.f(int) 
    ob.f(d); // calls ob.f(double) 
 
    ob.f(b); // calls ob.f(byte) -- now, no type conversion 
 
    ob.f(s); // calls ob.f(int) -- type conversion 
    ob.f(f); // calls ob.f(double) -- type conversion 
  } 
}

listing 12
// Demonstrate an overloaded constructor. 
class MyClass {  
  int x;  
  
  MyClass() { 
    System.out.println("Inside MyClass()."); 
    x = 0; 
  } 
 
  MyClass(int i) {  
    System.out.println("Inside MyClass(int)."); 
    x = i;  
  } 
 
  MyClass(double d) { 
    System.out.println("Inside MyClass(double)."); 
    x = (int) d; 
  } 
 
  MyClass(int i, int j) { 
    System.out.println("Inside MyClass(int, int)."); 
    x = i * j; 
  }    
}    
    
class OverloadConsDemo {    
  public static void main(String args[]) {    
    MyClass t1 = new MyClass();  
    MyClass t2 = new MyClass(88);  
    MyClass t3 = new MyClass(17.23);  
    MyClass t4 = new MyClass(2, 4);  
  
    System.out.println("t1.x: " + t1.x); 
    System.out.println("t2.x: " + t2.x); 
    System.out.println("t3.x: " + t3.x); 
    System.out.println("t4.x: " + t4.x); 
  }    
}

listing 13
// Initialize one object with another. 
class Summation { 
  int sum; 
 
  // Construct from an int. 
  Summation(int num) { 
    sum = 0; 
    for(int i=1; i <= num; i++) 
      sum += i; 
  } 
 
  // Construct from another object. 
  Summation(Summation ob) { 
    sum = ob.sum; 
  } 
} 
 
class SumDemo { 
  public static void main(String args[]) { 
    Summation s1 = new Summation(5); 
    Summation s2 = new Summation(s1); 
 
    System.out.println("s1.sum: " + s1.sum); 
    System.out.println("s2.sum: " + s2.sum); 
  } 
}

listing 14
// A queue class for characters.   
class Queue {   
  private char q[]; // this array holds the queue   
  private int putloc, getloc; // the put and get indices   
   
  // Construct an empty Queue given its size.  
  Queue(int size) {   
    q = new char[size+1]; // allocate memory for queue   
    putloc = getloc = 0;   
  }   
  
  // Construct a Queue from a Queue.  
  Queue(Queue ob) {  
    putloc = ob.putloc;  
    getloc = ob.getloc;  
    q = new char[ob.q.length];  
  
    // copy elements  
    for(int i=getloc+1; i <= putloc; i++)  
      q[i] = ob.q[i];  
  }  
  
  // Construct a Queue with initial values.  
  Queue(char a[]) {  
    putloc = 0;  
    getloc = 0;  
    q = new char[a.length+1];  
  
    for(int i = 0; i < a.length; i++) put(a[i]);  
  }  
      
  // Put a characer into the queue.   
  void put(char ch) {   
    if(putloc==q.length-1) {   
      System.out.println(" -- Queue is full.");   
      return;   
    }   
       
    putloc++;   
    q[putloc] = ch;   
  }   
   
  // Get a character from the queue.  
  char get() {   
    if(getloc == putloc) {   
      System.out.println(" -- Queue is empty.");   
      return (char) 0;    
    }   
     
    getloc++;   
    return q[getloc];   
  }   
}   
   
// Demonstrate the Queue class.   
class QDemo2 {   
  public static void main(String args[]) {   
    // construct 10-element empty queue  
    Queue q1 = new Queue(10);   
  
    char name[] = {'T', 'o', 'm'};   
    // construct queue from array  
    Queue q2 = new Queue(name);   
  
    char ch;   
    int i;   
   
    // put some characters into q1   
    for(i=0; i < 10; i++)   
      q1.put((char) ('A' + i));   
  
    // construct queue from another queue  
    Queue q3 = new Queue(q1);  
  
    // Show the queues.  
    System.out.print("Contents of q1: ");   
    for(i=0; i < 10; i++) {    
      ch = q1.get();   
      System.out.print(ch);   
    }   
   
    System.out.println("\n");   
   
    System.out.print("Contents of q2: ");   
    for(i=0; i < 3; i++) {    
      ch = q2.get();   
      System.out.print(ch);   
    }   
   
    System.out.println("\n");   
   
    System.out.print("Contents of q3: ");   
    for(i=0; i < 10; i++) {    
      ch = q3.get();   
      System.out.print(ch);   
    }   
  }   
}

listing 15
// A simple example of recursion.  
class Factorial {  
  // This is a recursive function.  
  int factR(int n) {  
    int result;  
  
    if(n==1) return 1;  
    result = factR(n-1) * n;  
    return result;  
  }  
  
  // This is an iterative equivalent.  
  int factI(int n) {  
    int t, result;  
  
    result = 1;  
    for(t=1; t <= n; t++) result *= t;  
    return result;  
}  
}  
  
class Recursion {  
  public static void main(String args[]) {  
    Factorial f = new Factorial();  
  
    System.out.println("Factorials using recursive method.");  
    System.out.println("Factorial of 3 is " + f.factR(3));  
    System.out.println("Factorial of 4 is " + f.factR(4));  
    System.out.println("Factorial of 5 is " + f.factR(5));  
    System.out.println();  
 
    System.out.println("Factorials using iterative method.");  
    System.out.println("Factorial of 3 is " + f.factI(3));  
    System.out.println("Factorial of 4 is " + f.factI(4));  
    System.out.println("Factorial of 5 is " + f.factI(5));  
  }  
}

listing 16
// Use a static variable. 
class StaticDemo { 
  int x; // a normal instance variable 
  static int y; // a static variable 
} 
 
class SDemo { 
  public static void main(String args[]) { 
    StaticDemo ob1 = new StaticDemo(); 
    StaticDemo ob2 = new StaticDemo(); 
 
    /* Each object has its own copy of 
       an instance variable. */ 
    ob1.x = 10; 
    ob2.x = 20; 
    System.out.println("Of course, ob1.x and ob2.x " + 
                       "are independent."); 
    System.out.println("ob1.x: " + ob1.x + 
                       "\nob2.x: " + ob2.x); 
    System.out.println(); 
 
    /* Each object shares one copy of 
       a static variable. */ 
    System.out.println("The static variable y is shared."); 
    ob1.y = 19; 
    System.out.println("ob1.y: " + ob1.y + 
                       "\nob2.y: " + ob2.y); 
    System.out.println(); 
 
    System.out.println("The static variable y can be" + 
                       " accessed through its class."); 
    StaticDemo.y = 11; // Can refer to y through class name 
    System.out.println("StaticDemo.y: " + StaticDemo.y + 
                       "\nob1.y: " + ob1.y + 
                       "\nob2.y: " + ob2.y); 
  } 
}

listing 17
// Use a static method. 
class StaticMeth { 
  static int val = 1024; // a static variable 
 
  // a static method 
  static int valDiv2() { 
    return val/2; 
  } 
} 
 
class SDemo2 { 
  public static void main(String args[]) { 
 
    System.out.println("val is " + StaticMeth.val); 
    System.out.println("StaticMeth.valDiv2(): " + 
                       StaticMeth.valDiv2()); 
 
    StaticMeth.val = 4; 
    System.out.println("val is " + StaticMeth.val); 
    System.out.println("StaticMeth.valDiv2(): " + 
                       StaticMeth.valDiv2()); 
 
  } 
}

listing 18
class StaticError { 
  int denom = 3; // a normal instance variable 
  static int val = 1024; // a static variable 
 
  /* Error! Can't access a non-static variable 
     from within a static method. */ 
  static int valDivDenom() { 
    return val/denom; // won't compile! 
  } 
}

listing 19
// Use a static block 
class StaticBlock { 
  static double rootOf2; 
  static double rootOf3; 
 
  static { 
    System.out.println("Inside static block."); 
    rootOf2 = Math.sqrt(2.0); 
    rootOf3 = Math.sqrt(3.0); 
  } 
 
  StaticBlock(String msg) { 
    System.out.println(msg); 
  } 
} 
 
class SDemo3 { 
  public static void main(String args[]) { 
    StaticBlock ob = new StaticBlock("Inside Constructor"); 
 
    System.out.println("Square root of 2 is " +  
                       StaticBlock.rootOf2); 
    System.out.println("Square root of 3 is " +  
                       StaticBlock.rootOf3); 
 
  } 
}

listing 20
// A simple version of the Quicksort. 
class Quicksort { 
 
  // Set up a call to the actual Quicksort method. 
  static void qsort(char items[]) { 
    qs(items, 0, items.length-1); 
  } 
 
  // A recursive version of Quicksort for characters. 
  private static void qs(char items[], int left, int right)  
  {  
    int i, j;  
    char x, y;  
  
    i = left; j = right;  
    x = items[(left+right)/2];  
  
    do {  
      while((items[i] < x) && (i < right)) i++;  
      while((x < items[j]) && (j > left)) j--;  
  
      if(i <= j) {  
        y = items[i];  
        items[i] = items[j];  
        items[j] = y;  
        i++; j--;  
      }  
    } while(i <= j);  
  
    if(left < j) qs(items, left, j);  
    if(i < right) qs(items, i, right);  
  } 
} 
 
class QSDemo { 
  public static void main(String args[]) { 
    char a[] = { 'd', 'x', 'a', 'r', 'p', 'j', 'i' }; 
    int i; 
 
    System.out.print("Original array: "); 
    for(i=0; i < a.length; i++)  
      System.out.print(a[i]); 
 
    System.out.println(); 
 
    // now, sort the array 
    Quicksort.qsort(a); 
     
    System.out.print("Sorted array: "); 
    for(i=0; i < a.length; i++)  
      System.out.print(a[i]); 
  } 
}

listing 21
// Use an inner class. 
class Outer {  
  int nums[]; 
 
  Outer(int n[]) { 
    nums = n; 
  } 
  
  void Analyze() {  
    Inner inOb = new Inner();  
 
    System.out.println("Minimum: " + inOb.min());  
    System.out.println("Maximum: " + inOb.max());  
    System.out.println("Average: " + inOb.avg());  
  }  
  
  // This is an innner class.  
  class Inner {  
    int min() { 
      int m = nums[0]; 
      for(int i=1; i < nums.length; i++)  
        if(nums[i] < m) m = nums[i]; 
 
      return m; 
    } 
             
    int max() { 
      int m = nums[0]; 
      for(int i=1; i < nums.length; i++)  
        if(nums[i] > m) m = nums[i]; 
 
      return m; 
    } 
             
    int avg() { 
      int a = 0; 
      for(int i=0; i < nums.length; i++)  
        a += nums[i]; 
 
      return a / nums.length; 
    } 
  }  
}  
  
class NestedClassDemo {  
  public static void main(String args[]) {  
    int x[] = { 3, 2, 1, 5, 6, 9, 7, 8 }; 
    Outer outOb = new Outer(x);  
 
    outOb.Analyze(); 
  }  
}

listing 22
// Use ShowBits as a local class.  
class LocalClassDemo {  
  public static void main(String args[]) {  
 
    // An inner class version of ShowBits. 
    class ShowBits {  
      int numbits;  
    
      ShowBits(int n) {  
        numbits = n;  
      }  
  
      void show(long val) {  
        long mask = 1;  
  
        // left-shit a 1 into the proper position  
        mask <<= numbits-1;  
   
        int spacer = 0;  
        for(; mask != 0; mask >>>= 1) {  
          if((val & mask) != 0) System.out.print("1");  
          else System.out.print("0");  
          spacer++;  
          if((spacer % 8) == 0) {  
            System.out.print(" ");  
            spacer = 0;  
          }  
        }  
        System.out.println();  
      }  
    }  
  
     
    for(byte b = 0; b < 10; b++) { 
      ShowBits byteval = new ShowBits(8);  
 
      System.out.print(b + " in binary: "); 
      byteval.show(b);  
    } 
  }  
}

listing 23
// Demonstrate variable-length arguments. 
class VarArgs { 
 
  // vaTest() uses a vararg. 
  static void vaTest(int ... v) { 
    System.out.println("Number of args: " + v.length); 
    System.out.println("Contents: "); 
 
    for(int i=0; i < v.length; i++) 
      System.out.println("  arg " + i + ": " + v[i]); 
 
    System.out.println(); 
  } 
 
  public static void main(String args[])  
  { 
 
    // Notice how vaTest() can be called with a 
    // variable number of arguments. 
    vaTest(10);      // 1 arg 
    vaTest(1, 2, 3); // 3 args 
    vaTest();        // no args 
  } 
}

listing 24
// Use varargs with standard arguments.  
class VarArgs2 {  
  
  // Here, msg is a normal parameter and v is a  
  // varargs parameter.  
  static void vaTest(String msg, int ... v) {  
    System.out.println(msg + v.length);  
    System.out.println("Contents: ");  
  
    for(int i=0; i < v.length; i++)  
      System.out.println("  arg " + i + ": " + v[i]);  
  
    System.out.println();  
  }  
  
  public static void main(String args[])   
  {  
    vaTest("One vararg: ", 10);  
    vaTest("Three varargs: ", 1, 2, 3);   
    vaTest("No varargs: ");   
  }  
}

listing 25
// Varargs and overloading.  
class VarArgs3 {  
  
  static void vaTest(int ... v) {  
    System.out.println("vaTest(int ...): " + 
                       "Number of args: " + v.length);  
    System.out.println("Contents: ");  
  
    for(int i=0; i < v.length; i++)  
      System.out.println("  arg " + i + ": " + v[i]);  
  
    System.out.println();  
  }  
  
  static void vaTest(boolean ... v) {  
    System.out.println("vaTest(boolean ...): " + 
                       "Number of args: " + v.length);  
    System.out.println("Contents: ");  
  
    for(int i=0; i < v.length; i++)  
      System.out.println("  arg " + i + ": " + v[i]);  
  
    System.out.println();  
  }  
  
  static void vaTest(String msg, int ... v) {  
    System.out.println("vaTest(String, int ...): " + 
                       msg + v.length);  
    System.out.println("Contents: ");  
  
    for(int i=0; i < v.length; i++)  
      System.out.println("  arg " + i + ": " + v[i]);  
  
    System.out.println();  
  }  
  
  public static void main(String args[])   
  {  
    vaTest(1, 2, 3);   
    vaTest("Testing: ", 10, 20);  
    vaTest(true, false, false);  
  }  
}

listing 26
// Varargs, overloading, and ambiguity.  
//  
// This program contains an error and will  
// not compile!  
class VarArgs4 {  
 
  // Use an int vararg parameter.  
  static void vaTest(int ... v) {  
    // ... 
  }  
  
  // Use a boolean vararg parameter.  
  static void vaTest(boolean ... v) {  
    // ... 
  }  
  
  
  public static void main(String args[])   
  {  
    vaTest(1, 2, 3);  // OK  
    vaTest(true, false, false); // OK  
  
    vaTest(); // Error: Ambiguous!  
  }  
}

 
listing 1
// A simple class hierarchy. 
 
// A class for two-dimensional objects. 
class TwoDShape { 
  double width; 
  double height; 
 
  void showDim() { 
    System.out.println("Width and height are " + 
                       width + " and " + height); 
  } 
} 
 
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape { 
  String style; 
   
  double area() { 
    return width * height / 2; 
  } 
 
  void showStyle() { 
    System.out.println("Triangle is " + style); 
  } 
} 
 
class Shapes { 
  public static void main(String args[]) { 
    Triangle t1 = new Triangle(); 
    Triangle t2 = new Triangle(); 
 
    t1.width = 4.0; 
    t1.height = 4.0; 
    t1.style = "isosceles"; 
 
    t2.width = 8.0; 
    t2.height = 12.0; 
    t2.style = "right"; 
 
    System.out.println("Info for t1: "); 
    t1.showStyle(); 
    t1.showDim(); 
    System.out.println("Area is " + t1.area()); 
 
    System.out.println(); 
 
    System.out.println("Info for t2: "); 
    t2.showStyle(); 
    t2.showDim(); 
    System.out.println("Area is " + t2.area()); 
  } 
}

listing 2
// A subclass of TwoDShape for rectangles. 
class Rectangle extends TwoDShape { 
  boolean isSquare() { 
    if(width == height) return true; 
    return false; 
  } 
   
  double area() { 
    return width * height; 
  } 
}

listing 3
// Private members are not inherited.  
 
// This example will not compile. 
 
// A class for two-dimensional objects. 
class TwoDShape { 
  private double width;  // these are 
  private double height; // now private  
 
  void showDim() { 
    System.out.println("Width and height are " + 
                       width + " and " + height); 
  } 
} 
 
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape { 
  String style; 
   
  double area() { 
    return width * height / 2; // Error! can't access 
  } 
 
  void showStyle() { 
    System.out.println("Triangle is " + style); 
  } 
}

listing 4
// Use accessor methods to set and get private members. 
 
// A class for two-dimensional objects. 
class TwoDShape { 
  private double width;  // these are 
  private double height; // now private  
 
  // Accessor methods for width and height. 
  double getWidth() { return width; } 
  double getHeight() { return height; } 
  void setWidth(double w) { width = w; } 
  void setHeight(double h) { height = h; } 
 
  void showDim() { 
    System.out.println("Width and height are " + 
                       width + " and " + height); 
  } 
} 
 
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape { 
  String style; 
   
  double area() { 
    return getWidth() * getHeight() / 2;  
  } 
 
  void showStyle() { 
    System.out.println("Triangle is " + style); 
  } 
} 
 
class Shapes2 { 
  public static void main(String args[]) { 
    Triangle t1 = new Triangle(); 
    Triangle t2 = new Triangle(); 
 
    t1.setWidth(4.0); 
    t1.setHeight(4.0); 
    t1.style = "isosceles"; 
 
    t2.setWidth(8.0); 
    t2.setHeight(12.0); 
    t2.style = "right"; 
 
    System.out.println("Info for t1: "); 
    t1.showStyle(); 
    t1.showDim(); 
    System.out.println("Area is " + t1.area()); 
 
    System.out.println(); 
 
    System.out.println("Info for t2: "); 
    t2.showStyle(); 
    t2.showDim(); 
    System.out.println("Area is " + t2.area()); 
  } 
}

listing 5
// Add a constructor to Triangle. 
 
// A class for two-dimensional objects. 
class TwoDShape { 
  private double width;  // these are 
  private double height; // now private  
 
  // Accessor methods for width and height. 
  double getWidth() { return width; } 
  double getHeight() { return height; } 
  void setWidth(double w) { width = w; } 
  void setHeight(double h) { height = h; } 
 
  void showDim() { 
    System.out.println("Width and height are " + 
                       width + " and " + height); 
  } 
} 
 
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape { 
  private String style; 
   
  // Constructor 
  Triangle(String s, double w, double h) { 
    setWidth(w); 
    setHeight(h); 
 
    style = s;  
  } 
 
  double area() { 
    return getWidth() * getHeight() / 2;  
  } 
 
  void showStyle() { 
    System.out.println("Triangle is " + style); 
  } 
} 
 
class Shapes3 { 
  public static void main(String args[]) { 
    Triangle t1 = new Triangle("isosceles", 4.0, 4.0); 
    Triangle t2 = new Triangle("right", 8.0, 12.0); 
 
    System.out.println("Info for t1: "); 
    t1.showStyle(); 
    t1.showDim(); 
    System.out.println("Area is " + t1.area()); 
 
    System.out.println(); 
 
    System.out.println("Info for t2: "); 
    t2.showStyle(); 
    t2.showDim(); 
    System.out.println("Area is " + t2.area()); 
  } 
}

listing 6
// Add constructors to TwoDShape. 
class TwoDShape { 
  private double width; 
  private double height; 
 
  // Parameterized constructor. 
  TwoDShape(double w, double h) { 
    width = w; 
    height = h; 
  } 
 
  // Accessor methods for width and height. 
  double getWidth() { return width; } 
  double getHeight() { return height; } 
  void setWidth(double w) { width = w; } 
  void setHeight(double h) { height = h; } 
 
  void showDim() { 
    System.out.println("Width and height are " + 
                       width + " and " + height); 
  } 
} 
 
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape { 
  private String style; 
   
  Triangle(String s, double w, double h) { 
    super(w, h); // call superclass constructor 
 
    style = s;  
  } 
 
  double area() { 
    return getWidth() * getHeight() / 2; 
  } 
 
  void showStyle() { 
    System.out.println("Triangle is " + style); 
  } 
} 
 
class Shapes4 { 
  public static void main(String args[]) { 
    Triangle t1 = new Triangle("isosceles", 4.0, 4.0); 
    Triangle t2 = new Triangle("right", 8.0, 12.0); 
 
    System.out.println("Info for t1: "); 
    t1.showStyle(); 
    t1.showDim(); 
    System.out.println("Area is " + t1.area()); 
 
    System.out.println(); 
 
    System.out.println("Info for t2: "); 
    t2.showStyle(); 
    t2.showDim(); 
    System.out.println("Area is " + t2.area()); 
  } 
}

listing 7
// Add more constructors to TwoDShape. 
class TwoDShape { 
  private double width; 
  private double height; 
 
  // A default constructor. 
  TwoDShape() { 
    width = height = 0.0; 
  } 
 
  // Parameterized constructor. 
  TwoDShape(double w, double h) { 
    width = w; 
    height = h; 
  } 
 
  // Construct object with equal width and height. 
  TwoDShape(double x) { 
    width = height = x; 
  } 
 
  // Accessor methods for width and height. 
  double getWidth() { return width; } 
  double getHeight() { return height; } 
  void setWidth(double w) { width = w; } 
  void setHeight(double h) { height = h; } 
 
  void showDim() { 
    System.out.println("Width and height are " + 
                       width + " and " + height); 
  } 
} 
 
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape { 
  private String style; 
   
  // A default constructor. 
  Triangle() { 
    super(); 
    style = "null"; 
  } 
 
  // Constructor 
  Triangle(String s, double w, double h) { 
    super(w, h); // call superclass constructor 
 
    style = s;  
  } 
 
  // Construct an isosceles triangle. 
  Triangle(double x) { 
    super(x); // call superclass constructor 
 
    style = "isosceles";  
  } 
 
  double area() { 
    return getWidth() * getHeight() / 2; 
  } 
 
  void showStyle() { 
    System.out.println("Triangle is " + style); 
  } 
} 
 
class Shapes5 { 
  public static void main(String args[]) { 
    Triangle t1 = new Triangle(); 
    Triangle t2 = new Triangle("right", 8.0, 12.0); 
    Triangle t3 = new Triangle(4.0); 
 
    t1 = t2; 
 
    System.out.println("Info for t1: "); 
    t1.showStyle(); 
    t1.showDim(); 
    System.out.println("Area is " + t1.area()); 
 
    System.out.println(); 
 
    System.out.println("Info for t2: "); 
    t2.showStyle(); 
    t2.showDim(); 
    System.out.println("Area is " + t2.area()); 
 
    System.out.println(); 
 
    System.out.println("Info for t3: "); 
    t3.showStyle(); 
    t3.showDim(); 
    System.out.println("Area is " + t3.area()); 
 
    System.out.println(); 
  } 
}

listing 8
// Using super to overcome name hiding. 
class A { 
  int i; 
} 
 
// Create a subclass by extending class A. 
class B extends A { 
  int i; // this i hides the i in A 
 
  B(int a, int b) { 
    super.i = a; // i in A 
    i = b; // i in B 
  } 
 
  void show() { 
    System.out.println("i in superclass: " + super.i); 
    System.out.println("i in subclass: " + i); 
  } 
} 
 
class UseSuper { 
  public static void main(String args[]) { 
    B subOb = new B(1, 2); 
 
    subOb.show(); 
  } 
}

listing 9
// Build a subclass of Vehicle for trucks. 
class Vehicle {    
  private int passengers; // number of passengers    
  private int fuelcap;    // fuel capacity in gallons   
  private int mpg;        // fuel consumption in miles per gallon   
   
  // This is a constructor for Vehicle.  
  Vehicle(int p, int f, int m) {  
    passengers = p;  
    fuelcap = f;  
    mpg = m;  
  }  
 
  // Return the range.   
  int range() {   
    return mpg * fuelcap;   
  }   
   
  // Compute fuel needed for a given distance.  
  double fuelneeded(int miles) {   
    return (double) miles / mpg;   
  } 
 
  // Access methods for instance variables. 
  int getPassengers() { return passengers; } 
  void setPassengers(int p) { passengers = p; } 
  int getFuelcap() { return fuelcap; } 
  void setFuelcap(int f) { fuelcap = f; } 
  int getMpg() { return mpg; } 
  void setMpg(int m) { mpg = m; } 
   
}    
  
// Extend Vehicle to create a Truck specialization.    
class Truck extends Vehicle {  
  private int cargocap; // cargo capacity in pounds  
  
  // This is a constructor for Truck.  
  Truck(int p, int f, int m, int c) {  
    /* Initialize Vehicle members using 
       Vehicle's constructor. */ 
    super(p, f, m);  
 
    cargocap = c;  
  }  
 
  // Accessor methods for cargocap. 
  int getCargo() { return cargocap; } 
  void putCargo(int c) { cargocap = c; } 
}  
    
class TruckDemo {    
  public static void main(String args[]) {    
  
    // construct some trucks 
    Truck semi = new Truck(2, 200, 7, 44000);    
    Truck pickup = new Truck(3, 28, 15, 2000);    
    double gallons;   
    int dist = 252;   
   
    gallons = semi.fuelneeded(dist);    
    
    System.out.println("Semi can carry " + semi.getCargo() +  
                       " pounds."); 
    System.out.println("To go " + dist + " miles semi needs " +   
                       gallons + " gallons of fuel.\n");   
       
    gallons = pickup.fuelneeded(dist);    
    
    System.out.println("Pickup can carry " + pickup.getCargo() +  
                       " pounds."); 
    System.out.println("To go " + dist + " miles pickup needs " +   
                       gallons + " gallons of fuel.");  
  }    
}

listing 10
// Create an off-road vehicle class 
class OffRoad extends Vehicle { 
  private int groundClearance; // ground clearance in inches 
 
  // ... 
}

listing 11
// A multilevel hierarchy. 
class TwoDShape { 
  private double width; 
  private double height; 
 
  // A default constructor. 
  TwoDShape() { 
    width = height = 0.0; 
  } 
 
  // Parameterized constructor. 
  TwoDShape(double w, double h) { 
    width = w; 
    height = h; 
  } 
 
  // Construct object with equal width and height. 
  TwoDShape(double x) { 
    width = height = x; 
  } 
 
  // Accessor methods for width and height. 
  double getWidth() { return width; } 
  double getHeight() { return height; } 
  void setWidth(double w) { width = w; } 
  void setHeight(double h) { height = h; } 
 
  void showDim() { 
    System.out.println("Width and height are " + 
                       width + " and " + height); 
  } 
} 
 
// Extend TwoDShape. 
class Triangle extends TwoDShape { 
  private String style; 
   
  // A default constructor. 
  Triangle() { 
    super(); 
    style = "null"; 
  } 
 
  Triangle(String s, double w, double h) { 
    super(w, h); // call superclass constructor 
 
    style = s;  
  } 
 
  // Construct an isosceles triangle. 
  Triangle(double x) { 
    super(x); // call superclass constructor 
 
    style = "isosceles";  
  } 
 
  double area() { 
    return getWidth() * getHeight() / 2; 
  } 
 
  void showStyle() { 
    System.out.println("Triangle is " + style); 
  } 
} 
 
// Extend Triangle. 
class ColorTriangle extends Triangle { 
  private String color; 
 
  ColorTriangle(String c, String s, 
                double w, double h) { 
    super(s, w, h); 
 
    color = c; 
  } 
 
  String getColor() { return color; } 
 
  void showColor() { 
    System.out.println("Color is " + color); 
  } 
} 
 
class Shapes6 { 
  public static void main(String args[]) { 
    ColorTriangle t1 =  
         new ColorTriangle("Blue", "right", 8.0, 12.0); 
    ColorTriangle t2 =  
         new ColorTriangle("Red", "isosceles", 2.0, 2.0); 
 
    System.out.println("Info for t1: "); 
    t1.showStyle(); 
    t1.showDim(); 
    t1.showColor(); 
    System.out.println("Area is " + t1.area()); 
 
    System.out.println(); 
 
    System.out.println("Info for t2: "); 
    t2.showStyle(); 
    t2.showDim(); 
    t2.showColor(); 
    System.out.println("Area is " + t2.area()); 
  } 
}

listing 12
// Demonstrate when constructors are called. 
 
// Create a super class. 
class A { 
  A() {  
    System.out.println("Constructing A."); 
  } 
} 
 
// Create a subclass by extending class A. 
class B extends A { 
  B() { 
    System.out.println("Constructing B."); 
  } 
} 
 
// Create another subclass by extending B. 
class C extends B { 
  C() { 
    System.out.println("Constructing C."); 
  } 
} 
 
class OrderOfConstruction { 
  public static void main(String args[]) {
    C c = new C(); 
  } 
}

listing 13
// This will not compile. 
class X { 
  int a; 
 
  X(int i) { a = i; } 
} 
 
class Y { 
  int a; 
 
  Y(int i) { a = i; } 
} 
 
class IncompatibleRef { 
  public static void main(String args[]) { 
    X x = new X(10); 
    X x2;  
    Y y = new Y(5); 
 
    x2 = x; // OK, both of same type 
 
    x2 = y; // Error, not of same type 
  } 
}

listing 14
// A superclass reference can refer to a subclass object. 
class X { 
  int a; 
 
  X(int i) { a = i; } 
} 
 
class Y extends X { 
  int b; 
 
  Y(int i, int j) { 
    super(j); 
    b = i; 
  } 
} 
 
class SupSubRef { 
  public static void main(String args[]) { 
    X x = new X(10); 
    X x2;  
    Y y = new Y(5, 6); 
 
    x2 = x; // OK, both of same type 
    System.out.println("x2.a: " + x2.a); 
 
    x2 = y; // still Ok because Y is derived from X 
    System.out.println("x2.a: " + x2.a); 
 
    // X references know only about X members 
    x2.a = 19; // OK 
//    x2.b = 27; // Error, X doesn't have a b member 
  } 
}

listing 15
class TwoDShape { 
  private double width; 
  private double height; 
 
  // A default constructor. 
  TwoDShape() { 
    width = height = 0.0; 
  } 
 
  // Parameterized constructor. 
  TwoDShape(double w, double h) { 
    width = w; 
    height = h; 
  } 
 
  // Construct object with equal width and height. 
  TwoDShape(double x) { 
    width = height = x; 
  } 
 
  // Construct an object from an object. 
  TwoDShape(TwoDShape ob) { 
    width = ob.width; 
    height = ob.height; 
  } 
 
  // Accessor methods for width and height. 
  double getWidth() { return width; } 
  double getHeight() { return height; } 
  void setWidth(double w) { width = w; } 
  void setHeight(double h) { height = h; } 
 
  void showDim() { 
    System.out.println("Width and height are " + 
                       width + " and " + height); 
  } 
} 
 
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape { 
  private String style; 
   
  // A default constructor. 
  Triangle() { 
    super(); 
    style = "null"; 
  } 
 
  // Constructor for Triangle. 
  Triangle(String s, double w, double h) { 
    super(w, h); // call superclass constructor 
 
    style = s;  
  } 
 
  // Construct an isosceles triangle. 
  Triangle(double x) { 
    super(x); // call superclass constructor 
 
    style = "isosceles";  
  } 
 
  // Construct an object from an object. 
  Triangle(Triangle ob) { 
    super(ob); // pass object to TwoDShape constructor 
    style = ob.style; 
  } 
 
  double area() { 
    return getWidth() * getHeight() / 2; 
  } 
 
  void showStyle() { 
    System.out.println("Triangle is " + style); 
  } 
} 
 
class Shapes7 { 
  public static void main(String args[]) { 
    Triangle t1 =  
         new Triangle("right", 8.0, 12.0); 
 
    // make a copy of t1 
    Triangle t2 = new Triangle(t1); 
 
    System.out.println("Info for t1: "); 
    t1.showStyle(); 
    t1.showDim(); 
    System.out.println("Area is " + t1.area()); 
 
    System.out.println(); 
 
    System.out.println("Info for t2: "); 
    t2.showStyle(); 
    t2.showDim(); 
    System.out.println("Area is " + t2.area()); 
  } 
}

listing 16
// Method overriding. 
class A { 
  int i, j; 
  A(int a, int b) { 
    i = a; 
    j = b; 
  } 
 
  // display i and j 
  void show() { 
    System.out.println("i and j: " + i + " " + j); 
  } 
} 
 
class B extends A {
  int k; 
 
  B(int a, int b, int c) { 
    super(a, b); 
    k = c; 
  } 
 
  // display k  this overrides show() in A 
  void show() { 
    System.out.println("k: " + k); 
  } 
} 
 
class Override { 
  public static void main(String args[]) { 
    B subOb = new B(1, 2, 3); 
 
    subOb.show(); // this calls show() in B 
  } 
}

listing 17
class B extends A { 
  int k; 
 
  B(int a, int b, int c) { 
    super(a, b); 
    k = c; 
  }
  void show() { 
    super.show(); // this calls A's show() 
    System.out.println("k: " + k); 
  } 
}

listing 18
/* Methods with differing type signatures are 
   overloaded and not overridden. */ 
class A { 
  int i, j; 
 
  A(int a, int b) { 
    i = a; 
    j = b; 
  } 
 
  // display i and j 
  void show() { 
    System.out.println("i and j: " + i + " " + j); 
  } 
} 
 
// Create a subclass by extending class A. 
class B extends A { 
  int k; 
 
  B(int a, int b, int c) { 
    super(a, b); 
    k = c;
  } 
 
  // overload show() 
  void show(String msg) { 
    System.out.println(msg + k); 
  } 
} 
 
class Overload { 
  public static void main(String args[]) { 
    B subOb = new B(1, 2, 3); 
 
    subOb.show("This is k: "); // this calls show() in B 
    subOb.show(); // this calls show() in A 
  } 
}

listing 19
// Demonstrate dynamic method dispatch. 
 
class Sup { 
  void who() { 
    System.out.println("who() in Sup"); 
  } 
} 
 
class Sub1 extends Sup { 
  void who() { 
    System.out.println("who() in Sub1"); 
  } 
} 
 
class Sub2 extends Sup { 
  void who() { 
    System.out.println("who() in Sub2"); 
  } 
} 
 
class DynDispDemo { 
  public static void main(String args[]) { 
    Sup superOb = new Sup(); 
    Sub1 subOb1 = new Sub1(); 
    Sub2 subOb2 = new Sub2(); 
 
    Sup supRef;  
 
    supRef = superOb;  
    supRef.who(); 
 
    supRef = subOb1;  
    supRef.who(); 
 
    supRef = subOb2;  
    supRef.who(); 
  } 
}

listing 20
// Use dynamic method dispatch.  
class TwoDShape {  
  private double width;  
  private double height;  
  private String name;  
  
  // A default constructor.  
  TwoDShape() {  
    width = height = 0.0;  
    name = "null";  
  }  
  
  // Parameterized constructor.  
  TwoDShape(double w, double h, String n) {  
    width = w;  
    height = h;  
    name = n;  
  }  
  
  // Construct object with equal width and height.  
  TwoDShape(double x, String n) {  
    width = height = x;  
    name = n;  
  }  
  
  // Construct an object from an object.  
  TwoDShape(TwoDShape ob) {  
    width = ob.width;  
    height = ob.height;  
    name = ob.name;  
  }  
  
  // Accessor methods for width and height.  
  double getWidth() { return width; }  
  double getHeight() { return height; }  
  void setWidth(double w) { width = w; }  
  void setHeight(double h) { height = h; }  
  
  String getName() { return name; }  
  
  void showDim() {  
    System.out.println("Width and height are " +  
                       width + " and " + height);  
  }  
  
  double area() {   
    System.out.println("area() must be overridden");  
    return 0.0;  
  }   
}  
  
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape {  
  private String style;  
    
  // A default constructor.  
  Triangle() {  
    super();  
    style = "null";  
  }  
  
  // Constructor for Triangle.  
  Triangle(String s, double w, double h) {  
    super(w, h, "triangle");  
  
    style = s;   
  }  
  
  // Construct an isosceles triangle.  
  Triangle(double x) {  
    super(x, "triangle"); // call superclass constructor  
  
    style = "isosceles";   
  }  
  
  // Construct an object from an object.  
  Triangle(Triangle ob) {  
    super(ob); // pass object to TwoDShape constructor  
    style = ob.style;  
  }  
  
  // Override area() for Triangle. 
  double area() {  
    return getWidth() * getHeight() / 2;  
  }  
  
  void showStyle() {  
    System.out.println("Triangle is " + style);  
  }  
}  
  
// A subclass of TwoDShape for rectangles.   
class Rectangle extends TwoDShape {   
  // A default constructor.  
  Rectangle() {  
    super();  
  }  
  
  // Constructor for Rectangle.  
  Rectangle(double w, double h) {  
    super(w, h, "rectangle"); // call superclass constructor  
  }  
  
  // Construct a square.  
  Rectangle(double x) {  
    super(x, "rectangle"); // call superclass constructor  
  }  
  
  // Construct an object from an object.  
  Rectangle(Rectangle ob) {  
    super(ob); // pass object to TwoDShape constructor  
  }  
  
  boolean isSquare() {   
    if(getWidth() == getHeight()) return true;   
    return false;   
  }   
     
  // Override area() for Rectangle. 
  double area() {   
    return getWidth() * getHeight();   
  }   
}  
  
class DynShapes {  
  public static void main(String args[]) {  
    TwoDShape shapes[] = new TwoDShape[5];  
  
    shapes[0] = new Triangle("right", 8.0, 12.0);  
    shapes[1] = new Rectangle(10);  
    shapes[2] = new Rectangle(10, 4);  
    shapes[3] = new Triangle(7.0);  
    shapes[4] = new TwoDShape(10, 20, "generic"); 
  
    for(int i=0; i < shapes.length; i++) {  
      System.out.println("object is " + shapes[i].getName());  
      System.out.println("Area is " + shapes[i].area());  
  
      System.out.println();    
    }  
  }  
}

listing 21
// Create an abstract class. 
abstract class TwoDShape {  
  private double width;  
  private double height;  
  private String name;  
  
  // A default constructor.  
  TwoDShape() {  
    width = height = 0.0;  
    name = "null";  
  }  
  
  // Parameterized constructor.  
  TwoDShape(double w, double h, String n) {  
    width = w;  
    height = h;  
    name = n;  
  }  
  
  // Construct object with equal width and height.  
  TwoDShape(double x, String n) {  
    width = height = x;  
    name = n;  
  }  
  
  // Construct an object from an object.  
  TwoDShape(TwoDShape ob) {  
    width = ob.width;  
    height = ob.height;  
    name = ob.name;  
  }  
  
  // Accessor methods for width and height.  
  double getWidth() { return width; }  
  double getHeight() { return height; }  
  void setWidth(double w) { width = w; }  
  void setHeight(double h) { height = h; }  
  
  String getName() { return name; }  
  
  void showDim() {  
    System.out.println("Width and height are " +  
                       width + " and " + height);  
  }  
  
  // Now, area() is abstract. 
  abstract double area(); 
}  
  
// A subclass of TwoDShape for triangles. 
class Triangle extends TwoDShape {  
  private String style;  
    
  // A default constructor.  
  Triangle() {  
    super();  
    style = "null";  
  }  
  
  // Constructor for Triangle.  
  Triangle(String s, double w, double h) {  
    super(w, h, "triangle");  
  
    style = s;   
  }  
  
  // Construct an isosceles triangle.  
  Triangle(double x) {  
    super(x, "triangle"); // call superclass constructor  
  
    style = "isosceles";   
  }  
  
  // Construct an object from an object.  
  Triangle(Triangle ob) {  
    super(ob); // pass object to TwoDShape constructor  
    style = ob.style;  
  }  
  
  double area() {  
    return getWidth() * getHeight() / 2;  
  }  
  
  void showStyle() {  
    System.out.println("Triangle is " + style);  
  }  
}  
  
// A subclass of TwoDShape for rectangles.   
class Rectangle extends TwoDShape {   
  // A default constructor.  
  Rectangle() {  
    super();  
  }  
  
  // Constructor for Rectangle.  
  Rectangle(double w, double h) {  
    super(w, h, "rectangle"); // call superclass constructor  
  }  
  
  // Construct a square.  
  Rectangle(double x) {  
    super(x, "rectangle"); // call superclass constructor  
  }  
  
  // Construct an object from an object.  
  Rectangle(Rectangle ob) {  
    super(ob); // pass object to TwoDShape constructor  
  }  
  
  boolean isSquare() {   
    if(getWidth() == getHeight()) return true;   
    return false;   
  }   
     
  double area() {   
    return getWidth() * getHeight();   
  }   
}  
  
class AbsShape {  
  public static void main(String args[]) {  
    TwoDShape shapes[] = new TwoDShape[4];  
  
    shapes[0] = new Triangle("right", 8.0, 12.0);  
    shapes[1] = new Rectangle(10);  
    shapes[2] = new Rectangle(10, 4);  
    shapes[3] = new Triangle(7.0);  
  
    for(int i=0; i < shapes.length; i++) {  
      System.out.println("object is " + shapes[i].getName());  
      System.out.println("Area is " + shapes[i].area());  
  
      System.out.println();    
    }  
  }  
}

listing 22
class A { 
  final void meth() { 
    System.out.println("This is a final method."); 
  } 
} 
 
class B extends A { 
  void meth() { // ERROR! Can't override.
    System.out.println("Illegal!"); 
  } 
}

listing 23
// Return a String object.  
class ErrorMsg {  
  // Error codes. 
  final int OUTERR   = 0; 
  final int INERR    = 1; 
  final int DISKERR  = 2; 
  final int INDEXERR = 3; 
 
  String msgs[] = {  
    "Output Error",  
    "Input Error",  
    "Disk Full",  
    "Index Out-Of-Bounds"  
  };  
  
  // Return the error message.  
  String getErrorMsg(int i) {  
    if(i >=0 & i < msgs.length)  
      return msgs[i];  
    else  
      return "Invalid Error Code";  
  }  
}  
  
class FinalD {  
  public static void main(String args[]) {  
    ErrorMsg err = new ErrorMsg();  
  
    System.out.println(err.getErrorMsg(err.OUTERR));  
    System.out.println(err.getErrorMsg(err.DISKERR));  
  }  
}

listing 1
// A short package demonstration.  
package BookPack;  
  
class Book {  
  private String title;  
  private String author;  
  private int pubDate;  
  
  Book(String t, String a, int d) {  
    title = t;  
    author = a;  
    pubDate = d;  
  }  
  
  void show() {  
    System.out.println(title);  
    System.out.println(author);  
    System.out.println(pubDate); 
    System.out.println(); 
  }  
}  
  
class BookDemo {  
  public static void main(String args[]) {  
    Book books[] = new Book[5];  
  
    books[0] = new Book("Java: A Beginner's Guide", 
                        "Schildt", 2007);  
    books[1] = new Book("Java: The Complete Reference", 
                        "Schildt", 2007); 
    books[2] = new Book("The Art of Java", 
                        "Schildt and Holmes", 2003); 
    books[3] = new Book("Red Storm Rising", 
                         "Clancy", 1986);  
    books[4] = new Book("On the Road", 
                        "Kerouac", 1955);  
  
    for(int i=0; i < books.length; i++) books[i].show();  
  } 
}

listing 2
// Book recoded for public access. 
package BookPack; 
 
public class Book {  
  private String title;  
  private String author;  
  private int pubDate; 
 
  // Now public. 
  public Book(String t, String a, int d) {  
    title = t;  
    author = a;  
    pubDate = d;  
  } 
 
  // Now public. 
  public void show() {  
    System.out.println(title);  
    System.out.println(author);  
    System.out.println(pubDate);   
    System.out.println(); 
  }  
}

listing 3
// This class is in package BookPackB. 
package BookPackB; 
 
// Use the Book Class from BookPack. 
class UseBook {  
  public static void main(String args[]) {  
    BookPack.Book books[] = new BookPack.Book[5]; 
 
    books[0] = new BookPack.Book("Java: A Beginner's Guide", 
                       "Schildt", 2005);  
    books[1] = new BookPack.Book("Java: The Complete Reference", 
                       "Schildt", 2005); 
    books[2] = new BookPack.Book("The Art of Java", 
                       "Schildt and Holmes", 2003); 
    books[3] = new BookPack.Book("Red Storm Rising", 
                        "Clancy", 1986);  
    books[4] = new BookPack.Book("On the Road", 
                       "Kerouac", 1955);  
  
    for(int i=0; i < books.length; i++) books[i].show();  
  } 
}

listing 4
// Make the instance variables in Book protected. 
package BookPack; 
 
public class Book { 
  // these are now protected 
  protected String title;  
  protected String author;  
  protected int pubDate; 
 
  public Book(String t, String a, int d) {  
    title = t;  
    author = a;  
    pubDate = d;  
  } 
 
   public void show() {  
    System.out.println(title);  
    System.out.println(author);  
    System.out.println(pubDate);   
    System.out.println(); 
  }  
}

listing 5
// Demonstrate Protected.  
package BookPackB; 
 
class ExtBook extends BookPack.Book { 
  private String publisher; 
 
  public ExtBook(String t, String a, int d, String p) {   
    super(t, a, d);  
    publisher = p;  
  } 
 
  public void show() {   
    super.show();   
    System.out.println(publisher);   
    System.out.println();    
  } 
 
  public String getPublisher() { return publisher; }  
  public void setPublisher(String p) { publisher = p; } 
 
  /* These are OK because subclass can access  
     a protected member. */  
  public String getTitle() { return title; }  
  public void setTitle(String t) { title = t; }  
  public String getAuthor() { return author; }  
  public void setAuthor(String a) { author = a; }  
  public int getPubDate() { return pubDate; }  
  public void setPubDate(int d) { pubDate = d; }  
} 
 
class ProtectDemo {   
  public static void main(String args[]) {   
    ExtBook books[] = new ExtBook[5]; 
 
    books[0] = new ExtBook("Java: A Beginner's Guide", 
                      "Schildt", 2005, "Osborne/McGraw-Hill");  
    books[1] = new ExtBook("Java: The Complete Reference", 
                      "Schildt", 2005, "Osborne/McGraw-Hill"); 
    books[2] = new ExtBook("The Art of Java", 
                      "Schildt and Holmes", 2003, 
                      "Osborne/McGraw-Hill"); 
    books[3] = new ExtBook("Red Storm Rising", 
                      "Clancy", 1986, "Putnam");  
    books[4] = new ExtBook("On the Road", 
                      "Kerouac", 1955, "Viking");  
 
    for(int i=0; i < books.length; i++) books[i].show();  
 
    // Find books by author 
    System.out.println("Showing all books by Schildt."); 
    for(int i=0; i < books.length; i++) 
      if(books[i].getAuthor() == "Schildt") 
        System.out.println(books[i].getTitle()); 
 
//    books[0].title = "test title"; // Error -- not accessible  
  }  
}

listing 6
// Demonstrate import. 
package BookPackB; 
import BookPack.*; 
 
// Use the Book Class from BookPack.  
class UseBook {  
  public static void main(String args[]) {  
    Book books[] = new Book[5];  
  
    books[0] = new Book("Java: A Beginner's Guide", 
                        "Schildt", 2005);  
    books[1] = new Book("Java: The Complete Reference", 
                        "Schildt", 2005); 
    books[2] = new Book("The Art of Java", 
                        "Schildt and Holmes", 2003); 
    books[3] = new Book("Red Storm Rising", 
                         "Clancy", 1986);  
    books[4] = new Book("On the Road", 
                        "Kerouac", 1955);  
  
    for(int i=0; i < books.length; i++) books[i].show();  
  } 
}

listing 7
public interface Series { 
  int getNext(); // return next number in series 
  void reset(); // restart 
  void setStart(int x); // set starting value 
}

listing 8
// Implement Series. 
class ByTwos implements Series { 
  int start; 
  int val; 
 
  ByTwos() { 
    start = 0; 
    val = 0; 
  }  
 
  public int getNext() { 
    val += 2; 
    return val; 
  } 
 
  public void reset() { 
    start = 0; 
    val = 0; 
  } 
 
  public void setStart(int x) { 
    start = x; 
    val = x; 
  } 
}

listing 9
class SeriesDemo { 
  public static void main(String args[]) { 
    ByTwos ob = new ByTwos(); 
 
    for(int i=0; i < 5; i++) 
      System.out.println("Next value is " + 
                         ob.getNext()); 
 
    System.out.println("\nResetting"); 
    ob.reset(); 
    for(int i=0; i < 5; i++) 
      System.out.println("Next value is " + 
                         ob.getNext()); 
 
    System.out.println("\nStarting at 100"); 
    ob.setStart(100); 
    for(int i=0; i < 5; i++) 
      System.out.println("Next value is " + 
                         ob.getNext()); 
  } 
}

listing 10
// Implement Series and add getPrevious(). 
class ByTwos implements Series { 
  int start; 
  int val; 
  int prev; 
 
  ByTwos() { 
    start = 0; 
    val = 0; 
    prev = -2; 
  }  
 
  public int getNext() { 
    prev = val; 
    val += 2; 
    return val; 
  } 
 
  public void reset() { 
    start = 0; 
    val = 0; 
    prev = -2; 
  } 
 
  public void setStart(int x) { 
    start = x; 
    val = x; 
    prev = x - 2; 
  } 
 
  int getPrevious() { 
    return prev; 
  } 
}

listing 11
// Implement Series. 
class ByThrees implements Series { 
  int start; 
  int val; 
 
  ByThrees() { 
    start = 0; 
    val = 0; 
  } 
 
  public int getNext() { 
    val += 3; 
    return val; 
  } 
 
  public void reset() { 
    start = 0; 
    val = 0; 
  } 
 
  public void setStart(int x) { 
    start = x; 
    val = x; 
  } 
}

listing 12
// Demonstrate interface references. 
 
class ByTwos implements Series { 
  int start; 
  int val; 
 
  ByTwos() { 
    start = 0; 
    val = 0; 
  }  
 
  public int getNext() { 
    val += 2; 
    return val; 
  } 
 
  public void reset() { 
    start = 0; 
    val = 0; 
  } 
 
  public void setStart(int x) { 
    start = x; 
    val = x; 
  } 
} 
 
class ByThrees implements Series { 
  int start; 
  int val; 
 
  ByThrees() { 
    start = 0; 
    val = 0; 
  }  
 
  public int getNext() { 
    val += 3; 
    return val; 
  } 
 
  public void reset() { 
    start = 0; 
    val = 0; 
  } 
 
  public void setStart(int x) { 
    start = x; 
    val = x; 
  } 
} 
 
class SeriesDemo2 { 
  public static void main(String args[]) { 
    ByTwos twoOb = new ByTwos(); 
    ByThrees threeOb = new ByThrees(); 
    Series ob; 
 
    for(int i=0; i < 5; i++) { 
      ob = twoOb; 
      System.out.println("Next ByTwos value is " + 
                          ob.getNext()); 
      ob = threeOb; 
      System.out.println("Next ByThrees value is " + 
                          ob.getNext()); 
    } 
  } 
}

listing 13
// A character queue interface. 
public interface ICharQ {    
  // Put a characer into the queue.    
  void put(char ch); 
 
  // Get a character from the queue.   
  char get(); 
}
 
listing 14
// A fixed-size queue class for characters.    
class FixedQueue implements ICharQ {    
  private char q[]; // this array holds the queue    
  private int putloc, getloc; // the put and get indices    
    
  // Construct an empty queue given its size.   
  public FixedQueue(int size) {    
    q = new char[size+1]; // allocate memory for queue    
    putloc = getloc = 0;    
  }    
   
  // Put a characer into the queue.    
  public void put(char ch) {    
    if(putloc==q.length-1) {    
      System.out.println(" -- Queue is full.");    
      return;    
    }    
        
    putloc++;    
    q[putloc] = ch;    
  }    
    
  // Get a character from the queue.   
  public char get() {    
    if(getloc == putloc) {    
      System.out.println(" -- Queue is empty.");    
      return (char) 0;     
    }    
      
    getloc++;    
    return q[getloc];    
  }    
}

listing 15
// A circular queue. 
class CircularQueue implements ICharQ {    
  private char q[]; // this array holds the queue    
  private int putloc, getloc; // the put and get indices    
    
  // Construct an empty queue given its size.   
  public CircularQueue(int size) {    
    q = new char[size+1]; // allocate memory for queue    
    putloc = getloc = 0;    
  }    
   
  // Put a characer into the queue.    
  public void put(char ch) {    
    /* Queue is full if either putloc is one less than 
       getloc, or if putloc is at the end of the array 
       and getloc is at the beginning. */ 
    if(putloc+1==getloc | 
       ((putloc==q.length-1) & (getloc==0))) {    
      System.out.println(" -- Queue is full.");    
      return;    
    }    
        
    putloc++;    
    if(putloc==q.length) putloc = 0; // loop back 
    q[putloc] = ch;    
  }    
    
  // Get a character from the queue.   
  public char get() {    
    if(getloc == putloc) {    
      System.out.println(" -- Queue is empty.");    
      return (char) 0;     
    }    
      
    getloc++;    
    if(getloc==q.length) getloc = 0; // loop back 
    return q[getloc];    
  }    
}

listing 16
// A dynamic queue. 
class DynQueue implements ICharQ {    
  private char q[]; // this array holds the queue    
  private int putloc, getloc; // the put and get indices    
    
  // Construct an empty queue given its size.   
  public DynQueue(int size) {    
    q = new char[size+1]; // allocate memory for queue    
    putloc = getloc = 0;    
  }    
   
  // Put a characer into the queue.    
  public void put(char ch) {    
    if(putloc==q.length-1) {    
      // increase queue size 
      char t[] = new char[q.length * 2]; 
 
      // copy elements into new queue 
      for(int i=0; i < q.length; i++) 
        t[i] = q[i]; 
 
      q = t; 
    }    
        
    putloc++;    
    q[putloc] = ch;    
  }    
    
  // Get a character from the queue.   
  public char get() {    
    if(getloc == putloc) {    
      System.out.println(" -- Queue is empty.");    
      return (char) 0;     
    }    
      
    getloc++;    
    return q[getloc];    
  }    
}

listing 17
// Demonstrate the ICharQ interface.    
class IQDemo {    
  public static void main(String args[]) {    
    FixedQueue q1 = new FixedQueue(10);    
    DynQueue q2 = new DynQueue(5); 
    CircularQueue q3 = new CircularQueue(10); 
 
    ICharQ iQ; 
 
    char ch;    
    int i;    
 
    iQ = q1;    
    // Put some characters into fixed queue.    
    for(i=0; i < 10; i++)    
      iQ.put((char) ('A' + i));    
   
    // Show the queue. 
    System.out.print("Contents of fixed queue: ");    
    for(i=0; i < 10; i++) {     
      ch = iQ.get();    
      System.out.print(ch);    
    } 
    System.out.println(); 
 
    iQ = q2; 
    // Put some characters into dynamic queue.    
    for(i=0; i < 10; i++)    
      iQ.put((char) ('Z' - i));    
   
    // Show the queue. 
    System.out.print("Contents of dynamic queue: ");    
    for(i=0; i < 10; i++) {     
      ch = iQ.get();    
      System.out.print(ch);    
    }    
 
    System.out.println(); 
 
    iQ = q3; 
    // Put some characters into circular queue.    
    for(i=0; i < 10; i++)    
      iQ.put((char) ('A' + i));    
   
    // Show the queue. 
    System.out.print("Contents of circular queue: ");    
    for(i=0; i < 10; i++) {     
      ch = iQ.get();    
      System.out.print(ch);    
    }    
 
    System.out.println(); 
 
    // Put more characters into circular queue.    
    for(i=10; i < 20; i++)    
      iQ.put((char) ('A' + i));    
 
    // Show the queue. 
    System.out.print("Contents of circular queue: ");    
    for(i=0; i < 10; i++) {     
      ch = iQ.get();    
      System.out.print(ch);    
    }    
 
    System.out.println("\nStore and consume from" + 
                       " circular queue."); 
 
    // Use and consume from circular queue. 
    for(i=0; i < 20; i++) { 
      iQ.put((char) ('A' + i));    
      ch = iQ.get();    
      System.out.print(ch);    
    }    
 
  }    
}

listing 18
// An interface that contains constants. 
interface IConst { 
  int MIN = 0; 
  int MAX = 10; 
  String ERRORMSG = "Boundary Error"; 
} 
 
class IConstD implements IConst { 
  public static void main(String args[]) { 
    int nums[] = new int[MAX]; 
 
    for(int i=MIN; i < 11; i++) { 
      if(i >= MAX) System.out.println(ERRORMSG); 
      else { 
        nums[i] = i; 
        System.out.print(nums[i] + " "); 
      } 
    } 
  } 
}

listing 19
// One interface can extend another. 
interface A { 
  void meth1(); 
  void meth2(); 
} 
 
// B now includes meth1() and meth2() -- it adds meth3(). 
interface B extends A { 
  void meth3(); 
} 
 
// This class must implement all of A and B 
class MyClass implements B { 
  public void meth1() { 
    System.out.println("Implement meth1()."); 
  } 
 
  public void meth2() { 
    System.out.println("Implement meth2()."); 
  } 
 
  public void meth3() { 
    System.out.println("Implement meth3()."); 
  } 
} 
 
class IFExtend { 
  public static void main(String arg[]) { 
    MyClass ob = new MyClass(); 
 
    ob.meth1(); 
    ob.meth2(); 
    ob.meth3(); 
  } 
}

 
listing 1
// Demonstrate exception handling. 
class ExcDemo1 { 
  public static void main(String args[]) { 
    int nums[] = new int[4]; 
 
    try { 
      System.out.println("Before exception is generated."); 
 
      // Generate an index out-of-bounds exception. 
      nums[7] = 10; 
      System.out.println("this won't be displayed"); 
    } 
    catch (ArrayIndexOutOfBoundsException exc) { 
      // catch the exception 
      System.out.println("Index out-of-bounds!"); 
    } 
    System.out.println("After catch statement."); 
  } 
}

listing 2
/* An exception can be generated by one 
   method and caught by another. */ 
 
class ExcTest { 
  // Generate an exception. 
  static void genException() { 
    int nums[] = new int[4];  
 
    System.out.println("Before exception is generated."); 
  
    // generate an index out-of-bounds exception  
    nums[7] = 10;  
    System.out.println("this won't be displayed");  
  } 
}     
 
class ExcDemo2 {  
  public static void main(String args[]) {  
  
    try {  
      ExcTest.genException(); 
    }  
    catch (ArrayIndexOutOfBoundsException exc) {  
      // catch the exception  
      System.out.println("Index out-of-bounds!");  
    }  
    System.out.println("After catch statement.");  
  }  
}

listing 3
// Let JVM handle the error. 
class NotHandled { 
  public static void main(String args[]) { 
    int nums[] = new int[4]; 
 
    System.out.println("Before exception is generated."); 
 
    // generate an index out-of-bounds exception 
    nums[7] = 10; 
  } 
}

listing 4
// This won't work! 
class ExcTypeMismatch {  
  public static void main(String args[]) {  
    int nums[] = new int[4];  
  
    try {  
      System.out.println("Before exception is generated."); 
  
      // generate an index out-of-bounds exception  
      nums[7] = 10;  
      System.out.println("this won't be displayed");  
    }  
 
    /* Can't catch an array boundary error with an  
       ArithmeticException. */ 
    catch (ArithmeticException exc) {  
      // catch the exception  
      System.out.println("Index out-of-bounds!");  
    }  
    System.out.println("After catch statement.");  
  }  
}

listing 5
// Handle error gracefully and continue. 
class ExcDemo3 { 
  public static void main(String args[]) { 
    int numer[] = { 4, 8, 16, 32, 64, 128 }; 
    int denom[] = { 2, 0, 4, 4, 0, 8 }; 
 
    for(int i=0; i<numer.length; i++) { 
      try { 
        System.out.println(numer[i] + " / " + 
                           denom[i] + " is " + 
                           numer[i]/denom[i]); 
      } 
      catch (ArithmeticException exc) { 
        // catch the exception 
        System.out.println("Can't divide by Zero!"); 
      } 
    } 
  } 
}

listing 6
// Use multiple catch statements. 
class ExcDemo4 { 
  public static void main(String args[]) { 
    // Here, numer is longer than denom. 
    int numer[] = { 4, 8, 16, 32, 64, 128, 256, 512 }; 
    int denom[] = { 2, 0, 4, 4, 0, 8 }; 
 
    for(int i=0; i<numer.length; i++) { 
      try { 
        System.out.println(numer[i] + " / " + 
                           denom[i] + " is " + 
                           numer[i]/denom[i]); 
      } 
      catch (ArithmeticException exc) { 
        // catch the exception 
        System.out.println("Can't divide by Zero!"); 
      } 
      catch (ArrayIndexOutOfBoundsException exc) { 
        // catch the exception 
        System.out.println("No matching element found."); 
      } 
    } 
  } 
}

listing 7
// Subclasses must precede superclasses in catch statements. 
class ExcDemo5 { 
  public static void main(String args[]) { 
    // Here, numer is longer than denom. 
    int numer[] = { 4, 8, 16, 32, 64, 128, 256, 512 }; 
    int denom[] = { 2, 0, 4, 4, 0, 8 }; 
 
    for(int i=0; i<numer.length; i++) { 
      try { 
        System.out.println(numer[i] + " / " + 
                           denom[i] + " is " + 
                           numer[i]/denom[i]); 
      } 
      catch (ArrayIndexOutOfBoundsException exc) { 
        // catch the exception 
        System.out.println("No matching element found."); 
      } 
      catch (Throwable exc) { 
        System.out.println("Some exception occurred."); 
      } 
    } 
  } 
}

listing 8
// Use a nested try block. 
class NestTrys { 
  public static void main(String args[]) { 
    // Here, numer is longer than denom. 
    int numer[] = { 4, 8, 16, 32, 64, 128, 256, 512 }; 
    int denom[] = { 2, 0, 4, 4, 0, 8 }; 
 
    try { // outer try 
      for(int i=0; i<numer.length; i++) { 
        try { // nested try 
          System.out.println(numer[i] + " / " + 
                             denom[i] + " is " + 
                             numer[i]/denom[i]); 
        } 
        catch (ArithmeticException exc) { 
          // catch the exception 
          System.out.println("Can't divide by Zero!"); 
        } 
      } 
    }  
    catch (ArrayIndexOutOfBoundsException exc) { 
      // catch the exception 
      System.out.println("No matching element found."); 
      System.out.println("Fatal error -- program terminated."); 
    } 
  } 
}

listing 9
// Manually throw an exception. 
class ThrowDemo { 
  public static void main(String args[]) { 
    try { 
      System.out.println("Before throw."); 
      throw new ArithmeticException(); 
    } 
    catch (ArithmeticException exc) { 
      // catch the exception 
      System.out.println("Exception caught."); 
    } 
    System.out.println("After try/catch block."); 
  } 
}

listing 10
// Rethrow an exception. 
class Rethrow { 
  public static void genException() { 
    // here, numer is longer than denom 
    int numer[] = { 4, 8, 16, 32, 64, 128, 256, 512 }; 
    int denom[] = { 2, 0, 4, 4, 0, 8 }; 
 
    for(int i=0; i<numer.length; i++) { 
      try { 
        System.out.println(numer[i] + " / " + 
                           denom[i] + " is " + 
                           numer[i]/denom[i]); 
      } 
      catch (ArithmeticException exc) { 
        // catch the exception 
        System.out.println("Can't divide by Zero!"); 
      } 
      catch (ArrayIndexOutOfBoundsException exc) { 
        // catch the exception 
        System.out.println("No matching element found."); 
        throw exc; // rethrow the exception 
      } 
    } 
  }   
} 
 
class RethrowDemo { 
  public static void main(String args[]) { 
    try { 
      Rethrow.genException(); 
    } 
    catch(ArrayIndexOutOfBoundsException exc) { 
      // recatch exception 
     System.out.println("Fatal error -- " + 
                        "program terminated."); 
    } 
  } 
}

listing 11
// Using the Throwable methods.  
 
class ExcTest { 
  static void genException() { 
    int nums[] = new int[4];  
 
    System.out.println("Before exception is generated."); 
 
    // generate an index out-of-bounds exception  
    nums[7] = 10;  
    System.out.println("this won't be displayed");  
  } 
}     
 
class UseThrowableMethods {  
  public static void main(String args[]) {  
  
    try {  
      ExcTest.genException(); 
    }  
    catch (ArrayIndexOutOfBoundsException exc) {  
      // catch the exception  
      System.out.println("Standard message is: "); 
      System.out.println(exc); 
      System.out.println("\nStack trace: "); 
      exc.printStackTrace(); 
    }  
    System.out.println("After catch statement.");  
  }  
}

listing 12
// Use finally. 
class UseFinally { 
  public static void genException(int what) { 
    int t; 
    int nums[] = new int[2]; 
 
    System.out.println("Receiving " + what); 
    try { 
      switch(what) { 
        case 0:  
          t = 10 / what; // generate div-by-zero error 
          break; 
        case 1: 
          nums[4] = 4; // generate array index error. 
          break; 
        case 2: 
          return; // return from try block 
      } 
    } 
    catch (ArithmeticException exc) { 
      // catch the exception 
      System.out.println("Can't divide by Zero!"); 
      return; // return from catch 
    } 
    catch (ArrayIndexOutOfBoundsException exc) { 
      // catch the exception 
      System.out.println("No matching element found."); 
    } 
    finally { 
      System.out.println("Leaving try."); 
    } 
  }   
} 
 
class FinallyDemo { 
  public static void main(String args[]) { 
     
    for(int i=0; i < 3; i++) { 
      UseFinally.genException(i); 
      System.out.println(); 
    } 
  } 
}

listing 13
// Use throws. 
class ThrowsDemo {   
  public static char prompt(String str) 
    throws java.io.IOException { 
 
    System.out.print(str + ": "); 
    return (char) System.in.read();  
  }   
 
  public static void main(String args[]) { 
    char ch; 
 
    try { 
      ch = prompt("Enter a letter"); 
    } 
    catch(java.io.IOException exc) { 
      System.out.println("I/O exception occurred."); 
      ch = 'X'; 
    } 
 
    System.out.println("You pressed " + ch); 
  } 
}

listing 14
// Use a custom exception. 
 
// Create an exception. 
class NonIntResultException extends Exception { 
  int n; 
  int d; 
 
  NonIntResultException(int i, int j) { 
    n = i; 
    d = j; 
  } 
 
  public String toString() { 
    return "Result of " + n + " / " + d + 
           " is non-integer."; 
  } 
} 
 
class CustomExceptDemo { 
  public static void main(String args[]) { 
 
    // Here, numer contains some odd values. 
    int numer[] = { 4, 8, 15, 32, 64, 127, 256, 512 }; 
    int denom[] = { 2, 0, 4, 4, 0, 8 }; 
    for(int i=0; i<numer.length; i++) { 
      try { 
        if((numer[i]%2) != 0) 
          throw new  
            NonIntResultException(numer[i], denom[i]); 
 
        System.out.println(numer[i] + " / " + 
                           denom[i] + " is " + 
                           numer[i]/denom[i]); 
      } 
      catch (ArithmeticException exc) { 
        // catch the exception 
        System.out.println("Can't divide by Zero!"); 
      } 
      catch (ArrayIndexOutOfBoundsException exc) { 
        // catch the exception 
        System.out.println("No matching element found."); 
      } 
      catch (NonIntResultException exc) { 
        System.out.println(exc); 
      } 
    } 
  } 
}

listing 15
/*  
    Project 9-1 
 
    Add exception handling to the queue classes. 
*/
 
// An exception for queue-full errors. 
class QueueFullException extends Exception { 
  int size; 
 
  QueueFullException(int s) { size = s; } 
 
  public String toString() { 
   return "\nQueue is full. Maximum size is " + 
          size; 
  } 
} 
 
// An exception for queue-empty errors. 
class QueueEmptyException extends Exception { 
 
  public String toString() { 
   return "\nQueue is empty."; 
  } 
}

listing 16
// A fixed-size queue class for characters that uses exceptions. 
class FixedQueue implements ICharQ {     
  private char q[]; // this array holds the queue     
  private int putloc, getloc; // the put and get indices     
     
  // Construct an empty queue given its size.    
  public FixedQueue(int size) {  
    q = new char[size+1]; // allocate memory for queue     
    putloc = getloc = 0;     
  }     
    
  // Put a characer into the queue.     
  public void put(char ch) 
    throws QueueFullException {     
 
    if(putloc==q.length-1)  
      throw new QueueFullException(q.length-1); 
         
    putloc++;     
    q[putloc] = ch;     
  }     
     
  // Get a character from the queue.    
  public char get() 
    throws QueueEmptyException {     
 
    if(getloc == putloc)  
      throw new QueueEmptyException(); 
       
    getloc++;     
    return q[getloc];     
  }     
}

listing 17
// Demonstrate the queue exceptions.     
class QExcDemo {     
  public static void main(String args[]) {     
    FixedQueue q = new FixedQueue(10);     
    char ch;     
    int i;     
     
    try {  
      // overrun the queue 
      for(i=0; i < 11; i++) { 
        System.out.print("Attempting to store : " + 
                         (char) ('A' + i)); 
        q.put((char) ('A' + i));     
        System.out.println(" -- OK"); 
      } 
      System.out.println(); 
    } 
    catch (QueueFullException exc) { 
      System.out.println(exc); 
    } 
    System.out.println(); 
    
    try { 
      // over-empty the queue 
      for(i=0; i < 11; i++) {      
        System.out.print("Getting next char: "); 
        ch = q.get();     
        System.out.println(ch);     
      } 
    } 
    catch (QueueEmptyException exc) { 
      System.out.println(exc); 
    }  
  }     
}

listing 18
// A character queue interface that throws exceptions.  
public interface ICharQ {     
  // Put a characer into the queue.     
  void put(char ch) throws QueueFullException;  
  
  // Get a character from the queue.    
  char get() throws QueueEmptyException;  
}

 
listing 1
// Read an array of bytes from the keyboard. 
 
import java.io.*; 
 
class ReadBytes { 
  public static void main(String args[]) 
    throws IOException { 
      byte data[] = new byte[10]; 
 
      System.out.println("Enter some characters."); 
      System.in.read(data); 
      System.out.print("You entered: "); 
      for(int i=0; i < data.length; i++) 
        System.out.print((char) data[i]); 
  } 
}

listing 2
// Demonstrate System.out.write(). 
class WriteDemo { 
  public static void main(String args[]) { 
    int b; 
 
    b = 'X'; 
    System.out.write(b); 
    System.out.write('\n'); 
  } 
}

listing 3
/* Display a text file. 
 
   To use this program, specify the name  
   of the file that you want to see. 
   For example, to see a file called TEST.TXT, 
   use the following command line. 
 
   java ShowFile TEST.TXT 
*/ 
 
import java.io.*; 
 
class ShowFile { 
  public static void main(String args[])  
  { 
    int i; 
    FileInputStream fin; 
 
    // First make sure that a file has been specified.
    if(args.length != 1) {
      System.out.println("Usage: ShowFile File"); 
      return;
    }

    try { 
      fin = new FileInputStream(args[0]); 
    } catch(FileNotFoundException exc) { 
      System.out.println("File Not Found"); 
      return; 
    }

    try { 
      // read bytes until EOF is encountered 
      do { 
        i = fin.read(); 
        if(i != -1) System.out.print((char) i); 
      } while(i != -1); 
    } catch(IOException exc) {
      System.out.println("Error reading file.");
    }

    try {
      fin.close(); 
    } catch(IOException exc) {
      System.out.println("Error closing file.");
    }

  } 
}

listing 4
/* Copy a text file. 
 
   To use this program, specify the name  
   of the source file and the destination file. 
   For example, to copy a file called FIRST.TXT 
   to a file called SECOND.TXT, use the following 
   command line. 
 
   java CopyFile FIRST.TXT SECOND.TXT 
*/ 
 
import java.io.*; 
 
class CopyFile { 
  public static void main(String args[])  
  { 
    int i; 
    FileInputStream fin; 
    FileOutputStream fout; 

    // First make sure that both files have been specified.
    if(args.length !=2 ) {
      System.out.println("Usage: CopyFile From To"); 
      return;
    }
 
    // open input file 
    try { 
      fin = new FileInputStream(args[0]); 
    } catch(FileNotFoundException exc) { 
      System.out.println("Input File Not Found"); 
      return; 
    } 
 
    // open output file 
    try { 
      fout = new FileOutputStream(args[1]); 
    } catch(FileNotFoundException exc) { 
      System.out.println("Error Opening Output File"); 

      // Close the open input file.
      try {
        fin.close();
      } catch(IOException exc2) { 
        System.out.println("Error closing input file."); 
      } 
      return; 
    } 

    // Copy File 
    try { 
      do { 
        i = fin.read(); 
        if(i != -1) fout.write(i); 
      } while(i != -1); 
    } catch(IOException exc) { 
      System.out.println("File Error"); 
    } 
 
    try {
      fin.close(); 
    } catch(IOException exc) { 
      System.out.println("Error closing input file."); 
    } 

    try {
      fout.close(); 
    } catch(IOException exc) { 
      System.out.println("Error closing output file."); 
    } 

  } 
}

listing 5
// Write and then read back binary data. 
import java.io.*; 
 
class RWData { 
  public static void main(String args[]) 
  { 
     
    DataOutputStream dataOut; 
    DataInputStream dataIn; 
 
    int i = 10; 
    double d = 1023.56; 
    boolean b = true; 
 
    try { 
      dataOut = new 
        DataOutputStream(new FileOutputStream("testdata")); 
    } 
    catch(IOException exc) { 
      System.out.println("Cannot open output file."); 
      return; 
    } 
 
    try { 
      System.out.println("Writing " + i); 
      dataOut.writeInt(i);  
 
      System.out.println("Writing " + d); 
      dataOut.writeDouble(d); 
 
      System.out.println("Writing " + b); 
      dataOut.writeBoolean(b); 
 
      System.out.println("Writing " + 12.2 * 7.4); 
      dataOut.writeDouble(12.2 * 7.4); 
 
    } 
    catch(IOException exc) { 
      System.out.println("Write error."); 
    } 
 
    try {
      dataOut.close(); 
    } catch(IOException exc) { 
      System.out.println("Error closing output file."); 
      return;
    } 
 
    System.out.println(); 
 
    // Now, read them back. 
    try { 
      dataIn = new 
        DataInputStream(new FileInputStream("testdata")); 
    } 
    catch(IOException exc) { 
      System.out.println("Cannot open input file."); 
      return; 
    } 
 
    try { 
      i = dataIn.readInt(); 
      System.out.println("Reading " + i); 
 
      d = dataIn.readDouble(); 
      System.out.println("Reading " + d); 
 
      b = dataIn.readBoolean(); 
      System.out.println("Reading " + b); 
 
      d = dataIn.readDouble(); 
      System.out.println("Reading " + d); 
    } 
    catch(IOException exc) { 
      System.out.println("Read error."); 
    } 
 
    try {
      dataIn.close();  
    } catch(IOException exc) { 
      System.out.println("Error closing input file."); 
    } 

  } 
}

listing 6
/*   
   Project 10-1 
 
   Compare two files. 
 
   To use this program, specify the names   
   of the files to be compared on the command line. 
  
   java CompFile FIRST.TXT SECOND.TXT  
*/  
  
import java.io.*;  
  
class CompFiles {  
  public static void main(String args[])   
  {  
    int i=0, j=0;  
    FileInputStream f1;  
    FileInputStream f2;  
  
    // First make sure that both files have been specified.
    if(args.length !=2 ) {
      System.out.println("Usage: CompFile f1 f2");  
      return;
    }

    // open first file
    try {  
      f1 = new FileInputStream(args[0]);  
    } catch(FileNotFoundException exc) {  
      System.out.println(args[0] + " File Not Found");  
      return;  
    }  
  
    // open second file  
    try {  
      f2 = new FileInputStream(args[1]);  
    } catch(FileNotFoundException exc) {  
      System.out.println(args[1] + " File Not Found");  

      // Close the first file if the second file
      // cannot be opened.
      try {
        f1.close();
      } catch(IOException exc2) { 
        System.out.println("Cannot close " + args[0]); 
      } 
      return;  
    }  
  
    // Compare files.
    try {  
      do {  
        i = f1.read();  
        j = f2.read();  
        if(i != j) break; 
      } while(i != -1 && j != -1);  

      if(i != j)  
        System.out.println("Files differ."); 
      else 
        System.out.println("Files are the same."); 
    } catch(IOException exc) {  
      System.out.println("File Error");  
    }  

    try {
      f1.close();  
    } catch(IOException exc) { 
      System.out.println("Error closing " + args[0]); 
    } 

    try {
      f2.close();  
    } catch(IOException exc) { 
      System.out.println("Error closing " + args[1]); 
    } 

  }  
}

listing 7
// Demonstrate random access files. 
import java.io.*; 
 
class RandomAccessDemo { 
  public static void main(String args[]) 
  { 
 
    double data[] = { 19.4, 10.1, 123.54, 33.0, 87.9, 74.25 }; 
    double d; 
    RandomAccessFile raf; 
 
    try { 
      raf = new RandomAccessFile("random.dat", "rw"); 
    } 
    catch(FileNotFoundException exc) { 
      System.out.println("Cannot open file."); 
      return ; 
    } 
 
    try { 
      // Write values to the file.      
      for(int i=0; i < data.length; i++) { 
        raf.writeDouble(data[i]); 
      }  

      // Now, read back specific values 
      raf.seek(0); // seek to first double 
      d = raf.readDouble(); 
      System.out.println("First value is " + d); 
 
      raf.seek(8); // seek to second double 
      d = raf.readDouble(); 
      System.out.println("Second value is " + d); 
 
      raf.seek(8 * 3); // seek to fourth double 
      d = raf.readDouble(); 
      System.out.println("Fourth value is " + d); 
 
      System.out.println(); 
 
      // Now, read every other value. 
      System.out.println("Here is every other value: "); 
      for(int i=0; i < data.length; i+=2) { 
        raf.seek(8 * i); // seek to ith double 
        d = raf.readDouble(); 
        System.out.print(d + " "); 
      } 
    }  
    catch(IOException exc) { 
      System.out.println("File error."); 
    } 
  
    try {
      raf.close(); 
    } catch(IOException exc) {
      System.out.println("Error closing file.");
    }
  } 
}

listing 8
// Use a BufferedReader to read characters from the console. 
import java.io.*; 
 
class ReadChars { 
  public static void main(String args[])  
    throws IOException 
  { 
    char c; 
    BufferedReader br = new 
            BufferedReader(new InputStreamReader(System.in)); 
 
    System.out.println("Enter characters, period to quit."); 
 
    // read characters 
    do { 
      c = (char) br.read(); 
      System.out.println(c); 
    } while(c != '.'); 
  } 
}

listing 9
// Read a string from console using a BufferedReader. 
import java.io.*; 
 
class ReadLines { 
  public static void main(String args[])  
    throws IOException 
  { 
    // create a BufferedReader using System.in 
    BufferedReader br = new BufferedReader(new 
                            InputStreamReader(System.in)); 
    String str; 
 
    System.out.println("Enter lines of text."); 
    System.out.println("Enter 'stop' to quit."); 
    do { 
      str = br.readLine(); 
      System.out.println(str); 
    } while(!str.equals("stop")); 
  } 
}

listing 10
// Demonstrate PrintWriter. 
import java.io.*; 
 
public class PrintWriterDemo { 
  public static void main(String args[]) { 
    PrintWriter pw = new PrintWriter(System.out, true); 
    int i = 10; 
    double d = 123.65; 
 
    pw.println("Using a PrintWriter."); 
    pw.println(i); 
    pw.println(d); 
 
    pw.println(i + " + " + d + " is " + (i+d)); 
  } 
}

listing 11
/* A simple key-to-disk utilitiy that 
   demonstrates a FileWriter. */ 
 
import java.io.*; 
 
class KtoD { 
  public static void main(String args[])  
  { 
 
    String str; 
    FileWriter fw; 
    BufferedReader br = 
            new BufferedReader( 
                  new InputStreamReader(System.in)); 
 
    try { 
      fw = new FileWriter("test.txt"); 
    } 
    catch(IOException exc) { 
      System.out.println("Cannot open file."); 
      return ; 
    } 
 
    System.out.println("Enter text ('stop' to quit)."); 

    try {
      do { 
        System.out.print(": "); 
        str = br.readLine(); 
 
        if(str.compareTo("stop") == 0) break;  
 
        str = str + "\r\n"; // add newline 
        fw.write(str); 
       } while(str.compareTo("stop") != 0); 
    } catch(IOException exc) {
      System.out.println("Error writing to file.");
    }

    try {
      fw.close(); 
    } catch(IOException exc) {
      System.out.println("Error closing file.");
    }

  } 
}

listing 12
/* A simple disk-to-screen utilitiy that 
   demonstrates a FileReader. */ 
 
import java.io.*; 
 
class DtoS { 
  public static void main(String args[]) {
    String s; 
    FileReader fr;
    BufferedReader br;

    try { 
      fr = new FileReader("test.txt"); 
      br = new BufferedReader(fr); 
    } catch(FileNotFoundException exc) {
      System.out.println("Cannot open input file.");
      return;
    }
 
    try {
      while((s = br.readLine()) != null) { 
        System.out.println(s); 
      }
    } catch(IOException exc) {
      System.out.println("Error reading file.");
    }

    try { 
      fr.close(); 
    } catch(IOException exc) {
      System.out.println("Error closing file.");
    }

  } 
}

listing 13
/* This program averages a list of numbers entered  
   by the user.  */  
  
import java.io.*;  
  
class AvgNums {  
  public static void main(String args[])   
    throws IOException  
  {  
    // create a BufferedReader using System.in  
    BufferedReader br = new  
      BufferedReader(new InputStreamReader(System.in));  
    String str;  
    int n;  
    double sum = 0.0; 
    double avg, t;  
      
    System.out.print("How many numbers will you enter: ");  
    str = br.readLine(); 
    try { 
      n = Integer.parseInt(str); 
    }  
    catch(NumberFormatException exc) { 
      System.out.println("Invalid format"); 
      n = 0; 
    } 
    
    System.out.println("Enter " + n + " values."); 
    for(int i=0; i < n ; i++)  {  
      System.out.print(": "); 
      str = br.readLine();  
      try {  
        t = Double.parseDouble(str);  
      } catch(NumberFormatException exc) {  
        System.out.println("Invalid format");  
        t = 0.0;  
      }  
      sum += t;  
    }  
    avg = sum / n; 
    System.out.println("Average is " + avg); 
  }  
}

listing 14
#if
if(condition) statement;
else statement;
 
#switch
switch(expression) {
  case constant:
    statement sequence
    break;
    // ...
  }   

#for
for(init; condition; iteration) statement;

#while
while(condition) statement;

#do
do {
  statement;
} while (condition);

#break
break; or break label;

#continue
continue; or continue label;

listing 15
/*   
   Project 10-2   
   
   A help program that uses a disk file 
   to store help information. 
*/   
 
import java.io.*; 
 
/* The Help class opens a help file, 
   searches for an topic, and then displays 
   the information associated with that topic. 
   Notice that it handles all I/O exceptions 
   itself, avoiding the need for calling  
   code to do so. */  
class Help { 
  String helpfile; // name of help file 
 
  Help(String fname) { 
    helpfile = fname; 
  } 
 
  // Display help on a topic. 
  boolean helpon(String what) {  
    FileReader fr; 
    BufferedReader helpRdr; 
    int ch; 
    String topic, info; 
 
    try { 
      fr = new FileReader(helpfile); 
      helpRdr = new BufferedReader(fr); 
    } 
    catch(FileNotFoundException exc) { 
      System.out.println("Help file not found."); 
      return false; 
    } 
 
    try { 
      do { 
        // read characters until a # is found 
        ch = helpRdr.read(); 
 
        // now, see if topics match 
        if(ch == '#') { 
          topic = helpRdr.readLine(); 
          if(what.compareTo(topic) == 0) { // found topic 
            do { 
              info = helpRdr.readLine(); 
              if(info != null) System.out.println(info); 
            } while((info != null) && 
                    (info.compareTo("") != 0)); 
            return true; 
          } 
        } 
      } while(ch != -1); 
    } 
    catch(IOException exc) { 
      System.out.println("File error."); 
      try { 
        helpRdr.close(); 
      }  
      catch(IOException exc2) { 
        System.out.println("Error closing file."); 
      } 
      return false; 
    } 
    try { 
      helpRdr.close(); 
    }  
    catch(IOException exc) { 
      System.out.println("Error closing file."); 
    } 
    return false; // topic not found 
  }  
  
  // Get a Help topic. 
  String getSelection() {  
    String topic = ""; 
 
    BufferedReader br = new BufferedReader( 
              new InputStreamReader(System.in)); 
 
    System.out.print("Enter topic: ");   
    try {   
      topic = br.readLine(); 
    } 
    catch(IOException exc) { 
      System.out.println("Error reading console."); 
    } 
    return topic; 
  } 
}  
  
// Demonstrate the file-based Help system. 
class FileHelp {   
  public static void main(String args[]) {   
    Help hlpobj = new Help("helpfile.txt");  
    String topic; 
 
    System.out.println("Try the help system. " + 
                       "Enter 'stop' to end.");  
    do {  
      topic = hlpobj.getSelection();   
 
      if(!hlpobj.helpon(topic)) 
        System.out.println("Topic not found.\n"); 
 
    } while(topic.compareTo("stop") != 0); 
  }  
}

 
listing 1
// Create a thread by implementing Runnable. 
 
class MyThread implements Runnable { 
  int count; 
  String thrdName; 
 
  MyThread(String name) { 
    count = 0; 
    thrdName = name; 
  } 
 
  // Entry point of thread. 
  public void run() { 
    System.out.println(thrdName + " starting."); 
    try {  
      do { 
        Thread.sleep(500); 
        System.out.println("In " + thrdName + 
                           ", count is " + count); 
        count++; 
      } while(count < 10); 
    } 
    catch(InterruptedException exc) { 
      System.out.println(thrdName + " interrupted."); 
    } 
    System.out.println(thrdName + " terminating."); 
  } 
} 
 
class UseThreads { 
  public static void main(String args[]) { 
    System.out.println("Main thread starting."); 
 
    // First, construct a MyThread object. 
    MyThread mt = new MyThread("Child #1"); 
 
    // Next, construct a thread from that object. 
    Thread newThrd = new Thread(mt); 
 
    // Finally, start execution of the thread. 
    newThrd.start(); 
 
    do { 
      System.out.print("."); 
      try { 
        Thread.sleep(100); 
      } 
      catch(InterruptedException exc) { 
        System.out.println("Main thread interrupted."); 
      } 
    } while (mt.count != 10); 
 
    System.out.println("Main thread ending."); 
  } 
} 



listing 2
// Improved MyThread.  
 
class MyThread implements Runnable { 
  int count; 
  Thread thrd; 
 
  // Construct a new thread. 
  MyThread(String name) { 
    thrd = new Thread(this, name); 
    count = 0; 
    thrd.start(); // start the thread 
  } 
 
  // Begin execution of new thread. 
  public void run() { 
    System.out.println(thrd.getName() + " starting."); 
    try {  
      do { 
        Thread.sleep(500); 
        System.out.println("In " + thrd.getName() + 
                           ", count is " + count); 
        count++; 
      } while(count < 10); 
    } 
    catch(InterruptedException exc) { 
      System.out.println(thrd.getName() + " interrupted."); 
    } 
    System.out.println(thrd.getName() + " terminating."); 
  } 
} 
 
class UseThreadsImproved { 
  public static void main(String args[]) { 
    System.out.println("Main thread starting."); 
 
    MyThread mt = new MyThread("Child #1"); 
 
    do { 
      System.out.print("."); 
      try { 
        Thread.sleep(100); 
      } 
      catch(InterruptedException exc) { 
        System.out.println("Main thread interrupted."); 
      } 
    } while (mt.count != 10); 
 
    System.out.println("Main thread ending."); 
  } 
}

listing 3
/*  
   Project 11-1 
 
   Extend Thread. 
*/ 
class MyThread extends Thread { 
  int count; 
 
  // Construct a new thread. 
  MyThread(String name) { 
    super(name); // name thread 
    count = 0; 
    start(); // start the thread 
  } 
 
  // Begin execution of new thread. 
  public void run() { 
    System.out.println(getName() + " starting."); 
    try {  
      do { 
        Thread.sleep(500); 
        System.out.println("In " + getName() + 
                           ", count is " + count); 
        count++; 
      } while(count < 10); 
    } 
    catch(InterruptedException exc) { 
      System.out.println(getName() + " interrupted."); 
    } 
    System.out.println(getName() + " terminating."); 
  } 
} 
 
class ExtendThread { 
  public static void main(String args[]) { 
    System.out.println("Main thread starting."); 
 
    MyThread mt = new MyThread("Child #1"); 
 
    do { 
      System.out.print("."); 
      try { 
        Thread.sleep(100); 
      } 
      catch(InterruptedException exc) { 
        System.out.println("Main thread interrupted."); 
      } 
    } while (mt.count != 10); 
 
    System.out.println("Main thread ending."); 
  } 
} 


listing 4
// Create multiple threads. 
 
class MyThread implements Runnable { 
  int count; 
  Thread thrd; 
 
  // Construct a new thread. 
  MyThread(String name) { 
    thrd = new Thread(this, name); 
    count = 0; 
    thrd.start(); // start the thread 
  } 
 
  // Begin execution of new thread. 
  public void run() { 
    System.out.println(thrd.getName() + " starting."); 
    try {  
      do { 
        Thread.sleep(500); 
        System.out.println("In " + thrd.getName() + 
                           ", count is " + count); 
        count++; 
      } while(count < 10); 
    } 
    catch(InterruptedException exc) { 
      System.out.println(thrd.getName() + " interrupted."); 
    } 
    System.out.println(thrd.getName() + " terminating."); 
  } 
} 
 
class MoreThreads { 
  public static void main(String args[]) { 
    System.out.println("Main thread starting."); 
 
    MyThread mt1 = new MyThread("Child #1"); 
    MyThread mt2 = new MyThread("Child #2"); 
    MyThread mt3 = new MyThread("Child #3"); 
 
    do { 
      System.out.print("."); 
      try { 
        Thread.sleep(100); 
      } 
      catch(InterruptedException exc) { 
        System.out.println("Main thread interrupted."); 
      } 
    } while (mt1.count < 10 || 
             mt2.count < 10 || 
             mt3.count < 10); 
 
    System.out.println("Main thread ending."); 
  } 
} 


listing 5
// Use isAlive(). 
class MoreThreads { 
  public static void main(String args[]) { 
    System.out.println("Main thread starting."); 
 
    MyThread mt1 = new MyThread("Child #1"); 
    MyThread mt2 = new MyThread("Child #2"); 
    MyThread mt3 = new MyThread("Child #3"); 
 
    do { 
      System.out.print("."); 
      try { 
        Thread.sleep(100); 
      } 
      catch(InterruptedException exc) { 
        System.out.println("Main thread interrupted."); 
      } 
    } while (mt1.thrd.isAlive() || 
             mt2.thrd.isAlive() || 
             mt3.thrd.isAlive()); 
 
    System.out.println("Main thread ending."); 
  } 
}

listing 6
// Use join(). 
 
class MyThread implements Runnable { 
  int count; 
  Thread thrd; 
 
  // Construct a new thread. 
  MyThread(String name) { 
    thrd = new Thread(this, name); 
    count = 0; 
    thrd.start(); // start the thread 
  } 
 
  // Begin execution of new thread. 
  public void run() { 
    System.out.println(thrd.getName() + " starting."); 
    try {  
      do { 
        Thread.sleep(500); 
        System.out.println("In " + thrd.getName() + 
                           ", count is " + count); 
        count++; 
      } while(count < 10); 
    } 
    catch(InterruptedException exc) { 
      System.out.println(thrd.getName() + " interrupted."); 
    } 
    System.out.println(thrd.getName() + " terminating."); 
  } 
} 
 
class JoinThreads { 
  public static void main(String args[]) { 
    System.out.println("Main thread starting."); 
 
    MyThread mt1 = new MyThread("Child #1"); 
    MyThread mt2 = new MyThread("Child #2"); 
    MyThread mt3 = new MyThread("Child #3"); 
 
    try { 
      mt1.thrd.join(); 
      System.out.println("Child #1 joined."); 
      mt2.thrd.join(); 
      System.out.println("Child #2 joined."); 
      mt3.thrd.join(); 
      System.out.println("Child #3 joined."); 
    } 
    catch(InterruptedException exc) { 
      System.out.println("Main thread interrupted."); 
    } 
 
    System.out.println("Main thread ending."); 
  } 
}

listing 7
// Demonstrate thread priorities. 
 
class Priority implements Runnable { 
  int count; 
  Thread thrd; 
 
  static boolean stop = false; 
  static String currentName; 
 
  /* Construct a new thread. Notice that this  
     constructor does not actually start the 
     threads running. */ 
  Priority(String name) { 
    thrd = new Thread(this, name); 
    count = 0; 
    currentName = name; 
  } 
 
  // Begin execution of new thread. 
  public void run() { 
    System.out.println(thrd.getName() + " starting."); 
    do { 
      count++; 
 
      if(currentName.compareTo(thrd.getName()) != 0) { 
        currentName = thrd.getName(); 
        System.out.println("In " + currentName); 
      } 
 
    } while(stop == false && count < 10000000); 
    stop = true; 
 
    System.out.println("\n" + thrd.getName() + 
                       " terminating."); 
  } 
} 
 
class PriorityDemo { 
  public static void main(String args[]) { 
    Priority mt1 = new Priority("High Priority"); 
    Priority mt2 = new Priority("Low Priority"); 
 
    // set the priorities 
    mt1.thrd.setPriority(Thread.NORM_PRIORITY+2); 
    mt2.thrd.setPriority(Thread.NORM_PRIORITY-2); 
 
    // start the threads 
    mt1.thrd.start(); 
    mt2.thrd.start(); 
 
    try { 
      mt1.thrd.join(); 
      mt2.thrd.join(); 
    } 
    catch(InterruptedException exc) { 
      System.out.println("Main thread interrupted."); 
    } 
 
    System.out.println("\nHigh priority thread counted to " + 
                       mt1.count); 
    System.out.println("Low priority thread counted to " + 
                       mt2.count); 
  } 
}

listing 8
// Use synchronize to control access. 
 
class SumArray { 
  private int sum; 
 
  synchronized int sumArray(int nums[]) { 
    sum = 0; // reset sum 
 
    for(int i=0; i<nums.length; i++) { 
      sum += nums[i]; 
      System.out.println("Running total for " + 
             Thread.currentThread().getName() + 
             " is " + sum); 
      try { 
        Thread.sleep(10); // allow task-switch 
      } 
      catch(InterruptedException exc) { 
        System.out.println("Main thread interrupted."); 
      } 
    } 
    return sum; 
  } 
}  
 
class MyThread implements Runnable { 
  Thread thrd; 
  static SumArray sa = new SumArray(); 
  int a[]; 
  int answer; 
 
  // Construct a new thread. 
  MyThread(String name, int nums[]) { 
    thrd = new Thread(this, name); 
    a = nums; 
    thrd.start(); // start the thread 
  } 
 
  // Begin execution of new thread. 
  public void run() { 
    int sum; 
 
    System.out.println(thrd.getName() + " starting."); 
 
    answer = sa.sumArray(a);          
    System.out.println("Sum for " + thrd.getName() + 
                       " is " + answer); 
 
    System.out.println(thrd.getName() + " terminating."); 
  } 
} 
 
class Sync { 
  public static void main(String args[]) { 
    int a[] = {1, 2, 3, 4, 5}; 
 
    MyThread mt1 = new MyThread("Child #1", a); 
    MyThread mt2 = new MyThread("Child #2", a); 
  } 
} 


listing 9
// Use a synchronized block to control access to SumArray.  
class SumArray {  
  private int sum;  
  
  int sumArray(int nums[]) {  
    sum = 0; // reset sum  
  
    for(int i=0; i<nums.length; i++) {  
      sum += nums[i];  
      System.out.println("Running total for " +  
             Thread.currentThread().getName() +  
             " is " + sum);  
      try {  
        Thread.sleep(10); // allow task-switch  
      }  
      catch(InterruptedException exc) {  
        System.out.println("Main thread interrupted.");  
      }  
    }  
    return sum; 
  }  
}   
  
class MyThread implements Runnable {  
  Thread thrd;  
  static SumArray sa = new SumArray();  
  int a[];  
  int answer; 
 
  // Construct a new thread.  
  MyThread(String name, int nums[]) {  
    thrd = new Thread(this, name);  
    a = nums;  
    thrd.start(); // start the thread  
  }  
  
  // Begin execution of new thread.  
  public void run() {  
    int sum;  
  
    System.out.println(thrd.getName() + " starting.");  
  
    // synchronize calls to sumArray()  
    synchronized(sa) {  
      answer = sa.sumArray(a);           
    }  
    System.out.println("Sum for " + thrd.getName() +  
                       " is " + answer);  
  
    System.out.println(thrd.getName() + " terminating.");  
  }  
}  
  
class Sync {  
  public static void main(String args[]) {  
    int a[] = {1, 2, 3, 4, 5};  
  
    MyThread mt1 = new MyThread("Child #1", a);  
    MyThread mt2 = new MyThread("Child #2", a);  
  
    try {  
      mt1.thrd.join();  
      mt2.thrd.join();  
    } catch(InterruptedException exc) {  
      System.out.println("Main thread interrupted.");  
    }  
  }  
} 


listing 10
// Use wait() and notify() to create a ticking clock. 
 
class TickTock { 

  String state; // contains the state of the clock
 
  synchronized void tick(boolean running) { 
    if(!running) { // stop the clock 
      state = "ticked";
      notify(); // notify any waiting threads 
      return; 
    } 
 
    System.out.print("Tick "); 

    state = "ticked"; // set the current state to ticked

    notify(); // let tock() run 
    try { 
      while(!state.equals("tocked"))
        wait(); // wait for tock() to complete 
    } 
    catch(InterruptedException exc) { 
      System.out.println("Thread interrupted."); 
    } 
  } 
 
  synchronized void tock(boolean running) { 
    if(!running) { // stop the clock 
      state = "tocked";
      notify(); // notify any waiting threads 
      return; 
    } 
 
    System.out.println("Tock"); 

    state = "tocked"; // set the current state to tocked

    notify(); // let tick() run 
    try { 
      while(!state.equals("ticked"))
        wait(); // wait for tick to complete 
    } 
    catch(InterruptedException exc) { 
      System.out.println("Thread interrupted."); 
    } 
  } 
}  
 
class MyThread implements Runnable { 
  Thread thrd; 
  TickTock ttOb; 
 
  // Construct a new thread. 
  MyThread(String name, TickTock tt) { 
    thrd = new Thread(this, name); 
    ttOb = tt; 
    thrd.start(); // start the thread 
  } 
 
  // Begin execution of new thread. 
  public void run() { 
 
    if(thrd.getName().compareTo("Tick") == 0) { 
      for(int i=0; i<5; i++) ttOb.tick(true); 
      ttOb.tick(false); 
    } 
    else { 
      for(int i=0; i<5; i++) ttOb.tock(true); 
      ttOb.tock(false); 
    } 
  } 
} 
 
class ThreadCom { 
  public static void main(String args[]) { 
    TickTock tt = new TickTock(); 
    MyThread mt1 = new MyThread("Tick", tt); 
    MyThread mt2 = new MyThread("Tock", tt); 
 
    try { 
      mt1.thrd.join(); 
      mt2.thrd.join(); 
    } catch(InterruptedException exc) { 
      System.out.println("Main thread interrupted."); 
    } 
  } 
}

listing 11
// No calls to wait() or notify(). 
class TickTock { 

  String state; // contains the state of the clock
 
  synchronized void tick(boolean running) { 
    if(!running) { // stop the clock 
      state = "ticked";
      return; 
    } 
 
    System.out.print("Tick "); 

    state = "ticked"; // set the current state to ticked
  } 
 
  synchronized void tock(boolean running) { 
    if(!running) { // stop the clock 
      state = "tocked";
      return; 
    } 
 
    System.out.println("Tock"); 

    state = "tocked"; // set the current state to tocked
  } 
}  

listing 12
// Suspending, resuming, and stopping a thread. 
 
class MyThread implements Runnable {  
  Thread thrd;  
  volatile boolean suspended;  
  volatile boolean stopped; 
    
  MyThread(String name) {  
    thrd = new Thread(this, name);  
    suspended = false;  
    stopped = false; 
    thrd.start();  
  }  
  
  // This is the entry point for thread.  
  public void run() {  
    System.out.println(thrd.getName() + " starting."); 
    try {  
      for(int i = 1; i < 1000; i++) {  
        System.out.print(i + " ");  
        if((i%10)==0) { 
          System.out.println(); 
          Thread.sleep(250); 
        } 
 
        // Use synchronized block to check suspended and stopped. 
        synchronized(this) {  
          while(suspended) {  
            wait();  
          }  
          if(stopped) break; 
        }  
      }  
    } catch (InterruptedException exc) {  
      System.out.println(thrd.getName() + " interrupted.");  
    }  
    System.out.println(thrd.getName() + " exiting.");  
  }  
 
  // Stop the thread.  
  synchronized void mystop() {  
    stopped = true;  
 
   // The following lets a suspended thread be stopped. 
    suspended = false; 
    notify(); 
  }  
 
  // Suspend the thread. 
  synchronized void mysuspend() {  
    suspended = true;  
  }  
 
  // Resume the thread.  
  synchronized void myresume() {  
    suspended = false;  
    notify();  
  }  
}  
  
class Suspend {  
  public static void main(String args[]) {  
    MyThread ob1 = new MyThread("My Thread");  
 
    try {  
      Thread.sleep(1000); // let ob1 thread start executing 
  
      ob1.mysuspend();  
      System.out.println("Suspending thread.");  
      Thread.sleep(1000); 
 
      ob1.myresume();  
      System.out.println("Resuming thread.");  
      Thread.sleep(1000); 
 
 
      ob1.mysuspend();  
      System.out.println("Suspending thread.");  
      Thread.sleep(1000); 
 
      ob1.myresume();  
      System.out.println("Resuming thread.");  
      Thread.sleep(1000); 
 
      ob1.mysuspend();  
      System.out.println("Stopping thread."); 
      ob1.mystop(); 
    } catch (InterruptedException e) {  
      System.out.println("Main thread Interrupted");  
    }  
  
    // wait for thread to finish  
    try {  
      ob1.thrd.join();  
    } catch (InterruptedException e) {  
      System.out.println("Main thread Interrupted");  
    }  
   
    System.out.println("Main thread exiting.");  
  }  
}

listing 13
/* 
   Project 11-2 
  
   Controlling the main thread. 
*/ 
 
class UseMain { 
  public static void main(String args[]) { 
    Thread thrd; 
 
    // Get the main thread. 
    thrd = Thread.currentThread(); 
 
    // Display main thread's name. 
    System.out.println("Main thread is called: " + 
                       thrd.getName()); 
 
    // Display main thread's priority. 
    System.out.println("Priority: " + 
                       thrd.getPriority()); 
 
    System.out.println(); 
 
    // Set the name and priority. 
    System.out.println("Setting name and priority.\n"); 
    thrd.setName("Thread #1"); 
    thrd.setPriority(Thread.NORM_PRIORITY+3); 
 
    System.out.println("Main thread is now called: " + 
                       thrd.getName()); 
 
    System.out.println("Priority is now: " + 
                       thrd.getPriority()); 
  } 
}

 
listing 1
// An enumeration of Transport varieties. 
enum Transport {  
  CAR, TRUCK, AIRPLANE, TRAIN, BOAT 
} 
 
class EnumDemo { 
  public static void main(String args[])  
  { 
    Transport tp; 
 
    tp = Transport.AIRPLANE; 
 
    // Output an enum value. 
    System.out.println("Value of tp: " + tp); 
    System.out.println(); 
 
    tp = Transport.TRAIN; 
 
    // Compare two enum values. 
    if(tp == Transport.TRAIN)  
      System.out.println("tp contains TRAIN.\n"); 
 
    // Use an enum to control a switch statement. 
    switch(tp) { 
      case CAR: 
        System.out.println("A car carries people."); 
        break; 
      case TRUCK: 
        System.out.println("A truck carries freight."); 
        break; 
      case AIRPLANE:  
        System.out.println("An airplane flies."); 
        break; 
      case TRAIN: 
        System.out.println("A train runs on rails."); 
        break; 
      case BOAT: 
        System.out.println("A boat sails on water."); 
        break; 
    } 
  } 
}

listing 2
// Use the built-in enumeration methods. 
 
// An enumeration of Transport varieties. 
enum Transport {  
  CAR, TRUCK, AIRPLANE, TRAIN, BOAT 
} 
 
class EnumDemo2 { 
  public static void main(String args[])  
  { 
    Transport tp; 
 
    System.out.println("Here are all Transport constants"); 
 
    // use values() 
    Transport allTransports[] = Transport.values(); 
    for(Transport t : allTransports) 
      System.out.println(t); 
 
    System.out.println(); 
    
    // use valueOf() 
    tp = Transport.valueOf("AIRPLANE"); 
    System.out.println("tp contains " + tp); 
 
  } 
}

listing 3
// Use an enum constructor, instance variable, and method.  
enum Transport {  
  CAR(65), TRUCK(55), AIRPLANE(600), TRAIN(70), BOAT(22);  
  
  private int speed; // typical speed of each transport   
  
  // Constructor  
  Transport(int s) { speed = s; }  
  
  int getSpeed() { return speed; }  
}  
  
class EnumDemo3 {  
  public static void main(String args[])   
  {  
    Transport tp;  
  
    // Display speed of an airplane.  
    System.out.println("Typical speed for an airplane is " +  
                       Transport.AIRPLANE.getSpeed() +  
                       " miles per hour.\n");  
  
    // Display all Transports and speeds.  
    System.out.println("All Transport speeds: ");  
    for(Transport t : Transport.values())  
      System.out.println(t + " typical speed is " + 
                         t.getSpeed() +  
                         " miles per hour.");  
  }  
}

listing 4
// Demonstrate ordinal() and compareTo(). 
 
// An enumeration of Transport varieties. 
enum Transport {  
  CAR, TRUCK, AIRPLANE, TRAIN, BOAT 
} 
 
class EnumDemo4 { 
  public static void main(String args[])  
  { 
    Transport tp, tp2, tp3; 
 
    // Obtain all ordinal values using ordinal(). 
    System.out.println("Here are all Transport constants" + 
                       " and their ordinal values: "); 
    for(Transport t : Transport.values()) 
      System.out.println(t + " " + t.ordinal()); 
 
    tp =  Transport.AIRPLANE; 
    tp2 = Transport.TRAIN; 
    tp3 = Transport.AIRPLANE; 
 
    System.out.println(); 
 
    // Demonstrate compareTo() 
    if(tp.compareTo(tp2) < 0) 
      System.out.println(tp + " comes before " + tp2); 
 
    if(tp.compareTo(tp2) > 0) 
      System.out.println(tp2 + " comes before " + tp); 
 
    if(tp.compareTo(tp3) == 0) 
      System.out.println(tp + " equals " + tp3); 
  } 
}

listing 5
// A simulation of a traffic light that uses 
// an enumeration to describe the light's color. 
 
// An enumeration of the colors of a traffic light. 
enum TrafficLightColor {  
  RED, GREEN, YELLOW 
} 
 
// A computerized traffic light. 
class TrafficLightSimulator implements Runnable { 
  private Thread thrd; // holds the thread that runs the simulation 
  private TrafficLightColor tlc; // holds the current traffic light color 
  boolean stop = false; // set to true to stop the simulation 
  boolean changed = false; // true when the light has changed
 
  TrafficLightSimulator(TrafficLightColor init) {  
    tlc = init; 
 
    thrd = new Thread(this); 
    thrd.start(); 
  } 
 
  TrafficLightSimulator() {  
    tlc = TrafficLightColor.RED; 
 
    thrd = new Thread(this); 
    thrd.start(); 
  } 
 
  // Start up the light. 
  public void run() { 
    while(!stop) { 
 
      try { 
        switch(tlc) { 
          case GREEN: 
            Thread.sleep(10000); // green for 10 seconds 
            break; 
          case YELLOW: 
            Thread.sleep(2000);  // yellow for 2 seconds 
            break; 
          case RED: 
            Thread.sleep(12000); // red for 12 seconds 
            break; 
        } 
      } catch(InterruptedException exc) { 
        System.out.println(exc); 
      } 
      changeColor(); 
    }  
  } 
 
  // Change color. 
  synchronized void changeColor() { 

    switch(tlc) { 
      case RED: 
        tlc = TrafficLightColor.GREEN; 
        break; 
      case YELLOW: 
        tlc = TrafficLightColor.RED; 
        break; 
      case GREEN: 
       tlc = TrafficLightColor.YELLOW; 
    } 
 
    changed = true;
    notify(); // signal that the light has changed 
  } 
 
  // Wait until a light change occurs. 
  synchronized void waitForChange() { 
    try { 
      while(!changed) 
        wait(); // wait for light to change 
      changed = false;
    } catch(InterruptedException exc) { 
      System.out.println(exc); 
    } 
  } 
 
  // Return current color. 
  TrafficLightColor getColor() { 
    return tlc; 
  } 
 
  // Stop the traffic light. 
  void cancel() { 
    stop = true; 
  } 
}  
  
class TrafficLightDemo {  
  public static void main(String args[]) {  
    TrafficLightSimulator tl =
      new TrafficLightSimulator(TrafficLightColor.GREEN); 
 
    for(int i=0; i < 9; i++) { 
      System.out.println(tl.getColor()); 
      tl.waitForChange(); 
    } 
 
    tl.cancel(); 
  }  
}

listing 6
// Demonstrate manual boxing and unboxing with a type wrapper. 
class Wrap { 
  public static void main(String args[]) { 
     
    Integer iOb = new Integer(100);  
 
    int i = iOb.intValue(); 
 
    System.out.println(i + " " + iOb); // displays 100 100 
  } 
}

listing 7
// Demonstrate autoboxing/unboxing. 
class AutoBox { 
  public static void main(String args[]) { 
     
    Integer iOb = 100; // autobox an int 
 
    int i = iOb; // auto-unbox 
 
    System.out.println(i + " " + iOb);  // displays 100 100 
  } 
}

listing 8
// Autoboxing/unboxing takes place with  
// method parameters and return values.  
  
class AutoBox2 {  
  // This method has an Integer parameter. 
  static void m(Integer v) {  
    System.out.println("m() received " + v); 
  }   
  
  // This method returns an int. 
  static int m2() { 
    return 10; 
  } 
 
  // This method returns an Integer. 
  static Integer m3() { 
    return 99; // autoboxing 99 into an Integer. 
  } 
 
  public static void main(String args[]) { 
 
    // Pass an int to m().  Because m() has an Integer 
    // parameter, the int value passed is automatically boxed. 
    m(199); 
 
    // Here, iOb recieves the int value returned by m2(). 
    // This value is automatically boxed so that it can be 
    // assigned to iOb. 
    Integer iOb = m2();   
    System.out.println("Return value from m2() is " + iOb);  
 
    // Next, m3() is called. It returns an Integer value 
    // which is auto-unboxed into an int. 
    int i = m3(); 
    System.out.println("Return value from m3() is " + i);  
 
    // Next, Math.sqrt() is called with iOb as an argument. 
    // In this case, iOb is auto-unboxed and its value promoted to 
    // double, which is the type needed by sqrt(). 
    iOb = 100; 
    System.out.println("Square root of iOb is " + Math.sqrt(iOb)); 
  }  
}

listing 9
// Autoboxing/unboxing occurs inside expressions. 
 
class AutoBox3 { 
  public static void main(String args[]) { 
     
    Integer iOb, iOb2; 
    int i; 
 
    iOb = 99; 
    System.out.println("Original value of iOb: " + iOb); 
 
    // The following automatically unboxes iOb, 
    // performs the increment, and then reboxes 
    // the result back into iOb. 
    ++iOb; 
    System.out.println("After ++iOb: " + iOb); 
 
    // Here, iOb is unboxed, its value is increased by 10 
    // and the result is boxed and stored back in iOb. 
    iOb += 10;  
    System.out.println("After iOb += 10: " + iOb); 
 
    // Here, iOb is unboxed, the expression is  
    // evaluated, and the result is reboxed and 
    // assigned to iOb2. 
    iOb2 = iOb + (iOb / 3); 
    System.out.println("iOb2 after expression: " + iOb2); 
 
    // The same expression is evaluated, but the 
    // result is not reboxed. 
    i = iOb + (iOb / 3); 
    System.out.println("i after expression: " + i); 
  }  
}

listing 10
// Find the solutions to a quadratic equation. 
class Quadratic {  
  public static void main(String args[]) {  
 
    // a, b, and c represent the coefficients in the 
    // quadratic equation: ax2 + bx + c = 0 
    double a, b, c, x; 
 
    // Solve 4x2 + x - 3 = 0 for x. 
    a = 4; 
    b = 1; 
    c = -3; 
 
    // Find first solution. 
    x = (-b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a); 
    System.out.println("First solution: " + x); 
 
    // Find second solution. 
    x = (-b - Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a); 
    System.out.println("Second solution: " + x); 
  }  
}

listing 11
// Use static import to bring sqrt() and pow() into view. 
 
import static java.lang.Math.sqrt; 
import static java.lang.Math.pow; 
 
class Quadratic {  
  public static void main(String args[]) {  
 
    // a, b, and c represent the coefficients in the 
    // quadratic equation: ax2 + bx + c = 0 
    double a, b, c, x; 
 
    // Solve 4x2 + x -3 = 0 for x. 
    a = 4; 
    b = 1; 
    c = -3; 
 
    // Find first solution. 
    x = (-b + sqrt(pow(b, 2) - 4 * a * c)) / (2 * a); 
    System.out.println("First solution: " + x); 
 
    // Find second solution. 
    x = (-b - sqrt(pow(b, 2) - 4 * a * c)) / (2 * a); 
    System.out.println("Second solution: " + x); 
  }  
}

listing 12
// An example that uses @Deprecated. 
 
// Deprecate a class. 
@Deprecated 
class MyClass { 
  private String msg; 
 
  MyClass(String m) { 
    msg = m; 
  } 
   
  // Deprecate a method within a class. 
  @Deprecated 
  String getMsg() { 
    return msg; 
  } 
 
  // ... 
} 
 
class AnnoDemo { 
  public static void main(String args[]) { 
    MyClass myObj = new MyClass("test"); 
 
    System.out.println(myObj.getMsg()); 
  } 
}

 
listing 1
// A simple generic class.  
// Here, T is a type parameter that 
// will be replaced by a real type 
// when an object of type Gen is created. 
class Gen<T> { 
  T ob; // declare an object of type T 
   
  // Pass the constructor a reference to  
  // an object of type T. 
  Gen(T o) { 
    ob = o; 
  } 
 
  // Return ob. 
  T getob() { 
    return ob; 
  } 
 
  // Show type of T. 
  void showType() { 
    System.out.println("Type of T is " + 
                       ob.getClass().getName()); 
  } 
} 
 
// Demonstrate the generic class. 
class GenDemo { 
  public static void main(String args[]) { 
    // Create a Gen reference for Integers.  
    Gen<Integer> iOb;  
 
    // Create a Gen<Integer> object and assign its 
    // reference to iOb.  Notice the use of autoboxing  
    // to encapsulate the value 88 within an Integer object. 
    iOb = new Gen<Integer>(88); 
 
    // Show the type of data used by iOb. 
    iOb.showType(); 
 
    // Get the value in iOb. Notice that 
    // no cast is needed. 
    int v = iOb.getob(); 
    System.out.println("value: " + v); 
 
    System.out.println(); 
 
    // Create a Gen object for Strings. 
    Gen<String> strOb = new Gen<String>("Generics Test"); 
 
    // Show the type of data used by strOb. 
    strOb.showType(); 
 
    // Get the value of strOb. Again, notice 
    // that no cast is needed. 
    String str = strOb.getob(); 
    System.out.println("value: " + str); 
  } 
}

listing 2
// A simple generic class with two type 
// parameters: T and V. 
class TwoGen<T, V> { 
  T ob1; 
  V ob2; 
   
  // Pass the constructor a reference to  
  // an object of type T. 
  TwoGen(T o1, V o2) { 
    ob1 = o1; 
    ob2 = o2; 
  } 
 
  // Show types of T and V. 
  void showTypes() { 
    System.out.println("Type of T is " + 
                       ob1.getClass().getName()); 
 
    System.out.println("Type of V is " + 
                       ob2.getClass().getName()); 
  } 
 
  T getob1() { 
    return ob1; 
  } 
 
  V getob2() { 
    return ob2; 
  } 
} 
 
// Demonstrate TwoGen. 
class SimpGen { 
  public static void main(String args[]) { 
 
    TwoGen<Integer, String> tgObj = 
      new TwoGen<Integer, String>(88, "Generics"); 
 
    // Show the types. 
    tgObj.showTypes(); 
 
    // Obtain and show values. 
    int v = tgObj.getob1(); 
    System.out.println("value: " + v); 
 
    String str = tgObj.getob2(); 
    System.out.println("value: " + str); 
  } 
}

listing 3
// NumericFns attemps (unsuccessfully) to create 
// a generic class that can compute various 
// numeric functions, such as the reciprocal or the 
// fractional component, given any type of number. 
class NumericFns<T> {  
  T num; 
    
  // Pass the constructor a reference to   
  // a numeric object. 
  NumericFns(T n) {  
    num = n; 
  }  
  
  // Return the reciprocal. 
  double reciprocal() { 
    return 1 / num.doubleValue(); // Error! 
  } 
 
  // Return the fractional component. 
  double fraction() { 
    return num.doubleValue() - num.intValue(); // Error! 
  } 
 
  // ... 
} 

listing 4
// In this version of NumericFns, the type argument 
// for T must be either Number, or a class derived 
// from Number. 
class NumericFns<T extends Number> {  
  T num; 
    
  // Pass the constructor a reference to   
  // a numeric object. 
  NumericFns(T n) {  
    num = n; 
  }  
  
  // Return the reciprocal. 
  double reciprocal() { 
    return 1 / num.doubleValue(); 
  } 
 
  // Return the fractional component. 
  double fraction() { 
    return num.doubleValue() - num.intValue(); 
  } 
 
  // ... 
}  
  
// Demonstrate NumericFns.  
class BoundsDemo {  
  public static void main(String args[]) {  
 
    NumericFns<Integer> iOb = 
                      new NumericFns<Integer>(5);   
 
    System.out.println("Reciprocal of iOb is " + 
                        iOb.reciprocal()); 
    System.out.println("Fractional component of iOb is " + 
                        iOb.fraction()); 
 
    System.out.println(); 
 
    NumericFns<Double> dOb = 
                      new NumericFns<Double>(5.25);   
 
    System.out.println("Reciprocal of dOb is " + 
                        dOb.reciprocal()); 
    System.out.println("Fractional component of dOb is " + 
                        dOb.fraction()); 
 
 
    // This won't compile because String is not a 
    // subclass of Number. 
//    NumericFns<String> strOb = new NumericFns<String>("Error");   
  }  
}

listing 5
// Use a wildcard. 
class NumericFns<T extends Number> {  
  T num; 
    
  // Pass the constructor a reference to   
  // a numeric object. 
  NumericFns(T n) {  
    num = n; 
  }  
  
  // Return the reciprocal. 
  double reciprocal() { 
    return 1 / num.doubleValue(); 
  } 
 
  // Return the fractional component. 
  double fraction() { 
    return num.doubleValue() - num.intValue(); 
  } 
 
  // Determine if the absolute values of two 
  // objects are the same. 
  boolean absEqual(NumericFns<?> ob) { 
    if(Math.abs(num.doubleValue()) == 
         Math.abs(ob.num.doubleValue())) return true; 
 
    return false; 
  } 
 
  // ... 
}  
  
// Demonstrate a wildcard. 
class WildcardDemo {  
  public static void main(String args[]) {  
 
    NumericFns<Integer> iOb = 
                      new NumericFns<Integer>(6);   
 
    NumericFns<Double> dOb = 
                      new NumericFns<Double>(-6.0); 
 
    NumericFns<Long> lOb =  
                      new NumericFns<Long>(5L); 
  
    System.out.println("Testing iOb and dOb."); 
    if(iOb.absEqual(dOb)) 
      System.out.println("Absolute values are equal."); 
    else 
      System.out.println("Absolute values differ."); 
 
    System.out.println(); 
 
    System.out.println("Testing iOb and lOb."); 
    if(iOb.absEqual(lOb)) 
      System.out.println("Absolute values are equal."); 
    else 
      System.out.println("Absolute values differ."); 
  
  }  
}


listing 6
class A { 
  // ... 
} 
 
class B extends A { 
  // ... 
} 
 
class C extends A { 
  // ... 
} 
 
// Note that D does NOT extend A. 
class D {  
  // ... 
}

listing 7
// A simple generic class. 
class Gen<T> { 
  T ob; 
 
  Gen(T o) { 
    ob = o; 
  } 
}

listing 8
class UseBoundedWildcard { 
  // Here, the ? will match A or any class type that 
  // that extends A 
  static void test(Gen<? extends A> o) { 
    // ... 
  }
  public static void main(String args[]) { 
    A a = new A(); 
    B b = new B(); 
    C c = new C(); 
    D d = new D(); 
 
    Gen<A> w = new Gen<A>(a); 
    Gen<B> w2 = new Gen<B>(b); 
    Gen<C> w3 = new Gen<C>(c); 
    Gen<D> w4 = new Gen<D>(d); 
 
    // These calls to test() are OK. 
    test(w); 
    test(w2); 
    test(w3); 
 
    // Can't call test() with w4 because 
    // it is not an object of a class that 
    // inherits A. 
//    test(w4); // Error! 
  } 
}

listing 9
// Demonstrate a simple generic method. 
class GenericMethodDemo {  
 
  // Determine if the contents of two arrays are same. 
  static <T, V extends T> boolean arraysEqual(T[] x, V[] y) { 
    // If array lengths differ, then the arrays differ. 
    if(x.length != y.length) return false; 
 
    for(int i=0; i < x.length; i++) 
      if(!x[i].equals(y[i])) return false; // arrays differ 
  
    return true; // contents of arrays are equivalent 
  } 
 
  public static void main(String args[]) {  
 
    Integer nums[] = { 1, 2, 3, 4, 5 }; 
    Integer nums2[] = { 1, 2, 3, 4, 5 }; 
    Integer nums3[] = { 1, 2, 7, 4, 5 }; 
    Integer nums4[] = { 1, 2, 7, 4, 5, 6 }; 
 
    if(arraysEqual(nums, nums)) 
      System.out.println("nums equals nums"); 
 
    if(arraysEqual(nums, nums2)) 
      System.out.println("nums equals nums2"); 
 
    if(arraysEqual(nums, nums3)) 
      System.out.println("nums equals nums3"); 
 
    if(arraysEqual(nums, nums4)) 
      System.out.println("nums equals nums4"); 
 
    // Create an array of Doubles 
    Double dvals[] = { 1.1, 2.2, 3.3, 4.4, 5.5 }; 
 
    // This won't compile because nums and dvals 
    // are not of the same type. 
//    if(arraysEqual(nums, dvals)) 
//      System.out.println("nums equals dvals"); 
  }  
}


listing 10
// Use a generic constructor. 
class Summation { 
  private int sum; 
 
  <T extends Number> Summation(T arg) { 
    sum = 0; 
 
    for(int i=0; i <= arg.intValue(); i++) 
      sum += i; 
  } 
 
  int getSum() { 
    return sum; 
  } 
} 
 
class GenConsDemo { 
  public static void main(String args[]) { 
    Summation ob = new Summation(4.0); 
 
    System.out.println("Summation of 4.0 is " + 
                       ob.getSum()); 
  } 
}

listing 11
// A generic interface example.  
  
// A generic containment interface. 
// This interface implies that an implementing 
// class contains one or more values. 
interface Containment<T> { 
  // The contains() method tests if a 
  // specific item is contained within 
  // an object that implements Containment. 
  boolean contains(T o); 
}  
  
// Implement Containment using an array to  
// hold the values. 
class MyClass<T> implements Containment<T> {  
  T[] arrayRef; 
 
  MyClass(T[] o) { 
    arrayRef = o; 
  } 
 
  // Implement Contains. 
  public boolean contains(T o) { 
    for(T x : arrayRef) 
      if(x.equals(o)) return true; 
    return false; 
  }     
}  
  
class GenIFDemo {  
  public static void main(String args[]) {  
    Integer x[] = { 1, 2, 3 }; 
 
    MyClass<Integer> ob = new MyClass<Integer>(x); 
 
    if(ob.contains(2)) 
      System.out.println("2 is in ob"); 
    else 
      System.out.println("2 is NOT in ob"); 
 
    if(ob.contains(5)) 
      System.out.println("5 is in ob"); 
    else 
      System.out.println("5 is NOT in ob"); 
 
    // The follow is illegal because ob 
    // is an Integer Containment and 9.25 is 
    // a Double value. 
//    if(ob.contains(9.25)) // Illegal! 
//      System.out.println("9.25 is in ob"); 
 
  } 
}

listing 12
// A generic queue interface. 
public interface IGenQ<T> {      
  // Put an item into the queue.      
  void put(T ch) throws QueueFullException;   
   
  // Get an item from the queue.     
  T get() throws QueueEmptyException;   
}

listing 13
// An exception for queue-full errors.  
class QueueFullException extends Exception {  
  int size;  
  
  QueueFullException(int s) { size = s; }  
  
  public String toString() {  
   return "\nQueue is full. Maximum size is " +  
          size;  
  }  
}  
  
// An exception for queue-empty errors.  
class QueueEmptyException extends Exception {  
  
  public String toString() {  
   return "\nQueue is empty.";  
  }  
}

listing 14
// A generic, fixed-size queue class. 
class GenQueue<T> implements IGenQ<T> {      
  private T q[]; // this array holds the queue      
  private int putloc, getloc; // the put and get indices      
      
  // Construct an empty queue with the given array.     
  public GenQueue(T[] aRef) {   
    q = aRef;  
    putloc = getloc = 0;      
  }      
     
  // Put an item into the queue.      
  public void put(T obj)  
    throws QueueFullException {      
  
    if(putloc==q.length-1)   
      throw new QueueFullException(q.length-1);  
          
    putloc++;      
    q[putloc] = obj;      
  }      
      
  // Get a character from the queue.     
  public T get()  
    throws QueueEmptyException {      
  
    if(getloc == putloc)   
      throw new QueueEmptyException();  
        
    getloc++;      
    return q[getloc];      
  }      
}

listing 15
/*   
    Project 13-1 
  
    Demonstrate a generic queue class. 
*/ 
class GenQDemo {      
  public static void main(String args[]) { 
    // Create in integer queue. 
    Integer iStore[] = new Integer[10]; 
    GenQueue<Integer> q = new GenQueue<Integer>(iStore); 
 
    Integer iVal; 
 
    System.out.println("Demonstrate a queue of Integers."); 
    try {   
      for(int i=0; i < 5; i++) {  
        System.out.println("Adding " + i + " to the q."); 
        q.put(i); // add integer value to q 
 
      }  
    }  
    catch (QueueFullException exc) {  
      System.out.println(exc);  
    }  
    System.out.println();  
     
    try {  
      for(int i=0; i < 5; i++) {       
        System.out.print("Getting next Integer from q: ");  
        iVal = q.get();      
        System.out.println(iVal);      
      }  
    }  
    catch (QueueEmptyException exc) {  
      System.out.println(exc);  
    }   
 
    System.out.println();  
 
    // Create a Double queue. 
    Double dStore[] = new Double[10]; 
    GenQueue<Double> q2 = new GenQueue<Double>(dStore); 
 
    Double dVal;      
 
    System.out.println("Demonstrate a queue of Doubles."); 
    try {   
      for(int i=0; i < 5; i++) {  
        System.out.println("Adding " + (double)i/2 + 
                           " to the q2."); 
        q2.put((double)i/2); // add double value to q2 
      }  
    }  
    catch (QueueFullException exc) {  
      System.out.println(exc);  
    }  
    System.out.println();  
     
    try {  
      for(int i=0; i < 5; i++) {       
        System.out.print("Getting next Double from q2: "); 
        dVal = q2.get();      
        System.out.println(dVal);      
      }  
    }  
    catch (QueueEmptyException exc) {  
      System.out.println(exc);  
    }   
  }  
}

listing 16
// Demonstrate a raw type. 
class Gen<T> {  
  T ob; // declare an object of type T  
    
  // Pass the constructor a reference to   
  // an object of type T.  
  Gen(T o) {  
    ob = o;  
  }  
  
  // Return ob.  
  T getob() {  
    return ob;  
  }  
}  
  
// Demonstrate raw type. 
class RawDemo {  
  public static void main(String args[]) {  
 
    // Create a Gen object for Integers. 
    Gen<Integer> iOb = new Gen<Integer>(88);  
   
    // Create a Gen object for Strings. 
    Gen<String> strOb = new Gen<String>("Generics Test");  
  
    // Create a raw-type Gen object and give it 
    // a Double value. 
    Gen raw = new Gen(new Double(98.6)); 
 
    // Cast here is necessary because type is unknown. 
    double d = (Double) raw.getob(); 
    System.out.println("value: " + d); 
 
    // The use of a raw type can lead to run-time. 
    // exceptions.  Here are some examples. 
 
    // The following cast causes a run-time error! 
//    int i = (Integer) raw.getob(); // run-time error 
 
    // This assigment overrides type safety. 
    strOb = raw; // OK, but potentially wrong 
//    String str = strOb.getob(); // run-time error  
     
    // This assingment also overrides type safety. 
    raw = iOb; // OK, but potentially wrong 
//    d = (Double) raw.getob(); // run-time error 
  }  
}

listing 17
// Here, T is bound by Object by default. 
class Gen<T> {  
  T ob; // here, T will be replaced by Object 
    
  Gen(T o) {  
    ob = o;  
  }  
  
  // Return ob.  
  T getob() {  
    return ob;  
  }  
}  
 
// Here, T is bound by String. 
class GenStr<T extends String> { 
  T str; // here, T will be replaced by String 
 
  GenStr(T o) {  
    str = o;  
  }  
 
  T getstr() { return str; } 
}

listing 18
// Ambiguity caused by erasure on  
// overloaded methods. 
class MyGenClass<T, V> {  
  T ob1;  
  V ob2;  
 
  // ... 
 
  // These two overloaded methods are ambiguous 
  // and will not compile. 
  void set(T o) { 
    ob1 = o; 
  } 
 
  void set(V o) { 
    ob2 = o; 
  } 
}

listing 19
// Can't create an instance of T. 
class Gen<T> {  
  T ob;  
  Gen() {  
    ob = new T(); // Illegal!!! 
  }  
} 

listing 20
class Wrong<T> {  
  // Wrong, no static variables of type T. 
  static T ob; 
    
  // Wrong, no static method can use T. 
  static T getob() { 
    return ob; 
  } 
 
  // Wrong, no static method can access object 
  // of type T. 
  static void showob() { 
    System.out.println(ob); 
 } 
}

listing 21
// Generics and arrays. 
class Gen<T extends Number> {  
  T ob;  
 
  T vals[]; // OK 
 
  Gen(T o, T[] nums) {  
    ob = o; 
 
    // This statement is illegal. 
//  vals = new T[10]; // can't create an array of T 
 
    // But, this statement is OK. 
    vals = nums; // OK to assign reference to existent array 
  }  
}  
  
class GenArrays {  
  public static void main(String args[]) {  
    Integer n[] = { 1, 2, 3, 4, 5 };   
 
    Gen<Integer> iOb = new Gen<Integer>(50, n); 
 
    // Can't create an array of type-specific generic references. 
    // Gen<Integer> gens[] = new Gen<Integer>[10]; // Wrong! 
 
    // This is OK. 
    Gen<?> gens[] = new Gen<?>[10]; // OK
  } 
}

 
listing 1
// A minimal applet. 
import java.awt.*; 
import java.applet.*; 
 
public class SimpleApplet extends Applet { 
  public void paint(Graphics g) { 
    g.drawString("Java makes applets easy.", 20, 20); 
  } 
}

listing 2
import java.awt.*; 
import java.applet.*; 
/* 
<applet code="SimpleApplet" width=200 height=60> 
</applet> 
*/ 
 
public class SimpleApplet extends Applet { 
  public void paint(Graphics g) { 
    g.drawString("Java makes applets easy.", 20, 20); 
  } 
}

listing 3
// An Applet skeleton. 
import java.awt.*; 
import java.applet.*; 
/* 
<applet code="AppletSkel" width=300 height=100> 
</applet> 
*/ 
 
public class AppletSkel extends Applet { 
  // Called first. 
  public void init() { 
    // initialization 
  } 
 
  /* Called second, after init().  Also called whenever 
     the applet is restarted. */ 
  public void start() { 
    // start or resume execution 
  } 
 
  // Called when the applet is stopped. 
  public void stop() { 
    // suspends execution 
  } 
 
  /* Called when applet is terminated.  This is the last 
     method executed. */ 
  public void destroy() { 
    // perform shutdown activities 
  } 
 
  // Called when an applet's window must be restored. 
  public void paint(Graphics g) { 
    // redisplay contents of window 
  } 
}

listing 4
/*  
   Project 12-1 
 
   A simple banner applet. 
 
   This applet creates a thread that scrolls 
   the message contained in msg right to left 
   across the applet's window. 
*/ 
import java.awt.*; 
import java.applet.*; 
/* 
<applet code="Banner" width=300 height=50> 
</applet> 
*/ 
 
public class Banner extends Applet implements Runnable { 
  String msg = " Java Rules the Web "; 
  Thread t; 
  boolean stopFlag; 
 
  // Initialize t to null.  
  public void init() { 
    t = null; 
  } 
 
  // Start thread 
  public void start() { 
    t = new Thread(this); 
    stopFlag = false; 
    t.start(); 
  } 
 
  // Entry point for the thread that runs the banner. 
  public void run() { 
    char ch; 
 
    // Display banner  
    for( ; ; ) { 
      try { 
        repaint(); 
        Thread.sleep(250); 
        ch = msg.charAt(0); 
        msg = msg.substring(1, msg.length()); 
        msg += ch; 
        if(stopFlag) 
          break; 
      } catch(InterruptedException exc) {} 
    } 
  } 
 
  // Pause the banner. 
  public void stop() { 
    stopFlag = true; 
    t = null; 
  } 
 
  // Display the banner. 
  public void paint(Graphics g) { 
    g.drawString(msg, 50, 30); 
  } 
}

listing 5
// Using the Status Window. 
import java.awt.*; 
import java.applet.*; 
/* 
<applet code="StatusWindow" width=300 height=50> 
</applet> 
*/ 
 
public class StatusWindow extends Applet{ 
  // Display msg in applet window. 
  public void paint(Graphics g) { 
    g.drawString("This is in the applet window.", 10, 20); 
    showStatus("This is shown in the status window."); 
  } 
}

listing 6
// Pass a parameter to an applet. 
import java.awt.*; 
import java.applet.*; 
 
/* 
<applet code="Param" width=300 height=80> 
<param name=author value="Herb Schildt"> 
<param name=purpose value="Demonstrate Parameters"> 
<param name=version value=2> 
</applet> 
*/ 
 
public class Param extends Applet { 
  String author; 
  String purpose; 
  int ver; 
 
  public void start() { 
    String temp; 
 
    author = getParameter("author"); 
    if(author == null) author = "not found"; 
 
    purpose = getParameter("purpose"); 
    if(purpose == null) purpose = "not found"; 
 
    temp = getParameter("version"); 
    try { 
      if(temp != null) 
        ver = Integer.parseInt(temp); 
      else 
        ver = 0; 
    } catch(NumberFormatException exc) { 
        ver = -1; // error code 
    } 
  } 
 
  public void paint(Graphics g) { 
    g.drawString("Purpose: " + purpose, 10, 20); 
    g.drawString("By: " + author, 10, 40); 
    g.drawString("Version: " + ver, 10, 60); 
  } 
}

listing 7
// Demonstrate the mouse event handlers. 
import java.awt.*; 
import java.awt.event.*; 
import java.applet.*; 
/* 
  <applet code="MouseEvents" width=300 height=100> 
  </applet> 
*/ 
 
public class MouseEvents extends Applet 
  implements MouseListener, MouseMotionListener { 
 
  String msg = ""; 
  int mouseX = 0, mouseY = 0; // coordinates of mouse 
 
  public void init() { 
     addMouseListener(this); 
     addMouseMotionListener(this); 
  } 
 
  // Handle mouse clicked. 
  public void mouseClicked(MouseEvent me) { 
    mouseX = 0; 
    mouseY = 10; 
    msg = "Mouse clicked."; 
    repaint(); 
  } 
 
  // Handle mouse entered. 
  public void mouseEntered(MouseEvent me) { 
    mouseX = 0; 
    mouseY = 10; 
    msg = "Mouse entered."; 
    repaint(); 
  } 
 
  // Handle mouse exited. 
  public void mouseExited(MouseEvent me) { 
    mouseX = 0; 
    mouseY = 10; 
    msg = "Mouse exited."; 
    repaint(); 
  } 
 
  // Handle button pressed. 
  public void mousePressed(MouseEvent me) { 
    // save coordinates 
    mouseX = me.getX(); 
    mouseY = me.getY(); 
    msg = "Down"; 
    repaint(); 
  } 
 
  // Handle button released. 
  public void mouseReleased(MouseEvent me) { 
    // save coordinates 
    mouseX = me.getX(); 
    mouseY = me.getY(); 
    msg = "Up"; 
    repaint(); 
  } 
 
  // Handle mouse dragged. 
  public void mouseDragged(MouseEvent me) { 
    // save coordinates 
    mouseX = me.getX(); 
    mouseY = me.getY(); 
    msg = "*"; 
    showStatus("Dragging mouse at " + mouseX + ", " + mouseY); 
    repaint(); 
  } 
 
  // Handle mouse moved. 
  public void mouseMoved(MouseEvent me) { 
    // show status 
    showStatus("Moving mouse at " + me.getX() + ", " + me.getY()); 
  } 
 
  // Display msg in applet window at current X,Y location. 
  public void paint(Graphics g) { 
    g.drawString(msg, mouseX, mouseY); 
  } 
}

listing 1
// A simple Swing program. 
 
import javax.swing.*; 
  
class SwingDemo { 
 
  SwingDemo() { 
 
    // Create a new JFrame container. 
    JFrame jfrm = new JFrame("A Simple Swing Application"); 
 
    // Give the frame an initial size. 
    jfrm.setSize(275, 100); 
 
    // Terminate the program when the user closes the application. 
    jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
 
    // Create a text-based label. 
    JLabel jlab = new JLabel(" Swing defines the modern Java GUI."); 
 
    // Add the label to the content pane. 
    jfrm.add(jlab); 
 
    // Display the frame. 
    jfrm.setVisible(true); 
  } 
 
  public static void main(String args[]) { 
    // Create the frame on the event dispatching thread. 
    SwingUtilities.invokeLater(new Runnable() { 
      public void run() { 
        new SwingDemo(); 
      } 
    }); 
  } 
}
    
listing 2
// Demonstrate a push button and handle action events. 
 
import java.awt.*; 
import java.awt.event.*; 
import javax.swing.*; 
  
class ButtonDemo implements ActionListener { 
 
  JLabel jlab;  
 
  ButtonDemo() { 
 
    // Create a new JFrame container. 
    JFrame jfrm = new JFrame("A Button Example"); 
 
    // Specify FlowLayout for the layout manager. 
    jfrm.setLayout(new FlowLayout()); 
 
    // Give the frame an initial size. 
    jfrm.setSize(220, 90); 
 
    // Terminate the program when the user closes the application. 
    jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
 
    // Make two buttons. 
    JButton jbtnUp = new JButton("Up"); 
    JButton jbtnDown = new JButton("Down"); 
 
    // Add action listeners. 
    jbtnUp.addActionListener(this); 
    jbtnDown.addActionListener(this); 
 
    // Add the buttons to the content pane. 
    jfrm.add(jbtnUp);  
    jfrm.add(jbtnDown);  
 
    // Create a label. 
    jlab = new JLabel("Press a button."); 
 
    // Add the label to the frame. 
    jfrm.add(jlab); 
 
    // Display the frame. 
    jfrm.setVisible(true); 
  } 
 
  // Handle button events. 
  public void actionPerformed(ActionEvent ae) { 
    if(ae.getActionCommand().equals("Up"))  
      jlab.setText("You pressed Up."); 
    else 
      jlab.setText("You pressed down. "); 
  } 
 
  public static void main(String args[]) { 
    // Create the frame on the event dispatching thread. 
    SwingUtilities.invokeLater(new Runnable() { 
      public void run() { 
        new ButtonDemo(); 
      } 
    }); 
  } 
}

listing 3
// Use a text field. 
 
import java.awt.*; 
import java.awt.event.*; 
import javax.swing.*; 
  
class TFDemo implements ActionListener { 
 
  JTextField jtf; 
  JButton jbtnRev; 
  JLabel jlabPrompt, jlabContents;  
 
  TFDemo() { 
 
    // Create a new JFrame container. 
    JFrame jfrm = new JFrame("Use a Text Field"); 
 
    // Specify FlowLayout for the layout manager. 
    jfrm.setLayout(new FlowLayout()); 
 
    // Give the frame an initial size. 
    jfrm.setSize(240, 120); 
 
    // Terminate the program when the user closes the application. 
    jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
 
    // Create a text field. 
    jtf = new JTextField(10); 
 
    // Set the action commands for the text field. 
    jtf.setActionCommand("myTF"); 
 
    // Create the Reverse button. 
    JButton jbtnRev = new JButton("Reverse"); 
 
    // Add action listeners. 
    jtf.addActionListener(this); 
    jbtnRev.addActionListener(this); 
 
    // Create the labels. 
    jlabPrompt = new JLabel("Enter text: "); 
    jlabContents = new JLabel(""); 
 
    // Add the components to the content pane. 
    jfrm.add(jlabPrompt); 
    jfrm.add(jtf);  
    jfrm.add(jbtnRev);  
    jfrm.add(jlabContents); 
 
    // Display the frame. 
    jfrm.setVisible(true); 
  } 
 
  // Handle action events. 
  public void actionPerformed(ActionEvent ae) { 
   
    if(ae.getActionCommand().equals("Reverse")) { 
      // The Reverse button was pressed.  
      String orgStr = jtf.getText(); 
      String resStr = ""; 
 
      // Reverse the string in the text field. 
      for(int i=orgStr.length()-1; i >=0; i--) 
        resStr += orgStr.charAt(i); 
 
      // Store the reversed string in the text field. 
      jtf.setText(resStr);  
    } else 
      // Enter was pressed while focus was in the  
      // text field. 
      jlabContents.setText("You pressed ENTER. Text is: " + 
                           jtf.getText()); 
  } 
 
  public static void main(String args[]) { 
    // Create the frame on the event dispatching thread. 
    SwingUtilities.invokeLater(new Runnable() { 
      public void run() { 
        new TFDemo(); 
      } 
    }); 
  } 
}

listing 4
// Demonstrate check boxes. 
  
import java.awt.*;  
import java.awt.event.*;  
import javax.swing.*;  
   
class CBDemo implements ItemListener {  
  
  JLabel jlabSelected; 
  JLabel jlabChanged; 
  JCheckBox jcbAlpha; 
  JCheckBox jcbBeta; 
  JCheckBox jcbGamma; 
  
  CBDemo() {  
    // Create a new JFrame container.  
    JFrame jfrm = new JFrame("Demonstrate Check Boxes");  
  
    // Specify FlowLayout for the layout manager. 
    jfrm.setLayout(new FlowLayout()); 
  
    // Give the frame an initial size.  
    jfrm.setSize(280, 120);  
  
    // Terminate the program when the user closes the application.  
    jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
  
    // Create empty labels. 
    jlabSelected = new JLabel(""); 
    jlabChanged = new JLabel("");  
  
    // Make check boxes. 
    jcbAlpha = new JCheckBox("Alpha");  
    jcbBeta = new JCheckBox("Beta");  
    jcbGamma = new JCheckBox("Gamma");  
 
    // Events generated by the check boxes 
    // are handled in common by the itemStateChanged() 
    // method implemented by CBDemo. 
    jcbAlpha.addItemListener(this); 
    jcbBeta.addItemListener(this); 
    jcbGamma.addItemListener(this); 
  
    // Add checkboxes and labels to the content pane.  
    jfrm.add(jcbAlpha);   
    jfrm.add(jcbBeta);   
    jfrm.add(jcbGamma);   
    jfrm.add(jlabChanged);  
    jfrm.add(jlabSelected);  
  
    // Display the frame.  
    jfrm.setVisible(true);  
  }  
 
  // This is the handler for the check boxes.   
  public void itemStateChanged(ItemEvent ie) { 
    String str = ""; 
 
    // Obtain a reference to the check box that 
    // caused the event. 
    JCheckBox cb = (JCheckBox) ie.getItem(); 
 
    // Report what check box changed. 
    if(cb.isSelected())  
      jlabChanged.setText(cb.getText() + " was just selected."); 
    else 
      jlabChanged.setText(cb.getText() + " was just cleared."); 
 
    // Report all selected boxes. 
    if(jcbAlpha.isSelected()) { 
      str += "Alpha "; 
    }  
    if(jcbBeta.isSelected()) { 
      str += "Beta "; 
    } 
    if(jcbGamma.isSelected()) { 
      str += "Gamma"; 
    } 
 
    jlabSelected.setText("Selected check boxes: " + str); 
  } 
 
  public static void main(String args[]) {  
    // Create the frame on the event dispatching thread.  
    SwingUtilities.invokeLater(new Runnable() {  
      public void run() {  
        new CBDemo();  
      }  
    });  
  }  
}

listing 5
// Demonstrate a simple JList. 
  
import javax.swing.*;  
import javax.swing.event.*; 
import java.awt.*; 
import java.awt.event.*; 
   
class ListDemo implements ListSelectionListener {  
  
  JList jlst; 
  JLabel jlab; 
  JScrollPane jscrlp; 
 
  // Create an array of names. 
  String names[] = { "Sherry", "Jon", "Rachel",  
                     "Sasha", "Josselyn",  "Randy", 
                     "Tom", "Mary", "Ken", 
                     "Andrew", "Matt", "Todd" }; 
 
  ListDemo() {  
    // Create a new JFrame container.  
    JFrame jfrm = new JFrame("JList Demo");  
 
    // Specify a flow Layout. 
    jfrm.setLayout(new FlowLayout());  
 
    // Give the frame an initial size.  
    jfrm.setSize(200, 160);  
  
    // Terminate the program when the user closes the application.  
    jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
  
    // Create a JList. 
    jlst = new JList(names); 
 
    // Set the list selection mode to single-selection. 
    jlst.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); 
 
    // Add list to a scroll pane. 
    jscrlp = new JScrollPane(jlst); 
 
    // Set the preferred size of the scroll pane. 
    jscrlp.setPreferredSize(new Dimension(120, 90)); 
 
    // Make a label that displays the selection. 
    jlab = new JLabel("Please choose a name"); 
 
    // Add list selection handler. 
    jlst.addListSelectionListener(this); 
 
    // Add the list and label to the content pane. 
    jfrm.add(jscrlp); 
    jfrm.add(jlab); 
  
    // Display the frame.  
    jfrm.setVisible(true);  
  }  
 
  // Handle list selection events. 
  public void valueChanged(ListSelectionEvent le) {  
    // Get the index of the changed item. 
    int idx = jlst.getSelectedIndex(); 
 
    // Display selection, if item was selected. 
    if(idx != -1) 
      jlab.setText("Current selection: " + names[idx]); 
    else // Othewise, reprompt. 
      jlab.setText("Please choose an name"); 
  }  
 
  public static void main(String args[]) {  
    // Create the frame on the event dispatching thread.  
    SwingUtilities.invokeLater(new Runnable() {  
      public void run() {  
        new ListDemo();  
      }  
    });   
  }  
}

listing 6
/* 
     Project 15-1 
 
     A Swing-based file comparison utility. 
*/ 
 
import java.awt.*; 
import java.awt.event.*; 
import javax.swing.*; 
import java.io.*; 
  
class SwingFC implements ActionListener { 
 
  JTextField jtfFirst;  // holds the first file name 
  JTextField jtfSecond; // holds the second file name 
 
  JButton jbtnComp; // button to compare the files 
 
  JLabel jlabFirst, jlabSecond; // displays prompts  
  JLabel jlabResult; // displays results and error messages 
 
  SwingFC() { 
 
    // Create a new JFrame container. 
    JFrame jfrm = new JFrame("Compare Files"); 
 
    // Specify FlowLayout for the layout manager. 
    jfrm.setLayout(new FlowLayout()); 
 
    // Give the frame an initial size. 
    jfrm.setSize(200, 190); 
 
    // Terminate the program when the user closes the application. 
    jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
 
    // Create the text fields for the file names.. 
    jtfFirst = new JTextField(14); 
    jtfSecond = new JTextField(14); 
 
    // Set the action commands for the text fields. 
    jtfFirst.setActionCommand("fileA"); 
    jtfSecond.setActionCommand("fileB"); 
 
    // Create the Compare button. 
    JButton jbtnComp = new JButton("Compare"); 
 
    // Add action listener for the Compare button. 
    jbtnComp.addActionListener(this); 
 
    // Create the labels. 
    jlabFirst = new JLabel("First file: "); 
    jlabSecond = new JLabel("Second file: "); 
    jlabResult = new JLabel(""); 
 
    // Add the components to the content pane. 
    jfrm.add(jlabFirst); 
    jfrm.add(jtfFirst);  
    jfrm.add(jlabSecond); 
    jfrm.add(jtfSecond);  
    jfrm.add(jbtnComp);  
    jfrm.add(jlabResult); 
 
    // Display the frame. 
    jfrm.setVisible(true); 
  } 
 
  // Compare the files when the Compare button is pressed. 
  public void actionPerformed(ActionEvent ae) { 
    int i=0, j=0;   
    FileInputStream f1;   
    FileInputStream f2;   
   
    // First, confirm that both file names have 
    // been entered. 
    if(jtfFirst.getText().equals("")) { 
      jlabResult.setText("First file name missing."); 
      return; 
    } 
    if(jtfSecond.getText().equals("")) { 
      jlabResult.setText("Second file name missing."); 
      return; 
    } 
 
    // Open first file. 
    try {   
      f1 = new FileInputStream(jtfFirst.getText());   
    } catch(FileNotFoundException exc) {   
      jlabResult.setText("First file not found.");   
      return;   
    }   
   
    // Open second file. 
    try {   
      f2 = new FileInputStream(jtfSecond.getText());   
    } catch(FileNotFoundException exc) {   
      jlabResult.setText("Second file not found.");   

      // Close the first file if the second file
      // cannot be opened.
      try {
        f1.close();
      } catch(IOException exc2) { 
        jlabResult.setText("Cannot close first file."); 
      } 

      return;   
    }   
   
    // Compare files. 
    try {   
      do {   
        i = f1.read();   
        j = f2.read();   
        if(i != j) break;  
      } while(i != -1 && j != -1);   
   
      if(i != j)   
        jlabResult.setText("Files are not the same."); 
      else  
        jlabResult.setText("Files compare equal.");  
    } catch(IOException exc) {   
      jlabResult.setText("File Error");   
    }   

    try {
      f1.close();  
    } catch(IOException exc) { 
      jlabResult.setText("Error closing first file.");
    } 

    try {
      f2.close();  
    } catch(IOException exc) { 
      jlabResult.setText("Error closing second file."); 
    } 
 
  } 
 
  public static void main(String args[]) { 
    // Create the frame on the event dispatching thread. 
    SwingUtilities.invokeLater(new Runnable() { 
      public void run() { 
        new SwingFC(); 
      } 
    }); 
  } 
}
 

/* ANSWER */

listing 1
/*    
   Compute your weight on the moon.  
   
   Call this file Moon.java.   
*/    
class Moon {    
  public static void main(String args[]) {    
    double earthweight; // weight on earth  
    double moonweight; // weight on moon   
   
    earthweight = 165;   
  
    moonweight = earthweight * 0.17;  
   
    System.out.println(earthweight + " earth-pounds is equivalent to " +  
                       moonweight + " moon-pounds.");    
   
  }    
}

listing 2
/*  
   This program displays a conversion  
   table of inches to meters. 
 
   Call this program InchToMeterTable.java. 
*/  
class InchToMeterTable {  
  public static void main(String args[]) {  
    double inches, meters; 
    int counter; 
 
    counter = 0; 
    for(inches = 1; inches <= 144; inches++) { 
      meters = inches / 39.37; // convert to meters 
      System.out.println(inches + " inches is " + 
                         meters + " meters."); 
 
      counter++; 
      // every 12th line, print a blank line        
      if(counter == 12) { 
        System.out.println(); 
        counter = 0; // reset the line counter 
      } 
    } 
  }  
}

listing 1
// Find prime numbers between 2 and 100. 
class Prime {    
  public static void main(String args[]) {    
    int i, j; 
    boolean isprime; 
 
    for(i=2; i < 100; i++) { 
      isprime = true;  
 
      // see if the number is evenly divisible 
      for(j=2; j <= i/j; j++) 
        // if it is, then its not prime 
        if((i%j) == 0) isprime = false; 
 
      if(isprime) 
        System.out.println(i + " is prime."); 
    } 
  }    
} 


 
listing 1
// Count spaces. 
class Spaces { 
  public static void main(String args[])  
    throws java.io.IOException { 
 
    char ch; 
    int spaces = 0; 
 
 
    System.out.println("Enter a period to stop."); 
 
    do { 
      ch = (char) System.in.read(); 
      if(ch == ' ') spaces++; 
    } while(ch != '.'); 
 
    System.out.println("Spaces: " + spaces); 
  } 
}

listing 2
// Change case. 
class CaseChg { 
  public static void main(String args[])  
    throws java.io.IOException { 
    char ch; 
    int changes = 0; 
 
    System.out.println("Enter period to stop."); 
 
    do { 
      ch = (char) System.in.read(); 
      if(ch >= 'a' & ch <= 'z') { 
        ch -= 32; 
        changes++; 
        System.out.println(ch); 
      } 
      else if(ch >= 'A' & ch <= 'Z') { 
        ch += 32; 
        changes++; 
        System.out.println(ch); 
      } 
    } while(ch != '.'); 
    System.out.println("Case changes: " + changes); 
  } 
}

listing 1
// Average 10 double values. 
class Avg { 
  public static void main(String args[]) { 
    double nums[] = { 1.1, 2.2, 3.3, 4.4, 5.5, 
                      6.6, 7.7, 8.8, 9.9, 10.1 }; 
    double sum = 0; 
 
    for(int i=0; i < nums.length; i++) 
      sum += nums[i]; 
 
    System.out.println("Average: " + sum / nums.length); 
  } 
}

listing 2
// Demonstrate the Bubble sort with strings.  
class StrBubble {   
  public static void main(String args[]) {   
    String strs[] = { 
                     "this", "is", "a", "test", 
                     "of", "a", "string", "sort"  
                    }; 
    int a, b; 
    String t;   
    int size;   
   
    size = strs.length; // number of elements to sort   
   
    // display original array   
    System.out.print("Original array is:");  
    for(int i=0; i < size; i++)  
      System.out.print(" " + strs[i]);   
    System.out.println();   
   
    // This is the bubble sort for strings.   
    for(a=1; a < size; a++)   
      for(b=size-1; b >= a; b--) {   
        if(strs[b-1].compareTo(strs[b]) > 0) { // if out of order   
          // exchange elements    
          t = strs[b-1];   
          strs[b-1] = strs[b];   
          strs[b] = t;   
        }   
      }   
   
    // display sorted array   
    System.out.print("Sorted array is:");   
    for(int i=0; i < size; i++)  
      System.out.print(" " + strs[i]);   
    System.out.println();  
  }  
}

listing 3
// An improved XOR cipher. 
class Encode {   
  public static void main(String args[]) {  
    String msg = "This is a test";   
    String encmsg = "";  
    String decmsg = "";  
    String key = "abcdefgi";  
    int j; 
 
    System.out.print("Original message: ");  
    System.out.println(msg);  
  
    // encode the message  
    j = 0; 
    for(int i=0; i < msg.length(); i++) { 
      encmsg = encmsg + (char) (msg.charAt(i) ^ key.charAt(j)); 
      j++; 
      if(j==8) j = 0; 
    }  
  
    System.out.print("Encoded message: ");  
    System.out.println(encmsg);  
  
    // decode the message  
    j = 0; 
    for(int i=0; i < msg.length(); i++) { 
      decmsg = decmsg + (char) (encmsg.charAt(i) ^ key.charAt(j)); 
      j++; 
      if(j==8) j = 0; 
    }  
     
    System.out.print("Decoded message: ");  
    System.out.println(decmsg);  
 
  }  
}

listing 4
// Find the minimum and maximum values in an array. 
class MinMax {  
  public static void main(String args[]) {  
    int nums[] = new int[10]; 
    int min, max; 
 
    nums[0] = 99; 
    nums[1] = -10; 
    nums[2] = 100123; 
    nums[3] = 18; 
    nums[4] = -978; 
    nums[5] = 5623; 
    nums[6] = 463; 
    nums[7] = -9; 
    nums[8] = 287; 
    nums[9] = 49; 
 
    min = max = nums[0]; 
    // Use a for-each style for loop.
    for(int v : nums) { 
      if(v < min) min = v; 
      if(v > max) max = v; 
    } 
    System.out.println("min and max: " + min + " " + max); 
  }  
}

 
listing 1
// A stack class for characters.  
class Stack {  
  private char stck[]; // this array holds the stack 
  private int tos;  // top of stack 
  
  // Construct an empty Stack given its size. 
  Stack(int size) {  
    stck = new char[size]; // allocate memory for stack 
    tos = 0;  
  }  
 
  // Construct a Stack from a Stack. 
  Stack(Stack ob) { 
    tos = ob.tos; 
    stck = new char[ob.stck.length]; 
 
    // copy elements 
    for(int i=0; i < tos; i++) 
      stck[i] = ob.stck[i]; 
  } 
 
  // Construct a stack with initial values. 
  Stack(char a[]) { 
    stck = new char[a.length]; 
 
    for(int i = 0; i < a.length; i++) { 
      push(a[i]); 
    }     
  } 
 
    
  // Push characters onto the stack. 
  void push(char ch) {  
    if(tos==stck.length) {  
      System.out.println(" -- Stack is full.");  
      return;  
    }  
      
    stck[tos] = ch; 
    tos++; 
  }  
  
  // Pop a character from the stack. 
  char pop() {  
    if(tos==0) {  
      System.out.println(" -- Stack is empty.");  
      return (char) 0;   
    }  
    
    tos--;  
    return stck[tos];  
  }  
}  
  
// Demonstrate the Stack class.  
class SDemo {  
  public static void main(String args[]) {  
    // construct 10-element empty stack 
    Stack stk1 = new Stack(10);  
 
    char name[] = {'T', 'o', 'm'};  
   
    // construct stack from array 
    Stack stk2 = new Stack(name);  
 
    char ch;  
    int i;  
  
    // put some characters into stk1  
    for(i=0; i < 10; i++)  
      stk1.push((char) ('A' + i));  
 
    // construct stack from another stack 
    Stack stk3 = new Stack(stk1); 
 
    //show the stacks. 
    System.out.print("Contents of stk1: ");  
    for(i=0; i < 10; i++) {   
      ch = stk1.pop();  
      System.out.print(ch);  
    }  
  
    System.out.println("\n");  
  
    System.out.print("Contents of stk2: ");  
    for(i=0; i < 3; i++) {   
      ch = stk2.pop();  
      System.out.print(ch);  
    }  
  
    System.out.println("\n");  
  
    System.out.print("Contents of stk3: ");  
    for(i=0; i < 10; i++) {   
      ch = stk3.pop();  
      System.out.print(ch);  
    }  
  }  
}

listing 2
void swap(Test ob1, Test ob2) { 
  int t; 
 
  t = ob1.a; 
  ob1.a = ob2.a; 
  ob2.a = t; 
}

listing 3
// Display a string backwards using recursion. 
class Backwards { 
  String str; 
 
  Backwards(String s) { 
    str = s; 
  } 
 
  void backward(int idx) { 
    if(idx != str.length()-1) backward(idx+1); 
 
    System.out.print(str.charAt(idx)); 
  } 
} 
 
class BWDemo { 
  public static void main(String args[]) { 
    Backwards s = new Backwards("This is a test"); 
 
    s.backward(0); 
  } 
}

listing 4
class SumIt {
  int sum(int ... n) {
    int result = 0;

    for(int i = 0; i < n.length; i++)
      result += n[i];

    return result;
  }
}

class SumDemo {
  public static void main(String args[]) {

    SumIt siObj = new SumIt();

    int total = siObj.sum(1, 2, 3);
    System.out.println("Sum is " + total);

    total = siObj.sum(1, 2, 3, 4, 5);
    System.out.println("Sum is " + total);
  }
}
 

listing 1
// A subclass of TwoDShape for circles. 
class Circle extends TwoDShape { 
  // A default constructor.
  Circle() {
    super();
  }

  // Construct Circle
  Circle(double x) {
    super(x, "circle"); // call superclass constructor
  }

  // Construct an object from an object.
  Circle(Circle ob) {
    super(ob); // pass object to TwoDShape constructor
  }
   
  double area() { 
    return (getWidth() / 2) * (getWidth() / 2) * 3.1416;
  } 
}
 

listing 1
interface IVehicle {
  // Return the range.   
  int range(); 
 
  // Compute fuel needed for a given distance.  
  double fuelneeded(int miles);  
 
  // Access methods for instance variables. 
  int getPassengers(); 
  void setPassengers(int p);  
  int getFuelcap(); 
  void setFuelcap(int f);  
  int getMpg(); 
  void setMpg(int m);  
}

 
listing 1
// An exception for stack-full errors.  
class StackFullException extends Exception {  
  int size;  
    
  StackFullException(int s) { size = s; }  
  
  public String toString() {  
   return "\nStack is full. Maximum size is " +  
           size;  
  }  
}  
  
// An exception for stack-empty errors.  
class StackEmptyException extends Exception {  
  
  public String toString() {  
   return "\nStack is empty.";  
  }  
}  
  
// A stack class for characters.    
class Stack {    
  private char stck[]; // this array holds the stack   
  private int tos;  // top of stack   
    
  // Construct an empty Stack given its size.   
  Stack(int size) {    
    stck = new char[size]; // allocate memory for stack   
    tos = 0;    
  }    
   
  // Construct a Stack from a Stack.   
  Stack(Stack ob) {   
    tos = ob.tos;   
    stck = new char[ob.stck.length];   
   
    // copy elements   
    for(int i=0; i < tos; i++)   
      stck[i] = ob.stck[i];   
  }   
   
  // Construct a stack with initial values.   
  Stack(char a[]) {   
    stck = new char[a.length];   
   
    for(int i = 0; i < a.length; i++) {   
      try {  
        push(a[i]);   
      }   
      catch(StackFullException exc) {  
        System.out.println(exc);  
      }  
    }       
  }   
      
  // Push characters onto the stack.   
  void push(char ch) throws StackFullException {    
    if(tos==stck.length)  
      throw new StackFullException(stck.length);  
 
    stck[tos] = ch;   
    tos++;   
  }    
    
  // Pop a character from the stack.   
  char pop() throws StackEmptyException {    
    if(tos==0)    
      throw new StackEmptyException();  
      
    tos--;    
    return stck[tos];    
  }    
}

listing 1
/* Copy a text file, substituting hyphens for spaces. 
  
   This version uses byte streams. 
 
   To use this program, specify the name   
   of the source file and the destination file.  
   For example, 
  
   java Hyphen source target 
*/  
 
import java.io.*; 
 
class Hyphen { 
  public static void main(String args[])  
  { 
    int i; 
    FileInputStream fin; 
    FileOutputStream fout; 

    // First make sure that both files have been specified.
    if(args.length !=2 ) {
      System.out.println("Usage: CopyFile From To"); 
      return;
    }
 
    // open input file 
    try { 
      fin = new FileInputStream(args[0]); 
    } catch(FileNotFoundException exc) { 
      System.out.println("Input File Not Found"); 
      return; 
    } 
 
    // open output file 
    try { 
      fout = new FileOutputStream(args[1]); 
    } catch(FileNotFoundException exc) { 
      System.out.println("Error Opening Output File"); 

      // Close the open input file.
      try {
        fin.close();
      } catch(IOException exc2) { 
        System.out.println("Error closing input file."); 
      } 
      return; 
    } 

    // Copy File 
    try { 
      do { 
        i = fin.read(); 

        // convert space to a hypen
        if((char)i == ' ') i = '-'; 

        if(i != -1) fout.write(i); 
      } while(i != -1); 
    } catch(IOException exc) { 
      System.out.println("File Error"); 
    } 
 
    try {
      fin.close(); 
    } catch(IOException exc) { 
      System.out.println("Error closing input file."); 
    } 

    try {
      fout.close(); 
    } catch(IOException exc) { 
      System.out.println("Error closing output file."); 
    } 

  } 
}

listing 2
/* Copy a text file, substituting hyphens for spaces. 
  
   This version uses character streams. 
 
   To use this program, specify the name   
   of the source file and the destination file.  
   For example, 
  
   java Hyphen2 source target 
*/  
  
import java.io.*;  
  
class Hyphen2 {  
  public static void main(String args[])   
    throws IOException  
  {  
    int i;  
    FileReader fin;  
    FileWriter fout;  
  
    // First make sure that both files have been specified.
    if(args.length !=2 ) {
      System.out.println("Usage: CopyFile From To"); 
      return;
    }

    // open input file  
    try {  
      fin = new FileReader(args[0]); 
    } catch(FileNotFoundException exc) {  
      System.out.println("Input File Not Found");  
      return;  
    }  
  
    // open output file  
    try {  
      fout = new FileWriter(args[1]);  
    } catch(IOException exc) {  
      System.out.println("Error Opening Output File");  

      // Close the open input file.
      try {
        fin.close();
      } catch(IOException exc2) { 
        System.out.println("Error closing input file."); 
      } 

      return;  
    }  
  
    // Copy File  
    try {  
      do {  
        i = fin.read();  

        // convert space to a hypen
        if((char)i == ' ') i = '-'; 

        if(i != -1) fout.write(i);  
      } while(i != -1);  
    } catch(IOException exc) {  
      System.out.println("File Error");  
    }  
  
    try {
      fin.close(); 
    } catch(IOException exc) { 
      System.out.println("Error closing input file."); 
    } 

    try {
      fout.close(); 
    } catch(IOException exc) { 
      System.out.println("Error closing output file."); 
    } 

  }  
}

 
listing 1
// Make the TickTock class actually keep time.
 
class TickTock { 

  String state; // contains the state of the clock
 
  synchronized void tick(boolean running) { 
    if(!running) { // stop the clock 
      state = "ticked";
      notify(); // notify any waiting threads 
      return; 
    } 
 
    System.out.print("Tick "); 

    // wait 1/2 second
    try {
      Thread.sleep(500);
    } catch(InterruptedException exc) {
      System.out.println("Thread interrupted.");
    }

    state = "ticked"; // set the current state to ticked

    notify(); // let tock() run 
    try { 
      while(!state.equals("tocked"))
        wait(); // wait for tock() to complete 
    } 
    catch(InterruptedException exc) { 
      System.out.println("Thread interrupted."); 
    } 
  } 
 
  synchronized void tock(boolean running) { 
    if(!running) { // stop the clock 
      state = "tocked";
      notify(); // notify any waiting threads 
      return; 
    } 
 
    System.out.println("Tock"); 

    // wait 1/2 second
    try {
      Thread.sleep(500);
    } catch(InterruptedException exc) {
      System.out.println("Thread interrupted.");
    }

    state = "tocked"; // set the current state to tocked

    notify(); // let tick() run 
    try { 
      while(!state.equals("ticked"))
        wait(); // wait for tick to complete 
    } 
    catch(InterruptedException exc) { 
      System.out.println("Thread interrupted."); 
    } 
  } 
}  
 
listing 1
enum Tools { 
  SCREWDRIVER, WRENCH, HAMMER, PLIERS  
} 
 
class ShowEnum { 
  public static void main(String args[]) { 
    for(Tools d : Tools.values())  
      System.out.print(d + " has ordinal value of " + 
                       d.ordinal() + '\n'); 
       
  } 
}

listing 2
// An improved version of the traffic light simulation that 
// stores the light delay in TrafficLightColor. 
 
// An enumeration of the colors of a traffic light. 
enum TrafficLightColor {  
  RED(12000), GREEN(10000), YELLOW(2000); 
 
  private int delay; 
 
  TrafficLightColor(int d) { 
    delay = d; 
  } 
 
  int getDelay() { return delay; } 
} 
 
// A computerized traffic light. 
class TrafficLightSimulator implements Runnable { 
  private Thread thrd; // holds the thread that runs the simulation 
  private TrafficLightColor tlc; // holds the current traffic light color 
  boolean stop = false; // set to true to stop the simulation 
  boolean changed = false; // true when the light has changed
 
  TrafficLightSimulator(TrafficLightColor init) {  
    tlc = init; 
 
    thrd = new Thread(this); 
    thrd.start(); 
  } 
 
  TrafficLightSimulator() {  
    tlc = TrafficLightColor.RED; 
 
    thrd = new Thread(this); 
    thrd.start(); 
  } 
 
  // Start up the light. 
  public void run() { 
    while(!stop) { 
 
      // Notice how this code has been simplified! 
      try { 
        Thread.sleep(tlc.getDelay()); 
      } catch(InterruptedException exc) { 
        System.out.println(exc); 
      } 
 
      changeColor(); 
    }  
  } 
 
  // Change color. 
  synchronized void changeColor() { 
    switch(tlc) { 
      case RED: 
        tlc = TrafficLightColor.GREEN; 
        break; 
      case YELLOW: 
        tlc = TrafficLightColor.RED; 
        break; 
      case GREEN: 
       tlc = TrafficLightColor.YELLOW; 
    } 

    changed = true; 
    notify(); // signal that the light has changed 
  } 
 
  // Wait until a light change occurs. 
  synchronized void waitForChange() { 
    try { 
      while(!changed)
        wait(); // wait for light to change 
      changed = false;
    } catch(InterruptedException exc) { 
      System.out.println(exc); 
    } 
  } 
 
  // Return current color. 
  TrafficLightColor getColor() { 
    return tlc; 
  } 
 
  // Stop the traffic light. 
  void cancel() { 
    stop = true; 
  } 
}  
  
class TrafficLightDemo {  
  public static void main(String args[]) {  
    TrafficLightSimulator tl =
      new TrafficLightSimulator(TrafficLightColor.GREEN); 
 
    for(int i=0; i < 9; i++) { 
      System.out.println(tl.getColor()); 
      tl.waitForChange(); 
    } 
 
    tl.cancel(); 
  }  
}

 
listing 1
// A generic stack. 
 
interface IGenStack<T> { 
  void push(T obj) throws StackFullException; 
  T pop() throws StackEmptyException; 
} 
 
// An exception for stack-full errors.   
class StackFullException extends Exception {   
  int size;   
     
  StackFullException(int s) { size = s; }   
   
  public String toString() {   
   return "\nStack is full. Maximum size is " +   
           size;   
  }   
}   
   
// An exception for stack-empty errors.   
class StackEmptyException extends Exception { 
   
  public String toString() {   
   return "\nStack is empty.";   
  }   
}   
   
// A stack class for characters.     
class GenStack<T> implements IGenStack<T> {  
  private T stck[]; // this array holds the stack    
  private int tos;  // top of stack    
     
  // Construct an empty Stack given its size.    
  GenStack(T[] stckArray) {     
    stck = stckArray; 
    tos = 0;     
  }     
    
  // Construct a Stack from a Stack.    
  GenStack(T[] stckArray, GenStack<T> ob) { 
 
    tos = ob.tos;    
    stck = stckArray; 
 
    try { 
      if(stck.length < ob.stck.length) 
        throw new StackFullException(stck.length); 
    } 
    catch(StackFullException exc) {   
      System.out.println(exc);   
    }   
    
    // Copy elements. 
    for(int i=0; i < tos; i++)    
      stck[i] = ob.stck[i];    
  }    
    
  // Construct a stack with initial values.    
  GenStack(T[] stckArray, T[] a) {    
    stck = stckArray; 
    
    for(int i = 0; i < a.length; i++) {    
      try {   
        push(a[i]);    
      }    
      catch(StackFullException exc) {   
        System.out.println(exc);   
      }   
    }        
  }    
       
  // Push objects onto the stack.    
  public void push(T obj) throws StackFullException {     
    if(tos==stck.length)   
      throw new StackFullException(stck.length);   
  
    stck[tos] = obj;    
    tos++;    
  }     
     
  // Pop an object from the stack.    
  public T pop() throws StackEmptyException {     
    if(tos==0)     
      throw new StackEmptyException();   
       
    tos--;     
    return stck[tos];     
  }     
} 
 
// Demonstrate the Stack class.   
class GenStackDemo {   
  public static void main(String args[]) {   
    // Construct 10-element empty Integer stack. 
    Integer iStore[] = new Integer[10]; 
    GenStack<Integer> stk1 = new GenStack<Integer>(iStore); 
  
    // Construct stack from array. 
    String name[] = {"One", "Two", "Three"};   
    String strStore[] = new String[3]; 
    GenStack<String> stk2 = 
        new GenStack<String>(strStore, name); 
  
    String str; 
    int n;   
 
    try { 
   
      // Put some values into stk1. 
      for(int i=0; i < 10; i++)   
        stk1.push(i); 
    } catch(StackFullException exc) { 
      System.out.println(exc); 
    } 
  
    // Construct stack from another stack. 
    String strStore2[] = new String[3]; 
    GenStack<String> stk3 =  
        new GenStack<String>(strStore2, stk2);  
 
    try {  
      // Show the stacks.  
      System.out.print("Contents of stk1: ");   
      for(int i=0; i < 10; i++) {    
        n = stk1.pop();   
        System.out.print(n + " ");   
      }   
   
      System.out.println("\n");   
   
      System.out.print("Contents of stk2: ");   
      for(int i=0; i < 3; i++) {    
        str = stk2.pop();   
        System.out.print(str + " "); 
      }   
   
      System.out.println("\n");   
   
      System.out.print("Contents of stk3: ");   
      for(int i=0; i < 3; i++) {    
        str = stk3.pop(); 
        System.out.print(str + " "); 
      }   
 
    } catch(StackEmptyException exc) { 
      System.out.println(exc); 
    } 
 
    System.out.println(); 
  }   
}

 
listing 1
/* A simple banner applet that uses parameters. 
  
*/  
import java.awt.*;  
import java.applet.*;  
/*  
<applet code="ParamBanner" width=300 height=50>  
<param name=message value=" I like Java! ">  
<param name=delay value=500>  
</applet>  
*/  
  
public class ParamBanner extends Applet implements Runnable {  
  String msg; 
  int delay;  
  Thread t;  
  boolean stopFlag;  
  
  // Initialize t to null.   
  public void init() {  
    String temp; 
 
    msg = getParameter("message");  
    if(msg == null) msg = " Java Rules the Web ";  
  
    temp = getParameter("delay");  
    try {  
      if(temp != null)  
        delay = Integer.parseInt(temp);  
      else  
        delay = 250; // default if not specified 
    } catch(NumberFormatException exc) {  
        delay = 250 ; // default on error 
    }  
     
    t = null;  
  }  
  
  // Start thread  
  public void start() {  
    t = new Thread(this);  
    stopFlag = false;  
    t.start();  
  }  
  
  // Entry point for the thread that runs the banner.  
  public void run() {  
    char ch;  
  
    // Display banner   
    for( ; ; ) {  
      try {  
        repaint();  
        Thread.sleep(delay);  
        ch = msg.charAt(0);  
        msg = msg.substring(1, msg.length());  
        msg += ch;  
        if(stopFlag)  
          break;  
      } catch(InterruptedException exc) {}  
    }  
  }  
  
  // Pause the banner.  
  public void stop() {  
    stopFlag = true;  
    t = null;  
  }  
  
  // Display the banner.  
  public void paint(Graphics g) {  
    g.drawString(msg, 50, 30);  
  }  
}

listing 2
// A simple clock applet. 
 
import java.util.*; 
import java.awt.*;  
import java.applet.*;  
/*  
<object code="Clock" width=200 height=50>  
</object>  
*/  
  
public class Clock extends Applet implements Runnable {  
  String msg; 
  Thread t;  
  Calendar clock; 
 
  boolean stopFlag;  
  
  // Initialize 
  public void init() {  
    t = null;  
    msg = ""; 
  }  
  
  // Start thread  
  public void start() {  
    t = new Thread(this);  
    stopFlag = false; 
    t.start();  
  }  
  
  // Entry point for the clock. 
  public void run() {  
    // Display clock   
    for( ; ; ) {  
      try {  
        clock = Calendar.getInstance(); 
        msg = "Current time is " + 
              Integer.toString(clock.get(Calendar.HOUR));  
        msg = msg + ":" + 
              Integer.toString(clock.get(Calendar.MINUTE)); 
        msg = msg + ":" + 
              Integer.toString(clock.get(Calendar.SECOND)); 
        repaint();  
        Thread.sleep(1000);  
        if(stopFlag)  
          break;  
      } catch(InterruptedException exc) {}  
    }  
  }  
  
  // Pause the clock.  
  public void stop() {  
    stopFlag = true;  
    t = null;  
  }  
  
  // Display the clock.  
  public void paint(Graphics g) {  
    g.drawString(msg, 30, 30);  
  }  
}

listing 3
/* Track mouse motion by drawing a line 
   when a mouse button is pressed. */ 
 
import java.awt.*;  
import java.awt.event.*;  
import java.applet.*;  
/*  
  <applet code="TrackM" width=300 height=100>  
  </applet>  
*/  
  
public class TrackM extends Applet  
  implements MouseListener, MouseMotionListener {  
  
  int curX = 0, curY = 0; // current coordinates 
  int oldX = 0, oldY = 0; // previous coordinates 
  boolean draw; 
  
  public void init() {  
     addMouseListener(this);  
     addMouseMotionListener(this);  
     draw = false; 
  }  
 
  /* The next three methods are not used, but must 
     be null-implemented because they are defined  
     by MouseListener. */ 
  
  // Handle mouse entered.  
  public void mouseEntered(MouseEvent me) {  
  }  
  
  // Handle mouse exited.  
  public void mouseExited(MouseEvent me) {  
  }  
 
  // Handle mouse click.  
  public void mouseClicked(MouseEvent me) {  
  }  
  
  // Handle button pressed.  
  public void mousePressed(MouseEvent me) {  
    // save coordinates  
    oldX = me.getX();  
    oldY = me.getY();  
    draw = true; 
  }  
  
  // Handle button released.  
  public void mouseReleased(MouseEvent me) {  
    draw = false; 
  }  
  
  // Handle mouse dragged.  
  public void mouseDragged(MouseEvent me) {  
    // save coordinates  
    curX = me.getX();  
    curY = me.getY();  
    repaint();  
  }  
  
  // Handle mouse moved.  
  public void mouseMoved(MouseEvent me) {  
    // show status  
    showStatus("Moving mouse at " + me.getX() + ", " + me.getY());  
  }  
  
  // Display line in applet window. 
  public void paint(Graphics g) {  
    if(draw) 
     g.drawLine(oldX, oldY, curX, curY); 
  }  
}

listing 1
/* 
     Project 15-1 
 
     A Swing-based file comparison utility. 
 
     This version has a check box that causes the 
     location of the first mismatch to be shown. 
*/ 
 
import java.awt.*; 
import java.awt.event.*; 
import javax.swing.*; 
import java.io.*; 
  
class SwingFC implements ActionListener { 
 
  JTextField jtfFirst;  // holds the first file name 
  JTextField jtfSecond; // holds the second file name 
 
  JButton jbtnComp; // button to compare the files 
 
  JLabel jlabFirst, jlabSecond; // displays prompts  
  JLabel jlabResult; // displays results and error messages 
 
  JCheckBox jcbLoc; // check to display location of mismatch 
 
  SwingFC() { 
 
    // Create a new JFrame container. 
    JFrame jfrm = new JFrame("Compare Files"); 
 
    // Specify FlowLayout for the layout manager. 
    jfrm.setLayout(new FlowLayout()); 
 
    // Give the frame an initial size. 
    jfrm.setSize(200, 220); 
 
    // Terminate the program when the user closes the application. 
    jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
 
    // Create the text fields for the file names.. 
    jtfFirst = new JTextField(14); 
    jtfSecond = new JTextField(14); 
 
    // Set the action commands for the text fields. 
    jtfFirst.setActionCommand("fileA"); 
    jtfSecond.setActionCommand("fileB"); 
 
    // Create the Compare button. 
    JButton jbtnComp = new JButton("Compare"); 
 
    // Add action listener for the Compare button. 
    jbtnComp.addActionListener(this); 
 
    // Create the labels. 
    jlabFirst = new JLabel("First file: "); 
    jlabSecond = new JLabel("Second file: "); 
    jlabResult = new JLabel(""); 
 
    // Create check box. 
    jcbLoc = new JCheckBox("Show position of mismatch"); 
 
    // Add the components to the content pane. 
    jfrm.add(jlabFirst); 
    jfrm.add(jtfFirst);  
    jfrm.add(jlabSecond); 
    jfrm.add(jtfSecond);  
    jfrm.add(jcbLoc); 
    jfrm.add(jbtnComp);  
    jfrm.add(jlabResult); 
 
    // Display the frame. 
    jfrm.setVisible(true); 
  } 
 
  // Compare the files when the Compare button is pressed. 
  public void actionPerformed(ActionEvent ae) { 
    int i=0, j=0;   
    int count = 0; 
    FileInputStream f1;   
    FileInputStream f2;   
   
    // First, confirm that both file names have 
    // been entered. 
    if(jtfFirst.getText().equals("")) { 
      jlabResult.setText("First file name missing."); 
      return; 
    } 
    if(jtfSecond.getText().equals("")) { 
      jlabResult.setText("Second file name missing."); 
      return; 
    } 
 
    // Open first file. 
    try {   
      f1 = new FileInputStream(jtfFirst.getText());   
    } catch(FileNotFoundException exc) {   
      jlabResult.setText("First file not found.");   
      return;   
    }   
   
    // Open second file. 
    try {   
      f2 = new FileInputStream(jtfSecond.getText());   
    } catch(FileNotFoundException exc) {   
      jlabResult.setText("Second file not found.");   

      // Close the first file if the second file
      // cannot be opened.
      try {
        f1.close();
      } catch(IOException exc2) { 
        jlabResult.setText("Cannot close first file."); 
      } 

      return;   
    }   
   
    // Compare files. 
    try {   
      do {   
        i = f1.read();   
        j = f2.read();   
        if(i != j) break;  
        count++;
      } while(i != -1 && j != -1);   
   
      if(i != j) { 
        if(jcbLoc.isSelected()) 
          jlabResult.setText("Files differ at location " + count); 
        else 
          jlabResult.setText("Files are not the same."); 
      }  
      else  
        jlabResult.setText("Files compare equal.");  

    } catch(IOException exc) {   
      jlabResult.setText("File Error");   
    }   

    try {
      f1.close();  
    } catch(IOException exc) { 
      jlabResult.setText("Error closing first file.");
    } 

    try {
      f2.close();  
    } catch(IOException exc) { 
      jlabResult.setText("Error closing second file."); 
    } 
 
  } 
 
  public static void main(String args[]) { 
    // Create the frame on the event dispatching thread. 
    SwingUtilities.invokeLater(new Runnable() { 
      public void run() { 
        new SwingFC(); 
      } 
    }); 
  } 
}

listing 2
// Demonstrate multiple selectin in a JList. 
  
import javax.swing.*;  
import javax.swing.event.*; 
import java.awt.*; 
import java.awt.event.*; 
   
class ListDemo implements ListSelectionListener {  
  
  JList jlst; 
  JLabel jlab; 
  JScrollPane jscrlp; 
 
  // Create an array of names. 
  String names[] = { "Sherry", "Jon", "Rachel",  
                     "Sasha", "Josselyn",  "Randy", 
                     "Tom", "Mary", "Ken", 
                     "Andrew", "Matt", "Todd" }; 
 
  ListDemo() {  
    // Create a new JFrame container.  
    JFrame jfrm = new JFrame("JList Demo");  
 
    // Specify a flow Layout. 
    jfrm.setLayout(new FlowLayout());  
 
    // Give the frame an initial size.  
    jfrm.setSize(200, 160);  
  
    // Terminate the program when the user closes the application.  
    jfrm.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  
  
    // Create a JList. 
    jlst = new JList(names); 
 
    // By removing the following line, multiple selection (which 
    // is the the default behavior of a JList) will be used. 
//    jlst.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); 
 
    // Add list to a scroll pane. 
    jscrlp = new JScrollPane(jlst); 
 
    // Set the preferred size of the scroll pane. 
    jscrlp.setPreferredSize(new Dimension(120, 90)); 
 
    // Make a label that displays the selection. 
    jlab = new JLabel("Please choose a name"); 
 
    // Add list selection handler. 
    jlst.addListSelectionListener(this); 
 
    // Add the list and label to the content pane. 
    jfrm.add(jscrlp); 
    jfrm.add(jlab); 
  
    // Display the frame.  
    jfrm.setVisible(true);  
  }  
 
  // Handle list selection events. 
  public void valueChanged(ListSelectionEvent le) {  
    // Get the indices of the changed item. 
    int indices[] = jlst.getSelectedIndices(); 
 
    // Display the selections, if one or more items 
    // was selected. 
    if(indices.length != 0) { 
      String who = ""; 
 
      // Construct a string of the names. 
      for(int i : indices) 
        who += names[i] + " "; 
         
      jlab.setText("Current selections: " + who); 
    } 
    else // Othewise, reprompt. 
      jlab.setText("Please choose an name"); 
  }  
 
  public static void main(String args[]) {  
    // Create the frame on the event dispatching thread.  
    SwingUtilities.invokeLater(new Runnable() {  
      public void run() {  
        new ListDemo();  
      }  
    });   
  }  
}

 
listing 1

import java.io.*;

/**
 * This class demonstrates documentation comments.
 * @author Herbert Schildt
 * @version 1.2
*/
public class SquareNum {
  /**
   * This method returns the square of num.
   * This is a multiline description.  You can use
   * as many lines as you like.
   * @param num The value to be squared.
   * @return num squared.
  */
  public double square(double num) {
    return num * num;
  }

  /**
   * This method inputs a number from the user.
   * @return The value input as a double.
   * @exception IOException On input error.
   * @see IOException 
  */
  public double getNumber() throws IOException {
    // create a BufferedReader using System.in
    InputStreamReader isr = new InputStreamReader(System.in);
    BufferedReader inData = new BufferedReader(isr);
    String str;

    str = inData.readLine();
    return (new Double(str)).doubleValue();
  }

  /**
   * This method demonstrates square().
   * @param args Unused.
   * @exception IOException On input error.
   * @see IOException
  */
  public static void main(String args[]) 
    throws IOException 
  {
    SquareNum ob = new SquareNum();
    double val;

    System.out.println("Enter value to be squared: ");
    val = ob.getNumber();
    val = ob.square(val);

    System.out.println("Squared value is " + val);
  }
}
 


--0--

These files contain all of the code listings in

  Java 2: The Complete Reference, 5th Edition

The source code is organized into files by chapter.
Within each chapter file, the listings are stored
in the same order as they appear in the book.
Simply edit the appropriate file to extract the
listing in which you are interested.

The code for Scrabblet is in its own ZIP file,
called CHAP32.ZIP.


/*************** 
 * Chapter  2  *
 ***************/

 listing 1
/*
   This is a simple Java program.
   Call this file "Example.java".
*/
class Example {
  // Your program begins with a call to main().
  public static void main(String args[]) {
    System.out.println("This is a simple Java program.");
  }
}

listing 2
/*
   This is a simple Java program.
   Call this file "Example.java".
*/

listing 3
class Example {

listing 4
// Your program begins with a call to main().

listing 5
/*
   Here is another short example.
   Call this file "Example2.java".
*/
class Example2 {
  public static void main(String args[]) {
    int num; // this declares a variable called num

    num = 100; // this assigns num the value 100

    System.out.println("This is num: " + num);

    num = num * 2;

    System.out.print("The value of num * 2 is ");
    System.out.println(num);
  }
}

listing 6
int num; // this declares a variable called num

listing 7
num = 100; // this assigns num the value 100

listing 8
System.out.println("This is num: " + num);

listing 9
System.out.print("The value of num * 2 is ");
System.out.println(num);

listing 10
/*
  Demonstrate the if.
  
  Call this file "IfSample.java".
*/
class IfSample {
  public static void main(String args[]) {
    int x, y;

    x = 10;
    y = 20;

    if(x < y) System.out.println("x is less than y");
    
    x = x * 2;
    if(x == y) System.out.println("x now equal to y");

    x = x * 2;
    if(x > y) System.out.println("x now greater than y");

    // this won't display anything
    if(x == y) System.out.println("you won't see this");
  }
}

listing 11
int x, y;

listing 12
/*
  Demonstrate the for loop.
  
  Call this file "ForTest.java".
*/
class ForTest {
  public static void main(String args[]) {
    int x;
  
    for(x = 0; x<10; x = x+1)
      System.out.println("This is x: " + x);
  }
}

listing 13
x = x + 1;

listing 14
for(x = 0; x<10; x++)

listing 15
/*
  Demonstrate a block of code.
  
  Call this file "BlockTest.java"
*/
class BlockTest {
  public static void main(String args[]) {
    int x, y;
  
    y = 20;

    // the target of this loop is a block
    for(x = 0; x<10; x++) {
      System.out.println("This is x: " + x);
      System.out.println("This is y: " + y);
      y = y - 2;
    }
  }
}


 
/*************** 
 * Chapter  3  *
 ***************/

 listing 1
byte b, c;

listing 2
short s;
short t;

listing 3
// Compute distance light travels using long variables.
class Light {
  public static void main(String args[]) {
    int lightspeed;
    long days;
    long seconds; 
    long distance;

    // approximate speed of light in miles per second
    lightspeed = 186000;

    days = 1000; // specify number of days here

    seconds = days * 24 * 60 * 60; // convert to seconds

    distance = lightspeed * seconds; // compute distance

    System.out.print("In " + days);
    System.out.print(" days light will travel about ");
    System.out.println(distance + " miles.");
  }
}

listing 4
float hightemp, lowtemp;

listing 5
// Compute the area of a circle.
class Area {
  public static void main(String args[]) {
    double pi, r, a; 

    r = 10.8; // radius of circle
    pi = 3.1416; // pi, approximately
    a = pi * r * r; // compute area

    System.out.println("Area of circle is " + a);
  }
}

listing 6
// Demonstrate char data type.
class CharDemo {
  public static void main(String args[]) {
    char ch1, ch2;

    ch1 = 88;  // code for X
    ch2 = 'Y';
    
    System.out.print("ch1 and ch2: ");
    System.out.println(ch1 + " " + ch2);
  }
}


listing 7
// char variables behave like integers. 
class CharDemo2 {
  public static void main(String args[]) {
    char ch1;

    ch1 = 'X';
    System.out.println("ch1 contains " + ch1);

    ch1++; // increment ch1
    System.out.println("ch1 is now " + ch1);
  }
}

listing 8
// Demonstrate boolean values.
class BoolTest {
  public static void main(String args[]) {
    boolean b;

    b = false;
    System.out.println("b is " + b);
    b = true;
    System.out.println("b is " + b);

    // a boolean value can control the if statement
    if(b) System.out.println("This is executed.");

    b = false;
    if(b) System.out.println("This is not executed.");

    // outcome of a relational operator is a boolean value
    System.out.println("10 > 9 is " + (10 > 9));
  }
}

listing 9
if(b == true) ...

listing 10
int a, b, c;            // declares three ints, a, b, and c.
int d = 3, e, f = 5;    // declares three more ints, initializing d and f.
byte z = 22;            // initializes z.
double pi = 3.14159;    // declares an approximation of pi.
char x = 'x';           // the variable x has the value 'x'.

listing 11
// Demonstrate dynamic initialization.
class DynInit {
    public static void main(String args[]) {
      double a = 3.0, b = 4.0;
      
      // c is dynamically initialized
      double c = Math.sqrt(a * a + b * b);

      System.out.println("Hypotenuse is " + c);
    }
}

listing 12
// Demonstrate block scope.
class Scope {
  public static void main(String args[]) {
    int x; // known to all code within main

    x = 10;
    if(x == 10) { // start new scope
      int y = 20; // known only to this block

      // x and y both known here.
      System.out.println("x and y: " + x + " " + y);
      x = y * 2;
    }
    // y = 100; // Error! y not known here 

    // x is still known here.
    System.out.println("x is " + x);
  }
}

listing 13
// This fragment is wrong!
count = 100; // oops!  cannot use count before it is declared!
int count; 

listing 14
// Demonstrate lifetime of a variable.
class LifeTime {
  public static void main(String args[]) {
    int x; 

    for(x = 0; x < 3; x++) {
      int y = -1; // y is initialized each time block is entered
      System.out.println("y iz: " + y); // this always prints -1
      y = 100; 
      System.out.println("y is now: " + y);
    }
  }
}

listing 15
// This program will not compile
class ScopeErr {
   public static void main(String args[]) {
     int bar = 1;
     {              // creates a new scope
       int bar = 2; // Compile time error -- bar already defined!
     }
   }
}

listing 16
int a;
byte b;
// ...
b = (byte) a;

listing 17
// Demonstrate casts.
class Conversion {
  public static void main(String args[]) {
    byte b;
    int i = 257;
    double d = 323.142;
    
    System.out.println("\nConversion of int to byte.");
    b = (byte) i;
    System.out.println("i and b " + i + " " + b);

    System.out.println("\nConversion of double to int.");
    i = (int) d;
    System.out.println("d and i " + d + " " + i);

    System.out.println("\nConversion of double to byte.");
    b = (byte) d;
    System.out.println("d and b " + d + " " + b);
  }
}

listing 18
byte a = 40;
byte b = 50;
byte c = 100;
int d = a * b / c;

listing 19
byte b = 50;
b = b * 2; // Error! Cannot assign an int to a byte!

listing 20
byte b = 50;
b = (byte)(b * 2);

listing 21
class Promote {
  public static void main(String args[]) {
    byte b = 42;
    char c = 'a';
    short s = 1024;
    int i = 50000;
    float f = 5.67f;
    double d = .1234;
    double result = (f * b) + (i / c) - (d * s);
    System.out.println((f * b) + " + " + (i / c) + " - " + (d * s));
    System.out.println("result = " + result);
  }
}

listing 22
double result = (f * b) + (i / c) - (d * s);

listing 23
int month_days[];

listing 24
month_days = new int[12];

listing 25
month_days[1] = 28;

listing 26
System.out.println(month_days[3]);

listing 27
// Demonstrate a one-dimensional array.
class Array {
  public static void main(String args[]) {
    int month_days[];
    month_days = new int[12];
    month_days[0] = 31;
    month_days[1] = 28;
    month_days[2] = 31;
    month_days[3] = 30;
    month_days[4] = 31;
    month_days[5] = 30;
    month_days[6] = 31;
    month_days[7] = 31;
    month_days[8] = 30;
    month_days[9] = 31;
    month_days[10] = 30;
    month_days[11] = 31;
    System.out.println("April has " + month_days[3] + " days.");
  }
}

listing 28
int month_days[] = new int[12];

listing 29
// An improvied version of the previous program.
class AutoArray {
  public static void main(String args[]) {
    int month_days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    System.out.println("April has " + month_days[3] + " days.");
  }
}

listing 30
// Average an array of values.
class Average {
  public static void main(String args[]) {
    double nums[] = {10.1, 11.2, 12.3, 13.4, 14.5};
    double result = 0;
    int i;
    
    for(i=0; i<5; i++) 
      result = result + nums[i];

    System.out.println("Average is " + result / 5);
  }
}

listing 31
int twoD[][] = new int[4][5];

listing 32
// Demonstrate a two-dimensional array.
class TwoDArray {
  public static void main(String args[]) {
    int twoD[][]= new int[4][5];
    int i, j, k = 0;

    for(i=0; i<4; i++) 
      for(j=0; j<5; j++) {
        twoD[i][j] = k;
        k++;
      }

    for(i=0; i<4; i++) {
      for(j=0; j<5; j++)
        System.out.print(twoD[i][j] + " ");
      System.out.println();
    }
  }
}

listing 33
int twoD[][] = new int[4][];
twoD[0] = new int[5];
twoD[1] = new int[5];
twoD[2] = new int[5];
twoD[3] = new int[5];

listing 34
// Manually allocate differing size second dimensions.
class TwoDAgain {
  public static void main(String args[]) {
    int twoD[][] = new int[4][];
    twoD[0] = new int[1];
    twoD[1] = new int[2];
    twoD[2] = new int[3];
    twoD[3] = new int[4];

    int i, j, k = 0;

    for(i=0; i<4; i++) 
      for(j=0; j<i+1; j++) {
        twoD[i][j] = k;
        k++;
      }

    for(i=0; i<4; i++) {
      for(j=0; j<i+1; j++)
        System.out.print(twoD[i][j] + " ");
      System.out.println();
    }
  }
}

listing 35
// Initialize a two-dimensional array.
class Matrix {
  public static void main(String args[]) {
    double m[][] = {
      { 0*0, 1*0, 2*0, 3*0 },
      { 0*1, 1*1, 2*1, 3*1 },
      { 0*2, 1*2, 2*2, 3*2 },
      { 0*3, 1*3, 2*3, 3*3 }
    };
    int i, j;

    for(i=0; i<4; i++) {
      for(j=0; j<4; j++)
        System.out.print(m[i][j] + " ");
      System.out.println();
    }
  }
}

listing 36
// Demonstrate a three-dimensional array.
class threeDMatrix {
  public static void main(String args[]) {
    int threeD[][][] = new int[3][4][5];
    int i, j, k;
    
    for(i=0; i<3; i++) 
      for(j=0; j<4; j++)
        for(k=0; k<5; k++)
        threeD[i][j][k] = i * j * k;

    for(i=0; i<3; i++) {
      for(j=0; j<4; j++) {
        for(k=0; k<5; k++) 
          System.out.print(threeD[i][j][k] + " "); 
        System.out.println();
      }
      System.out.println();
    }
  }
}

listing 37
String str = "this is a test";
System.out.println(str);


 
/*************** 
 * Chapter  4  *
 ***************/

 listing 1
// Demonstrate the basic arithmetic operators.
class BasicMath {
  public static void main(String args[]) {
    // arithmetic using integers
    System.out.println("Integer Arithmetic");
    int a = 1 + 1;
    int b = a * 3;
    int c = b / 4;
    int d = c - a;
    int e = -d;
    System.out.println("a = " + a);
    System.out.println("b = " + b);
    System.out.println("c = " + c);
    System.out.println("d = " + d);
    System.out.println("e = " + e);

    // arithmetic using doubles
    System.out.println("\nFloating Point Arithmetic");
    double da = 1 + 1;
    double db = da * 3;
    double dc = db / 4;
    double dd = dc - a;
    double de = -dd;
    System.out.println("da = " + da);
    System.out.println("db = " + db);
    System.out.println("dc = " + dc);
    System.out.println("dd = " + dd);
    System.out.println("de = " + de);
  }
}

listing 2
// Demonstrate the % operator.
class Modulus {
  public static void main(String args[]) {
    int x = 42;
    double y = 42.25;

    System.out.println("x mod 10 = " + x % 10);
    System.out.println("y mod 10 = " + y % 10);
  }
}

listing 3
a = a + 4;

listing 4
a += 4;

listing 5
a = a % 2;

listing 6
a %= 2;

listing 7
// Demonstrate several assignment operators.
class OpEquals {
  public static void main(String args[]) {
    int a = 1;
    int b = 2;
    int c = 3;

    a += 5;
    b *= 4;
    c += a * b;
    c %= 6;
    System.out.println("a = " + a);
    System.out.println("b = " + b);
    System.out.println("c = " + c);
  }
}

listing 8
x = x + 1;

listing 9
x++;

listing 10
x = x - 1;

listing 11
x--;

listing 12
x = 42;
y = ++x;

listing 13
x = x + 1;
y = x;

listing 14
x = 42;
y = x++;

listing 15
y = x;
x = x + 1;

listing 16
// Demonstrate ++ and --.
class IncDec {
  public static void main(String args[]) {
    int a = 1;
    int b = 2;
    int c;
    int d;

    c = ++b;
    d = a++;
    c++;
    System.out.println("a = " + a);
    System.out.println("b = " + b);
    System.out.println("c = " + c);
    System.out.println("d = " + d);
  }
}

listing 17
// Demonstrate the bitwise logical operators.
class BitLogic {
  public static void main(String args[]) {
    String binary[] = {
      "0000", "0001", "0010", "0011", "0100", "0101", "0110", "0111",
      "1000", "1001", "1010", "1011", "1100", "1101", "1110", "1111"
    };
    int a = 3; // 0 + 2 + 1 or 0011 in binary
    int b = 6; // 4 + 2 + 0 or 0110 in binary
    int c = a | b;
    int d = a & b;
    int e = a ^ b;
    int f = (~a & b) | (a & ~b);
    int g = ~a & 0x0f;

    System.out.println("        a = " + binary[a]);
    System.out.println("        b = " + binary[b]);
    System.out.println("      a|b = " + binary[c]);
    System.out.println("      a&b = " + binary[d]);
    System.out.println("      a^b = " + binary[e]);
    System.out.println("~a&b|a&~b = " + binary[f]);
    System.out.println("       ~a = " + binary[g]);
  }
}

listing 18
// Left shifting a byte value.
class ByteShift {
  public static void main(String args[]) {
    byte a = 64, b;
    int i;

    i = a << 2;
    b = (byte) (a << 2);

    System.out.println("Original value of a: " + a);
    System.out.println("i and b: " + i + " " + b);
  }
}

listing 19
// Left shifting as a quick way to multiply by 2.
class MultByTwo {
  public static void main(String args[]) {
    int i;
    int num = 0xFFFFFFE;

    for(i=0; i<4; i++) {
      num = num << 1;
      System.out.println(num);
    }
  }
}

listing 20
int a = 32;
a = a >> 2; // a now contains 8

listing 21
int a = 35;
a = a >> 2; // a still contains 8

listing 22
// Masking sign extension.
class HexByte {
  static public void main(String args[]) {
    char hex[] = {
      '0', '1', '2', '3', '4', '5', '6', '7',
      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };
    byte b = (byte) 0xf1;

    System.out.println("b = 0x" + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);
  }
}

listing 23
int a = -1;
a = a >>> 24;

listing 24
// Unsigned shifting a byte value.
class ByteUShift {
  static public void main(String args[]) {
    char hex[] = {
      '0', '1', '2', '3', '4', '5', '6', '7',
      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };
    byte b = (byte) 0xf1;
    byte c = (byte) (b >> 4);
    byte d = (byte) (b >>> 4);
    byte e = (byte) ((b & 0xff) >> 4);

    System.out.println("              b = 0x"
      + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);
    System.out.println("         b >> 4 = 0x"
      + hex[(c >> 4) & 0x0f] + hex[c & 0x0f]);
    System.out.println("        b >>> 4 = 0x"
      + hex[(d >> 4) & 0x0f] + hex[d & 0x0f]);
    System.out.println("(b & 0xff) >> 4 = 0x"
      + hex[(e >> 4) & 0x0f] + hex[e & 0x0f]);
  }
}

listing 25
a = a >> 4;
a >>= 4;

listing 26
a = a | b;
a |= b;

listing 27
class OpBitEquals {
  public static void main(String args[]) {
    int a = 1;
    int b = 2;
    int c = 3;

    a |= 4;
    b >>= 1;
    c <<= 1;
    a ^= c;
    System.out.println("a = " + a);
    System.out.println("b = " + b);
    System.out.println("c = " + c);
  }
}

listing 28
int a = 4;
int b = 1;
boolean c = a < b;

listing 29
int done;
// ...
if(!done) ... // Valid in C/C++
if(num) ...   // but not in Java.

listing 30
if(done == 0)) ... // This is Java-style.
if(num != 0) ...

listing 31
// Demonstrate the boolean logical operators.
class BoolLogic {
  public static void main(String args[]) {
    boolean a = true;
    boolean b = false;
    boolean c = a | b;
    boolean d = a & b;
    boolean e = a ^ b;
    boolean f = (!a & b) | (a & !b);
    boolean g = !a;

    System.out.println("        a = " + a);
    System.out.println("        b = " + b);
    System.out.println("      a|b = " + c);
    System.out.println("      a&b = " + d);
    System.out.println("      a^b = " + e);
    System.out.println("!a&b|a&!b = " + f);
    System.out.println("       !a = " + g);
  }
}

listing 32
if (denom != 0 && num / denom > 10)

listing 33
if(c==1 & e++ < 100) d = 100;

listing 34
int x, y, z;

x = y = z = 100; // set x, y, and z to 100

listing 35
ratio = denom == 0 ? 0 : num / denom;

listing 36
// Demonstrate ?. 
class Ternary {
  public static void main(String args[]) {
    int i, k;

    i = 10;
    k = i < 0 ? -i : i; // get absolute value of i
    System.out.print("Absolute value of ");
    System.out.println(i + " is " + k);

    i = -10;
    k = i < 0 ? -i : i; // get absolute value of i
    System.out.print("Absolute value of ");
    System.out.println(i + " is " + k);
  }
}

listing 37
a >> b + 3

listing 38
a >> (b + 3)

listing 39
(a >> b) + 3

listing 40
a | 4 + c >> b & 7 || b > a % 3
(a | (((4 + c) >> b) & 7)) || (b > (a % 3))


 
/*************** 
 * Chapter  5  *
 ***************/

 listing 1
int a, b;
// ...
if(a < b) a = 0;
else b = 0;

listing 2
boolean dataAvailable;
// ...
if (dataAvailable)
  ProcessData();
else
  waitForMoreData();

listing 3
int bytesAvailable;
// ...
if (bytesAvailable > 0) {
  ProcessData();
  bytesAvailable -= n;
} else
  waitForMoreData();

listing 4
int bytesAvailable;
// ...
if (bytesAvailable > 0) {
  ProcessData();
  bytesAvailable -= n;
} else
  waitForMoreData();
  bytesAvailable = n;

listing 5
int bytesAvailable;
// ...
if (bytesAvailable > 0) {
  ProcessData();
  bytesAvailable -= n;
} else {
  waitForMoreData();
  bytesAvailable = n;
}

listing 6
if(i == 10) {
  if(j < 20) a = b;
  if(k > 100) c = d; // this if is
  else a = c;        // associated with this else
}
else a = d;          // this else refers to if(i == 10)

listing 7
// Demonstrate if-else-if statements.
class IfElse {
  public static void main(String args[]) {
    int month = 4; // April
    String season;

    if(month == 12 || month == 1 || month == 2) 
      season = "Winter";
    else if(month == 3 || month == 4 || month == 5)
      season = "Spring";
    else if(month == 6 || month == 7 || month == 8)
      season = "Summer";
    else if(month == 9 || month == 10 || month == 11)
      season = "Autumn";
    else 
      season = "Bogus Month";

    System.out.println("April is in the " + season + ".");
  }
}

listing 8
// A simple example of the switch.
class SampleSwitch {
  public static void main(String args[]) {
    for(int i=0; i<6; i++)
      switch(i) {
        case 0:
          System.out.println("i is zero.");
          break;
        case 1:
          System.out.println("i is one.");
          break;
        case 2:
          System.out.println("i is two.");
          break;
        case 3:
          System.out.println("i is three.");
          break;
        default:
          System.out.println("i is greater than 3.");
      }
  }
}


listing 9
// In a switch, break statements are optional.
class MissingBreak {
  public static void main(String args[]) {
    for(int i=0; i<12; i++)
      switch(i) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
          System.out.println("i is less than 5");
          break;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          System.out.println("i is less than 10");
          break;
        default:
          System.out.println("i is 10 or more.");
      }
  }
}

listing 10
// An improved version of the season program.
class Switch {
    public static void main(String args[]) {
        int month = 4;
        String season;
        switch (month) {
          case 12: 
          case 1: 
          case 2:
            season = "Winter";
            break;
          case 3: 
          case 4: 
          case 5:
            season = "Spring";
            break;
          case 6: 
          case 7: 
          case 8:
            season = "Summer";
            break;
          case 9: 
          case 10: 
          case 11:
            season = "Autumn";
            break;
          default:
            season = "Bogus Month";
        }
        System.out.println("April is in the " + season + ".");
    }
}

listing 11
// Demonstrate the while loop.
class While {
  public static void main(String args[]) {
    int n = 10;

    while(n > 0) {
      System.out.println("tick " + n);
      n--;
    }
  }
}

listing 12
int a = 10, b = 20;

while(a > b) 
  System.out.println("This will not be displayed");

listing 13
// The target of a loop can be empty. 
class NoBody {
  public static void main(String args[]) {
    int i, j;

    i = 100;
    j = 200;

    // find midpoint between i and j
    while(++i < --j) ; // no body in this loop

    System.out.println("Midpoint is " + i);
  }
}

listing 14
// Demonstrate the do-while loop.
class DoWhile {
  public static void main(String args[]) {
    int n = 10;

    do {
      System.out.println("tick " + n);
      n--;
    } while(n > 0);
  }
}

listing 15
do {
  System.out.println("tick " + n);
} while(--n > 0);

listing 16
// Using a do-while to process a menu selection -- a simple help system.
class Menu {
  public static void main(String args[]) 
    throws java.io.IOException {
    char choice;

    do {
      System.out.println("Help on:");
      System.out.println("  1. if");
      System.out.println("  2. switch");
      System.out.println("  3. while");
      System.out.println("  4. do-while");
      System.out.println("  5. for\n");
      System.out.println("Choose one:");
      choice = (char) System.in.read();
    } while( choice < '1' || choice > '5');

    System.out.println("\n");
 
    switch(choice) {
      case '1':
        System.out.println("The if:\n");
        System.out.println("if(condition) statement;");
        System.out.println("else statement;");
        break;
      case '2':
        System.out.println("The switch:\n");
        System.out.println("switch(expression) {");
        System.out.println("  case constant:");
        System.out.println("    statement sequence");
        System.out.println("  break;");
        System.out.println("  // ...");
        System.out.println("}");
        break;
      case '3':
        System.out.println("The while:\n");
        System.out.println("while(condition) statement;");
        break;
      case '4':
        System.out.println("The do-while:\n");
        System.out.println("do {");
        System.out.println("  statement;");
        System.out.println("} while (condition);");
        break;
      case '5':
        System.out.println("The for:\n");
        System.out.print("for(init; condition; iteration)");
        System.out.println(" statement;");
        break;
    }
  }
}

listing 17
// Demonstrate the for loop.
class ForTick {
  public static void main(String args[]) {
    int n;

    for(n=10; n>0; n--)
      System.out.println("tick " + n);
  }
}

listing 18
// Declare a loop control variable inside the for.
class ForTick {
  public static void main(String args[]) {

    // here, n is declared inside of the for loop
    for(int n=10; n>0; n--)
      System.out.println("tick " + n);
  }
}

listing 19
// Test for primes.
class FindPrime {
  public static void main(String args[]) {
    int num;
    boolean isPrime = true;

    num = 14;
    for(int i=2; i <= num/2; i++) {
      if((num % i) == 0) {
        isPrime = false;
        break;
      }
    }
    if(isPrime) System.out.println("Prime");
    else System.out.println("Not Prime");
  }
}

listing 20
class Sample {
  public static void main(String args[]) {
    int a, b;

    b = 4;
    for(a=1; a<b; a++) {
      System.out.println("a = " + a);
      System.out.println("b = " + b);
      b--;
    }
  }
}

listing 21
// Using the comma.
class Comma {
  public static void main(String args[]) {
    int a, b;

    for(a=1, b=4; a<b; a++, b--) {
      System.out.println("a = " + a);
      System.out.println("b = " + b);
    }
  }
}

listing 22
boolean done = false;

for(int i=1; !done; i++) {
  // ...
  if(interrupted()) done = true;
}

listing 23
// Parts of the for loop can be empty.
class ForVar {
  public static void main(String args[]) {
    int i;
    boolean done = false;

    i = 0;
    for( ; !done; ) {
      System.out.println("i is " + i);
      if(i == 10) done = true;
      i++;
    }
  }
}

listing 24
// Loops may be nested.
class Nested {
  public static void main(String args[]) {
    int i, j;

    for(i=0; i<10; i++) {
      for(j=i; j<10; j++)
        System.out.print(".");
      System.out.println();
    }
  }
}

listing 25
// Using break to exit a loop. 
class BreakLoop {
  public static void main(String args[]) {
    for(int i=0; i<100; i++) {
      if(i == 10) break; // terminate loop if i is 10
      System.out.println("i: " + i);
    }
    System.out.println("Loop complete.");
  }
}

listing 26
// Using break to exit a while loop. 
class BreakLoop2 {
  public static void main(String args[]) {
    int i = 0;
    
    while(i < 100) {
      if(i == 10) break; // terminate loop if i is 10
      System.out.println("i: " + i);
      i++;
    }
    System.out.println("Loop complete.");
  }
}

listing 27
// Using break with nested loops.
class BreakLoop3 {
  public static void main(String args[]) {
    for(int i=0; i<3; i++) {
      System.out.print("Pass " + i + ": ");
      for(int j=0; j<100; j++) {
        if(j == 10) break; // terminate loop if j is 10
        System.out.print(j + " ");
      }
      System.out.println();
    }
    System.out.println("Loops complete.");
  }
}

listing 28
// Using break as a civilized form of goto. 
class Break {
  public static void main(String args[]) {
    boolean t = true;

    first: {
      second: {
        third: {
          System.out.println("Before the break.");
          if(t) break second; // break out of second block
          System.out.println("This won't execute");
        }
        System.out.println("This won't execute");
      }
      System.out.println("This is after second block.");
    }
  }
}

listing 29
// Using break to exit from nested loops
class BreakLoop4 {
  public static void main(String args[]) {
    outer: for(int i=0; i<3; i++) {
      System.out.print("Pass " + i + ": ");
      for(int j=0; j<100; j++) {
        if(j == 10) break outer; // exit both loops
        System.out.print(j + " ");
      }
      System.out.println("This will not print");
    }
    System.out.println("Loops complete.");
  }
}

listing 30
// This program contains an error.
class BreakErr {
  public static void main(String args[]) {

    one: for(int i=0; i<3; i++) {
      System.out.print("Pass " + i + ": ");
    }

    for(int j=0; j<100; j++) {
      if(j == 10) break one; // WRONG
      System.out.print(j + " ");
    }
  }
}

listing 31
// Demonstrate continue.
class Continue {
  public static void main(String args[]) {
    for(int i=0; i<10; i++) {
      System.out.print(i + " ");
      if (i%2 == 0) continue;
      System.out.println("");
    }
  }
}

listing 32
// Using continue with a label.
class ContinueLabel {
  public static void main(String args[]) {
outer: for (int i=0; i<10; i++) {
         for(int j=0; j<10; j++) {
           if(j > i) {
             System.out.println();
             continue outer;
           }
           System.out.print(" " + (i * j));
         }
       }
       System.out.println();
  }
}

listing 33
// Demonstrate return.
class Return {
  public static void main(String args[]) {
    boolean t = true;

    System.out.println("Before the return.");

    if(t) return; // return to caller

    System.out.println("This won't execute.");
  }
}


 
/*************** 
 * Chapter  6  *
 ***************/

listing 1
class Box {
  double width;
  double height;
  double depth;
}

listing 2
Box mybox = new Box(); // create a Box object called mybox

listing 3
/* A program that uses the Box class.

   Call this file BoxDemo.java
*/
class Box {
  double width;
  double height;
  double depth;
}

// This class declares an object of type Box.
class BoxDemo {
  public static void main(String args[]) {
    Box mybox = new Box();
    double vol;

    // assign values to mybox's instance variables
    mybox.width = 10;
    mybox.height = 20;
    mybox.depth = 15;

    // compute volume of box
    vol = mybox.width * mybox.height * mybox.depth;

    System.out.println("Volume is " + vol);
  }
}

listing 4
// This program declares two Box objects.

class Box {
  double width;
  double height;
  double depth;
}
  
class BoxDemo2 {
  public static void main(String args[]) {
    Box mybox1 = new Box();
    Box mybox2 = new Box();
    double vol;

    // assign values to mybox1's instance variables
    mybox1.width = 10;
    mybox1.height = 20;
    mybox1.depth = 15;

    /* assign different values to mybox2's
       instance variables */
    mybox2.width = 3;
    mybox2.height = 6;
    mybox2.depth = 9;

    // compute volume of first box
    vol = mybox1.width * mybox1.height * mybox1.depth;
    System.out.println("Volume is " + vol);

    // compute volume of second box
    vol = mybox2.width * mybox2.height * mybox2.depth;
    System.out.println("Volume is " + vol);
  }
}

listing 5
Box mybox = new Box();

listing 6
// This program includes a method inside the box class.

class Box {
  double width;
  double height;
  double depth;

  // display volume of a box
  void volume() {
    System.out.print("Volume is ");
    System.out.println(width * height * depth);
  }
}
  
class BoxDemo3 {
  public static void main(String args[]) {
    Box mybox1 = new Box();
    Box mybox2 = new Box();

    // assign values to mybox1's instance variables
    mybox1.width = 10;
    mybox1.height = 20;
    mybox1.depth = 15;

    /* assign different values to mybox2's
       instance variables */
    mybox2.width = 3;
    mybox2.height = 6;
    mybox2.depth = 9;

    // display volume of first box
    mybox1.volume();

    // display volume of second box
    mybox2.volume();
  }
}

listing 7
mybox1.volume();
mybox2.volume();

listing 8
// Now, volume() returns the volume of a box.

class Box {
  double width;
  double height;
  double depth;

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}
  
class BoxDemo4 {
  public static void main(String args[]) {
    Box mybox1 = new Box();
    Box mybox2 = new Box();
    double vol;

    // assign values to mybox1's instance variables
    mybox1.width = 10;
    mybox1.height = 20;
    mybox1.depth = 15;

    /* assign different values to mybox2's
       instance variables */
    mybox2.width = 3;
    mybox2.height = 6;
    mybox2.depth = 9;

    // get volume of first box
    vol = mybox1.volume();
    System.out.println("Volume is " + vol);

    // get volume of second box
    vol = mybox2.volume();
    System.out.println("Volume is " + vol);
  }
}

listing 9
vol = mybox1.volume();

listing 10
System.out.println("Volume is " + mybox1.volume());

listing 11
// This program uses a parameterized method.

class Box {
  double width;
  double height;
  double depth;

  // compute and return volume
  double volume() {
    return width * height * depth;
  }

  // sets dimensions of box
  void setDim(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }
}
  
class BoxDemo5 {
  public static void main(String args[]) {
    Box mybox1 = new Box();
    Box mybox2 = new Box();
    double vol;

    // initialize each box
    mybox1.setDim(10, 20, 15);
    mybox2.setDim(3, 6, 9);    

    // get volume of first box
    vol = mybox1.volume();
    System.out.println("Volume is " + vol);

    // get volume of second box
    vol = mybox2.volume();
    System.out.println("Volume is " + vol);
  }
}

listing 12
mybox1.setDim(10, 20, 15);

listing 13
/* Here, Box uses a constructor to initialize the 
   dimensions of a box.
*/
class Box {
  double width;
  double height;
  double depth;

  // This is the constructor for Box.
  Box() {
    System.out.println("Constructing Box");
    width = 10;
    height = 10;
    depth = 10;
  }

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}
  
class BoxDemo6 {
  public static void main(String args[]) {
    // declare, allocate, and initialize Box objects
    Box mybox1 = new Box();
    Box mybox2 = new Box();

    double vol;

    // get volume of first box
    vol = mybox1.volume();
    System.out.println("Volume is " + vol);

    // get volume of second box
    vol = mybox2.volume();
    System.out.println("Volume is " + vol);
  }
}


listing 14
Box mybox1 = new Box();

listing 15
/* Here, Box uses a parameterized constructor to
   initialize the dimensions of a box.
*/
class Box {
  double width;
  double height;
  double depth;

  // This is the constructor for Box.
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}
  
class BoxDemo7 {
  public static void main(String args[]) {
    // declare, allocate, and initialize Box objects
    Box mybox1 = new Box(10, 20, 15);
    Box mybox2 = new Box(3, 6, 9);

    double vol;

    // get volume of first box
    vol = mybox1.volume();
    System.out.println("Volume is " + vol);

    // get volume of second box
    vol = mybox2.volume();
    System.out.println("Volume is " + vol);
  }
}

listing 16
Box mybox1 = new Box(10, 20, 15);

listing 17
// A redundant use of this.
Box(double w, double h, double d) {
  this.width = w;
  this.height = h;
  this.depth = d;
}

listing 18
// Use this to resolve name-space collisions.
Box(double width, double height, double depth) {
  this.width = width;
  this.height = height;
  this.depth = depth;
}

listing 19
// This class defines an integer stack that can hold 10 values. 
class Stack {
  int stck[] = new int[10];
  int tos;
  
  // Initialize top-of-stack
  Stack() {
    tos = -1;
  }

  // Push an item onto the stack
  void push(int item) {
    if(tos==9) 
      System.out.println("Stack is full.");
    else 
      stck[++tos] = item;
  }

  // Pop an item from the stack
  int pop() {
    if(tos < 0) {
      System.out.println("Stack underflow.");
      return 0;
    }
    else 
      return stck[tos--];
  }
}

listing 20
class TestStack {
  public static void main(String args[]) {
    Stack mystack1 = new Stack();
    Stack mystack2 = new Stack();

    // push some numbers onto the stack
    for(int i=0; i<10; i++) mystack1.push(i);
    for(int i=10; i<20; i++) mystack2.push(i);

    // pop those numbers off the stack
    System.out.println("Stack in mystack1:");
    for(int i=0; i<10; i++) 
       System.out.println(mystack1.pop());

    System.out.println("Stack in mystack2:");
    for(int i=0; i<10; i++) 
       System.out.println(mystack2.pop());
  }
}


 
/*************** 
 * Chapter  7  *
 ***************/

listing 1
// Demonstrate method overloading.
class OverloadDemo {
  void test() {
    System.out.println("No parameters");
  }

  // Overload test for one integer parameter.
  void test(int a) {
    System.out.println("a: " + a);
  }

  // Overload test for two integer parameters.
  void test(int a, int b) {
    System.out.println("a and b: " + a + " " + b);
  }

  // overload test for a double parameter
  double test(double a) {
    System.out.println("double a: " + a);
    return a*a;
  }
}
  
class Overload {
  public static void main(String args[]) {
    OverloadDemo ob = new OverloadDemo();
    double result;

    // call all versions of test()
    ob.test(); 
    ob.test(10);
    ob.test(10, 20);
    result = ob.test(123.25);
    System.out.println("Result of ob.test(123.25): " + result);
  }
}

listing 2
// Automatic type conversions apply to overloading.
class OverloadDemo {
  void test() {
    System.out.println("No parameters");
  }

  // Overload test for two integer parameters.
  void test(int a, int b) {
    System.out.println("a and b: " + a + " " + b);
  }

  // overload test for a double parameter and return type
  void test(double a) {
    System.out.println("Inside test(double) a: " + a);
  }
}
  
class Overload {
  public static void main(String args[]) {
    OverloadDemo ob = new OverloadDemo();
    int i = 88;

    ob.test(); 
    ob.test(10, 20);

    ob.test(i); // this will invoke test(double)
    ob.test(123.2); // this will invoke test(double)
  }
}

listing 3
class Box {
  double width;
  double height;
  double depth;

  // This is the constructor for Box.
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}

listing 4
Box ob = new Box();

listing 5
/* Here, Box defines three constructors to initialize
   the dimensions of a box various ways.
*/
class Box {
  double width;
  double height;
  double depth;

  // constructor used when all dimensions specified
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // constructor used when no dimensions specified
  Box() {
    width = -1;  // use -1 to indicate
    height = -1; // an uninitialized
    depth = -1;  // box
  }

  // constructor used when cube is created
  Box(double len) {
    width = height = depth = len;
  }

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}
  
class OverloadCons {
  public static void main(String args[]) {
    // create boxes using the various constructors
    Box mybox1 = new Box(10, 20, 15);
    Box mybox2 = new Box();
    Box mycube = new Box(7);

    double vol;

    // get volume of first box
    vol = mybox1.volume();
    System.out.println("Volume of mybox1 is " + vol);

    // get volume of second box
    vol = mybox2.volume();
    System.out.println("Volume of mybox2 is " + vol);

    // get volume of cube
    vol = mycube.volume();
    System.out.println("Volume of mycube is " + vol);
  }
}

listing 6
// Objects may be passed to methods.
class Test {
  int a, b;

  Test(int i, int j) {
    a = i;
    b = j;
  }

  // return true if o is equal to the invoking object
  boolean equals(Test o) {
    if(o.a == a && o.b == b) return true;
    else return false;
  }
}

class PassOb {
  public static void main(String args[]) {
    Test ob1 = new Test(100, 22);
    Test ob2 = new Test(100, 22);
    Test ob3 = new Test(-1, -1);
    
    System.out.println("ob1 == ob2: " + ob1.equals(ob2));

    System.out.println("ob1 == ob3: " + ob1.equals(ob3));
  }
}

listing 7
// Here, Box allows one object to initialize another.

class Box {
  double width;
  double height;
  double depth;

  // construct clone of an object
  Box(Box ob) { // pass object to constructor
    width = ob.width;
    height = ob.height;
    depth = ob.depth;
  }

  // constructor used when all dimensions specified
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // constructor used when no dimensions specified
  Box() {
    width = -1;  // use -1 to indicate
    height = -1; // an uninitialized
    depth = -1;  // box
  }

  // constructor used when cube is created
  Box(double len) {
    width = height = depth = len;
  }

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}
  
class OverloadCons2 {
  public static void main(String args[]) {
    // create boxes using the various constructors
    Box mybox1 = new Box(10, 20, 15);
    Box mybox2 = new Box();
    Box mycube = new Box(7);

    Box myclone = new Box(mybox1);

    double vol;

    // get volume of first box
    vol = mybox1.volume();
    System.out.println("Volume of mybox1 is " + vol);

    // get volume of second box
    vol = mybox2.volume();
    System.out.println("Volume of mybox2 is " + vol);

    // get volume of cube
    vol = mycube.volume();
    System.out.println("Volume of cube is " + vol);

    // get volume of clone
    vol = myclone.volume();
    System.out.println("Volume of clone is " + vol);
  }
}

listing 8
// Simple Types are passed by value.
class Test {
  void meth(int i, int j) {
    i *= 2;
    j /= 2;
  }
}

class CallByValue {
  public static void main(String args[]) {
    Test ob = new Test();
    int a = 15, b = 20;
    
    System.out.println("a and b before call: " +
                       a + " " + b);

    ob.meth(a, b); 

    System.out.println("a and b after call: " +
                       a + " " + b);
  }
}

listing 9
// Objects are passed by reference.

class Test {
  int a, b;

  Test(int i, int j) {
    a = i;
    b = j;
  }

  // pass an object
  void meth(Test o) {
    o.a *=  2;
    o.b /= 2;
  }
}

class CallByRef {
  public static void main(String args[]) {
    Test ob = new Test(15, 20);
    
    System.out.println("ob.a and ob.b before call: " +
                       ob.a + " " + ob.b);

    ob.meth(ob); 

    System.out.println("ob.a and ob.b after call: " +
                       ob.a + " " + ob.b);
  }
}

listing 10
// Returning an object.
class Test {
  int a;

  Test(int i) {
    a = i;
  }

  Test incrByTen() {
    Test temp = new Test(a+10);
    return temp;
  }
}

class RetOb {
  public static void main(String args[]) {
    Test ob1 = new Test(2);
    Test ob2;

    ob2 = ob1.incrByTen();
    System.out.println("ob1.a: " + ob1.a);
    System.out.println("ob2.a: " + ob2.a);

    ob2 = ob2.incrByTen();
    System.out.println("ob2.a after second increase: "
                        + ob2.a);
  }
}

listing 11
// A simple example of recursion.
class Factorial {
  // this is a recusive function
  int fact(int n) {
    int result;

    if(n==1) return 1;
    result = fact(n-1) * n;
    return result;
  }
}

class Recursion {
  public static void main(String args[]) {
    Factorial f = new Factorial();

    System.out.println("Factorial of 3 is " + f.fact(3));
    System.out.println("Factorial of 4 is " + f.fact(4));
    System.out.println("Factorial of 5 is " + f.fact(5));
  }
}

listing 12
// Another example that uses recursion.

class RecTest {
  int values[];

  RecTest(int i) {
    values = new int[i];
  }

  // display arrary -- recursively
  void printArray(int i) {
    if(i==0) return;
    else printArray(i-1);
    System.out.println("[" + (i-1) + "] " + values[i-1]);
  }
}

class Recursion2 {
  public static void main(String args[]) {
    RecTest ob = new RecTest(10);
    int i;

    for(i=0; i<10; i++) ob.values[i] = i;
    
    ob.printArray(10);
  }
}

listing 13
public int i;
private double j;

private int myMethod(int a, char b) { // ...

listing 14
/* This program demonstrates the difference between
   public and private.
*/
class Test {
  int a; // default access
  public int b; // public access
  private int c; // private access

  // methods to access c
  void setc(int i) { // set c's value
    c = i;
  }
  int getc() { // get c's value
    return c;
  }
}
  
class AccessTest {
  public static void main(String args[]) {
    Test ob = new Test();

    // These are OK, a and b may be accessed directly
    ob.a = 10;
    ob.b = 20;

    // This is not OK and will cause an error
//  ob.c = 100; // Error!

    // You must access c through its methods
    ob.setc(100); // OK
   
    System.out.println("a, b, and c: " + ob.a + " " +
                       ob.b + " " + ob.getc());
  }
}

listing 15
//  ob.c = 100; // Error!

listing 16
// This class defines an integer stack that can hold 10 values. 
class Stack {
  /* Now, both stck and tos are private.  This means
     that they cannot be accidentally or maliciously
     altered in a way that would be harmful to the stack.
  */
  private int stck[] = new int[10];
  private int tos;
  
  // Initialize top-of-stack
  Stack() {
    tos = -1;
  }

  // Push an item onto the stack
  void push(int item) {
    if(tos==9) 
      System.out.println("Stack is full.");
    else 
      stck[++tos] = item;
  }

  // Pop an item from the stack
  int pop() {
    if(tos < 0) {
      System.out.println("Stack underflow.");
      return 0;
    }
    else 
      return stck[tos--];
  }
}

listing 17
class TestStack {
  public static void main(String args[]) {
    Stack mystack1 = new Stack();
    Stack mystack2 = new Stack();

    // push some numbers onto the stack
    for(int i=0; i<10; i++) mystack1.push(i);
    for(int i=10; i<20; i++) mystack2.push(i);

    // pop those numbers off the stack
    System.out.println("Stack in mystack1:");
    for(int i=0; i<10; i++) 
       System.out.println(mystack1.pop());

    System.out.println("Stack in mystack2:");
    for(int i=0; i<10; i++) 
       System.out.println(mystack2.pop());

    // these statements are not legal
    // mystack1.tos = -2;
    // mystack2.stck[3] = 100; 
  }
}

listing 18
// Demonstrate static variables, methods, and blocks.
class UseStatic {
  static int a = 3;
  static int b;

  static void meth(int x) {
    System.out.println("x = " + x);
    System.out.println("a = " + a);
    System.out.println("b = " + b);
  }

  static {
    System.out.println("Static block initialized.");
    b = a * 4;
  }

  public static void main(String args[]) {
    meth(42);
  }
}

listing 19
class StaticDemo {
  static int a = 42;
  static int b = 99;
  static void callme() {
    System.out.println("a = " + a);
  }
}

class StaticByName {
  public static void main(String args[]) {
    StaticDemo.callme();
    System.out.println("b = " + StaticDemo.b);
  }
}

listing 20
final int FILE_NEW = 1;
final int FILE_OPEN = 2;
final int FILE_SAVE = 3;
final int FILE_SAVEAS = 4;
final int FILE_QUIT = 5;

listing 21
// This program demonstrates the length array member.
class Length {
  public static void main(String args[]) {
    int a1[] = new int[10];
    int a2[] = {3, 5, 7, 1, 8, 99, 44, -10};
    int a3[] = {4, 3, 2, 1};

    System.out.println("length of a1 is " + a1.length);
    System.out.println("length of a2 is " + a2.length);
    System.out.println("length of a3 is " + a3.length);
  }
}

listing 22
// Improved Stack class that uses the length array member.
class Stack {
  private int stck[];
  private int tos;

  // allocate and initialize stack
  Stack(int size) {
    stck = new int[size];
    tos = -1;
  }

  // Push an item onto the stack
  void push(int item) {
    if(tos==stck.length-1) // use length member 
      System.out.println("Stack is full.");
    else 
      stck[++tos] = item;
  }

  // Pop an item from the stack
  int pop() {
    if(tos < 0) {
      System.out.println("Stack underflow.");
      return 0;
    }
    else 
      return stck[tos--];
  }
}

class TestStack2 {
  public static void main(String args[]) {
    Stack mystack1 = new Stack(5);
    Stack mystack2 = new Stack(8);

    // push some numbers onto the stack
    for(int i=0; i<5; i++) mystack1.push(i);
    for(int i=0; i<8; i++) mystack2.push(i);

    // pop those numbers off the stack
    System.out.println("Stack in mystack1:");
    for(int i=0; i<5; i++) 
       System.out.println(mystack1.pop());

    System.out.println("Stack in mystack2:");
    for(int i=0; i<8; i++) 
       System.out.println(mystack2.pop());
  }
}

listing 23
// Demonstrate an inner class.
class Outer {
  int outer_x = 100;

  void test() {
    Inner inner = new Inner();
    inner.display();
  }

  // this is an innner class
  class Inner {
    void display() {
      System.out.println("display: outer_x = " + outer_x);
    }
  }
}

class InnerClassDemo {
  public static void main(String args[]) {
    Outer outer = new Outer();
    outer.test();
  }
}

listing 24
// This program will not compile.
class Outer {
  int outer_x = 100;

  void test() {
    Inner inner = new Inner();
    inner.display();
  }

  // this is an innner class
  class Inner {
    int y = 10; // y is local to Inner
    void display() {
      System.out.println("display: outer_x = " + outer_x);
    }
  }

  void showy() {
    System.out.println(y); // error, y not known here!
  }
}

class InnerClassDemo {
  public static void main(String args[]) {
    Outer outer = new Outer();
    outer.test();
  }
}

listing 35
// Define an inner class within a for loop.
class Outer {
  int outer_x = 100;

  void test() {
    for(int i=0; i<10; i++) {
      class Inner {
        void display() {
          System.out.println("display: outer_x = " + outer_x);
        }
      }
      Inner inner = new Inner();
      inner.display();
    }
  }
}

class InnerClassDemo {
  public static void main(String args[]) {
    Outer outer = new Outer();
    outer.test();
  }
}

listing 26
System.out.println("This is a String, too");

listing 27
String myString = "this is a test";

listing 28
System.out.println(myString);

listing 29
String myString = "I" + " like " + "Java.";

listing 30
// Demonstrating Strings.
class StringDemo {
  public static void main(String args[]) {
    String strOb1 = "First String";
    String strOb2 = "Second String";
    String strOb3 = strOb1 + " and " + strOb2;

    System.out.println(strOb1);
    System.out.println(strOb2);
    System.out.println(strOb3);
  }
}

listing 31
// Demonstrating some String methods.
class StringDemo2 {
  public static void main(String args[]) {
    String strOb1 = "First String";
    String strOb2 = "Second String";
    String strOb3 = strOb1;

    System.out.println("Length of strOb1: " +
                       strOb1.length());

    System.out.println("Char at index 3 in strOb1: " +
                       strOb1.charAt(3));

    if(strOb1.equals(strOb2)) 
      System.out.println("strOb1 == strOb2");
    else
      System.out.println("strOb1 != strOb2");

    if(strOb1.equals(strOb3)) 
      System.out.println("strOb1 == strOb3");
    else
      System.out.println("strOb1 != strOb3");
  }
}

listing 32
// Demonstrate String arrays.
class StringDemo3 {
  public static void main(String args[]) {
    String str[] = { "one", "two", "three" };
    
    for(int i=0; i<str.length; i++)
      System.out.println("str[" + i + "]: " +
                          str[i]);
  }
}

listing 33
// Display all command line arguments.
class CommandLine {
  public static void main(String args[]) {
    for(int i=0; i<args.length; i++)
      System.out.println("args[" + i + "]: " +
                          args[i]);
  }
}


 
/*************** 
 * Chapter  8  *
 ***************/

listing 1
// A simple example of inheritance.

// Create a superclass.
class A {
  int i, j;

  void showij() {
    System.out.println("i and j: " + i + " " + j);
  }
}

// Create a subclass by extending class A.
class B extends A {
  int k;

  void showk() {
    System.out.println("k: " + k);
  }
  void sum() {
    System.out.println("i+j+k: " + (i+j+k));
  }
}
  
class SimpleInheritance {
  public static void main(String args[]) {
    A superOb = new A();
    B subOb = new B();

    // The superclass may be used by itself.
    superOb.i = 10;
    superOb.j = 20;
    System.out.println("Contents of superOb: ");
    superOb.showij();
    System.out.println();

    /* The subclass has access to all public members of
       its superclass. */
    subOb.i = 7;
    subOb.j = 8;
    subOb.k = 9; 
    System.out.println("Contents of subOb: ");
    subOb.showij();
    subOb.showk();
    System.out.println();

    System.out.println("Sum of i, j and k in subOb:");
    subOb.sum();
  }
}


listing 2
/* In a class hierarchy, private members remain
   private to their class.

   This program contains an error and will not
   compile.
*/

// Create a superclass.
class A {
  int i; // public be default
  private int j; // private to A

  void setij(int x, int y) {
    i = x;
    j = y;
  }
}

// A's j is not accessible here.
class B extends A {
  int total;

  void sum() {
    total = i + j; // ERROR, j is not accessible here
  }
}
  
class Access {
  public static void main(String args[]) {
    B subOb = new B();

    subOb.setij(10, 12);

    subOb.sum();
    System.out.println("Total is " + subOb.total);
  }
}


listing 4
// This program uses inheritance to extend Box.
class Box {
  double width;
  double height;
  double depth;

  // construct clone of an object
  Box(Box ob) { // pass object to constructor
    width = ob.width;
    height = ob.height;
    depth = ob.depth;
  }

  // constructor used when all dimensions specified
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // constructor used when no dimensions specified
  Box() {
    width = -1;  // use -1 to indicate
    height = -1; // an uninitialized
    depth = -1;  // box
  }

  // constructor used when cube is created
  Box(double len) {
    width = height = depth = len;
  }

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}

// Here, Box is extened to include weight.
class BoxWeight extends Box {
  double weight; // weight of box

  // constructor for BoxWeight
  BoxWeight(double w, double h, double d, double m) {
    width = w;
    height = h;
    depth = d;
    weight = m;
  }    
}
  
class DemoBoxWeight {
  public static void main(String args[]) {
    BoxWeight mybox1 = new BoxWeight(10, 20, 15, 34.3);
    BoxWeight mybox2 = new BoxWeight(2, 3, 4, 0.076);
    double vol;

    vol = mybox1.volume();
    System.out.println("Volume of mybox1 is " + vol);
    System.out.println("Weight of mybox1 is " + mybox1.weight);
    System.out.println();

    vol = mybox2.volume();
    System.out.println("Volume of mybox2 is " + vol);
    System.out.println("Weight of mybox2 is " + mybox2.weight);
  }
}

listing 5
// Here, Box is extended to include color.
class ColorBox extends Box {
  int color; // color of box

  ColorBox(double w, double h, double d, int c) {
    width = w;
    height = h;
    depth = d;
    color = c;
  }    
}

listing 6
class RefDemo {
  public static void main(String args[]) {
    BoxWeight weightbox = new BoxWeight(3, 5, 7, 8.37);
    Box plainbox = new Box();
    double vol;

    vol = weightbox.volume();
    System.out.println("Volume of weightbox is " + vol);
    System.out.println("Weight of weightbox is " + weightbox.weight);
    System.out.println();

    // assign BoxWeight reference to Box reference
    plainbox = weightbox;

    vol = plainbox.volume(); // OK, volume() defined in Box
    System.out.println("Volume of plainbox is " + vol);

    /* The following statement is invalid because plainbox
       does not define a weight member. */
//  System.out.println("Weight of plainbox is " + plainbox.weight);
  }
}

listing 7
// BoxWeight now uses super to initialize its Box attributes.
class BoxWeight extends Box {
  double weight; // weight of box

  // initialize width, height, and depth using super()
  BoxWeight(double w, double h, double d, double m) {
    super(w, h, d); // call superclass constructor
    weight = m;
  }    
}

listing 8
 // A complete implementation of BoxWeight.
class Box {
  private double width;
  private double height;
  private double depth;

  // construct clone of an object
  Box(Box ob) { // pass object to constructor
    width = ob.width;
    height = ob.height;
    depth = ob.depth;
  }

  // constructor used when all dimensions specified
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // constructor used when no dimensions specified
  Box() {
    width = -1;  // use -1 to indicate
    height = -1; // an uninitialized
    depth = -1;  // box
  }

  // constructor used when cube is created
  Box(double len) {
    width = height = depth = len;
  }

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}

// BoxWeight now fully implements all constructors.
class BoxWeight extends Box {
  double weight; // weight of box

  // construct clone of an object
  BoxWeight(BoxWeight ob) { // pass object to constructor
    super(ob);
    weight = ob.weight;
  }

  // constructor when all parameters are specified
  BoxWeight(double w, double h, double d, double m) {
    super(w, h, d); // call superclass constructor
    weight = m;
  }    

  // default constructor
  BoxWeight() {
    super();
    weight = -1;
  }

  // constructor used when cube is created
  BoxWeight(double len, double m) {
    super(len);
    weight = m;
  }
}
  
class DemoSuper {
  public static void main(String args[]) {
    BoxWeight mybox1 = new BoxWeight(10, 20, 15, 34.3);
    BoxWeight mybox2 = new BoxWeight(2, 3, 4, 0.076);
    BoxWeight mybox3 = new BoxWeight(); // default
    BoxWeight mycube = new BoxWeight(3, 2);
    BoxWeight myclone = new BoxWeight(mybox1);
    double vol;

    vol = mybox1.volume();
    System.out.println("Volume of mybox1 is " + vol);
    System.out.println("Weight of mybox1 is " + mybox1.weight);
    System.out.println();

    vol = mybox2.volume();
    System.out.println("Volume of mybox2 is " + vol);
    System.out.println("Weight of mybox2 is " + mybox2.weight);
    System.out.println();

    vol = mybox3.volume();
    System.out.println("Volume of mybox3 is " + vol);
    System.out.println("Weight of mybox3 is " + mybox3.weight);
    System.out.println();
 
    vol = myclone.volume();
    System.out.println("Volume of myclone is " + vol);
    System.out.println("Weight of myclone is " + myclone.weight);
    System.out.println();

    vol = mycube.volume();
    System.out.println("Volume of mycube is " + vol);
    System.out.println("Weight of mycube is " + mycube.weight);
    System.out.println();
  }
}

listing 9
// construct clone of an object
BoxWeight(BoxWeight ob) { // pass object to constructor
  super(ob);
  weight = ob.weight;
}

listing 10
// Using super to overcome name hiding.
class A {
  int i;
}

// Create a subclass by extending class A.
class B extends A {
  int i; // this i hides the i in A

  B(int a, int b) {
    super.i = a; // i in A
    i = b; // i in B
  }

  void show() {
    System.out.println("i in superclass: " + super.i);
    System.out.println("i in subclass: " + i);
  }
}
  
class UseSuper {
  public static void main(String args[]) {
    B subOb = new B(1, 2);

    subOb.show();
  }
}

listing 11
// Extend BoxWeight to include shipping costs.

// Start with Box.
class Box {
  private double width;
  private double height;
  private double depth;

  // construct clone of an object
  Box(Box ob) { // pass object to constructor
    width = ob.width;
    height = ob.height;
    depth = ob.depth;
  }

  // constructor used when all dimensions specified
  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  // constructor used when no dimensions specified
  Box() {
    width = -1;  // use -1 to indicate
    height = -1; // an uninitialized
    depth = -1;  // box
  }

  // constructor used when cube is created
  Box(double len) {
    width = height = depth = len;
  }

  // compute and return volume
  double volume() {
    return width * height * depth;
  }
}

// Add weight.
class BoxWeight extends Box {
  double weight; // weight of box

  // construct clone of an object
  BoxWeight(BoxWeight ob) { // pass object to constructor
    super(ob);
    weight = ob.weight;
  }

  // constructor when all parameters are specified
  BoxWeight(double w, double h, double d, double m) {
    super(w, h, d); // call superclass constructor
    weight = m;
  }    

  // default constructor
  BoxWeight() {
    super();
    weight = -1;
  }

  // constructor used when cube is created
  BoxWeight(double len, double m) {
    super(len);
    weight = m;
  }
}

// Add shipping costs
class Shipment extends BoxWeight {
  double cost;

  // construct clone of an object
  Shipment(Shipment ob) { // pass object to constructor
    super(ob);
    cost = ob.cost;
  }

  // constructor when all parameters are specified
  Shipment(double w, double h, double d,
            double m, double c) {
    super(w, h, d, m); // call superclass constructor
    cost = c;
  }    

  // default constructor
  Shipment() {
    super();
    cost = -1;
  }

  // constructor used when cube is created
  Shipment(double len, double m, double c) {
    super(len, m);
    cost = c;
  }
}
  
class DemoShipment {
  public static void main(String args[]) {
    Shipment shipment1 = 
               new Shipment(10, 20, 15, 10, 3.41);
    Shipment shipment2 =
               new Shipment(2, 3, 4, 0.76, 1.28);

    double vol;

    vol = shipment1.volume();
    System.out.println("Volume of shipment1 is " + vol);
    System.out.println("Weight of shipment1 is "
                        + shipment1.weight);
    System.out.println("Shipping cost: $" + shipment1.cost);
    System.out.println();

    vol = shipment2.volume();
    System.out.println("Volume of shipment2 is " + vol);
    System.out.println("Weight of shipment2 is "
                        + shipment2.weight);
    System.out.println("Shipping cost: $" + shipment2.cost);
  }
}

listing 12
// Demonstrate when constructors are called.

// Create a super class.
class A {
  A() { 
    System.out.println("Inside A's constructor.");
  }
}

// Create a subclass by extending class A.
class B extends A {
  B() {
    System.out.println("Inside B's constructor.");
  }
}

// Create another subclass by extending B.
class C extends B {
  C() {
    System.out.println("Inside C's constructor.");
  }
}
  
class CallingCons {
  public static void main(String args[]) {
    C c = new C();
  }
}

listing 13
// Method overriding.
class A {
  int i, j;

  A(int a, int b) {
    i = a;
    j = b;
  }

  // display i and j
  void show() {
    System.out.println("i and j: " + i + " " + j);
  }
}

class B extends A {
  int k;

  B(int a, int b, int c) {
    super(a, b);
    k = c;
  }

  // display k -- this overrides show() in A
  void show() {
    System.out.println("k: " + k);
  }
}
  
class Override {
  public static void main(String args[]) {
    B subOb = new B(1, 2, 3);

    subOb.show(); // this calls show() in B
  }
}

listing 14
class B extends A {
  int k;

  B(int a, int b, int c) {
    super(a, b);
    k = c;
  }

  void show() {
    super.show(); // this calls A's show()
    System.out.println("k: " + k);
  }
}

listing 15
// Methods with differing type signatures are overloaded -- not overridden.
class A {
  int i, j;

  A(int a, int b) {
    i = a;
    j = b;
  }

  // display i and j
  void show() {
    System.out.println("i and j: " + i + " " + j);
  }
}

// Create a subclass by extending class A.
class B extends A {
  int k;

  B(int a, int b, int c) {
    super(a, b);
    k = c;
  }

  // overload show()
  void show(String msg) {
    System.out.println(msg + k);
  }
}
  
class Override {
  public static void main(String args[]) {
    B subOb = new B(1, 2, 3);

    subOb.show("This is k: "); // this calls show() in B
    subOb.show(); // this calls show() in A
  }
}

listing 16
// Dynamic Method Dispatch
class A {
   void callme() {
     System.out.println("Inside A's callme method");
  }
}

class B extends A {
  // override callme()
  void callme() {
    System.out.println("Inside B's callme method");
  }
}

class C extends A {
  // override callme()
  void callme() {
    System.out.println("Inside C's callme method");
  }
}

class Dispatch {
  public static void main(String args[]) {
    A a = new A(); // object of type A
    B b = new B(); // object of type B
    C c = new C(); // object of type C
    A r; // obtain a reference of type A    

    r = a; // r refers to an A object
    r.callme(); // calls A's version of callme

    r = b; // r refers to a B object
    r.callme(); // calls B's version of callme

    r = c; // r refers to a C object
    r.callme(); // calls C's version of callme
  }
}

listing 17
// Using run-time polymorphism.
class Figure {
  double dim1;
  double dim2; 

  Figure(double a, double b) {
    dim1 = a;
    dim2 = b;
  }

  double area() {
    System.out.println("Area for Figure is undefined.");
    return 0;
  }
}

class Rectangle extends Figure {
  Rectangle(double a, double b) {
    super(a, b);
  }

  // override area for rectangle
  double area() {
    System.out.println("Inside Area for Rectangle.");
    return dim1 * dim2;
  }
}

class Triangle extends Figure {
  Triangle(double a, double b) {
    super(a, b);
  }

  // override area for right triangle
  double area() {
    System.out.println("Inside Area for Triangle.");
    return dim1 * dim2 / 2;
  }
}

class FindAreas {
  public static void main(String args[]) {
    Figure f = new Figure(10, 10);
    Rectangle r = new Rectangle(9, 5);
    Triangle t = new Triangle(10, 8);
    
    Figure figref;

    figref = r;
    System.out.println("Area is " + figref.area());
    
    figref = t;
    System.out.println("Area is " + figref.area());
    
    figref = f;
    System.out.println("Area is " + figref.area());
  }
}

listing 18
// A Simple demonstration of abstract.
abstract class A {
  abstract void callme();

  // concrete methods are still allowed in abstract classes
  void callmetoo() {
    System.out.println("This is a concrete method.");
  }
}

class B extends A {
  void callme() {
    System.out.println("B's implementation of callme.");
  }
}

class AbstractDemo {
  public static void main(String args[]) {
    B b = new B();

    b.callme();
    b.callmetoo();
  }
}

listing 19
// Using abstract methods and classes.
abstract class Figure {
  double dim1;
  double dim2; 

  Figure(double a, double b) {
    dim1 = a;
    dim2 = b;
  }

  // area is now an an abstract method 
  abstract double area();
}

class Rectangle extends Figure {
  Rectangle(double a, double b) {
    super(a, b);
  }

  // override area for rectangle
  double area() {
    System.out.println("Inside Area for Rectangle.");
    return dim1 * dim2;
  }
}

class Triangle extends Figure {
  Triangle(double a, double b) {
    super(a, b);
  }

  // override area for right triangle
  double area() {
    System.out.println("Inside Area for Triangle.");
    return dim1 * dim2 / 2;
  }
}

class AbstractAreas {
  public static void main(String args[]) {
  // Figure f = new Figure(10, 10); // illegal now
    Rectangle r = new Rectangle(9, 5);
    Triangle t = new Triangle(10, 8);
    
    Figure figref; // this is OK, no object is created

    figref = r;
    System.out.println("Area is " + figref.area());
    
    figref = t;
    System.out.println("Area is " + figref.area());
  }
}

listing 20
class A {
  final void meth() {
    System.out.println("This is a final method.");
  }
}

class B extends A {
  void meth() { // ERROR! Can't override.
    System.out.println("Illegal!");
  }
}

listing 21
final class A {
  // ...
}

// The following class is illegal.
class B extends A { // ERROR! Can't subclass A
  // ...
}


 
/*************** 
 * Chapter  9  *
 ***************/

listing 1
package MyPackage;

listing 2
package java.awt.image;

listing 3
// A simple package
package MyPack;

class Balance {
  String name;
  double bal;

  Balance(String n, double b) {
    name = n;
    bal = b;
  }

  void show() {
    if(bal<0) 
      System.out.print("-->> ");
    System.out.println(name + ": $" + bal);
  }
}
  
class AccountBalance {
  public static void main(String args[]) {
    Balance current[] = new Balance[3];

    current[0] = new Balance("K. J. Fielding", 123.23);
    current[1] = new Balance("Will Tell", 157.02);
    current[2] = new Balance("Tom Jackson", -12.33);

    for(int i=0; i<3; i++) current[i].show();
  }
}

listing 4
package p1;

public class Protection {
  int n = 1;
  private int n_pri = 2;
  protected int n_pro = 3;
  public int n_pub = 4;

  public Protection() {
    System.out.println("base constructor");
    System.out.println("n = " + n);
    System.out.println("n_pri = " + n_pri);
    System.out.println("n_pro = " + n_pro);
    System.out.println("n_pub = " + n_pub);
  }
}

class Derived extends Protection {
  Derived() {
    System.out.println("derived constructor");
    System.out.println("n = " + n);

//  class only
//  System.out.println("n_pri = " + n_pri);

    System.out.println("n_pro = " + n_pro);
    System.out.println("n_pub = " + n_pub);
  }
}

class SamePackage {
  SamePackage() {
    Protection p = new Protection();
    System.out.println("same package constructor");
    System.out.println("n = " + p.n);

//  class only
//  System.out.println("n_pri = " + p.n_pri);

    System.out.println("n_pro = " + p.n_pro);
    System.out.println("n_pub = " + p.n_pub);
  }
}

listing 5
package p2;

class Protection2 extends p1.Protection {
  Protection2() {
    System.out.println("derived other package constructor");

//  class or package only
//  System.out.println("n = " + n);

//  class only
//  System.out.println("n_pri = " + n_pri);

    System.out.println("n_pro = " + n_pro);
    System.out.println("n_pub = " + n_pub);
  }
}

class OtherPackage {
  OtherPackage() {
    p1.Protection p = new p1.Protection();
    System.out.println("other package constructor");

//  class or package only
//  System.out.println("n = " + p.n);

//  class only
//  System.out.println("n_pri = " + p.n_pri);

//  class, subclass or package only
//  System.out.println("n_pro = " + p.n_pro);

    System.out.println("n_pub = " + p.n_pub);
  }
}

listing 6
// Demo package p1.
package p1;

// Instantiate the various classes in p1.
public class Demo {
  public static void main(String args[]) {
    Protection ob1 = new Protection();
    Derived ob2 = new Derived();
    SamePackage ob3 = new SamePackage();
  }
}


listing 7
// Demo package p2.
package p2;

// Instantiate the various classes in p2.
public class Demo {
  public static void main(String args[]) {
    Protection2 ob1 = new Protection2();
    OtherPackage ob2 = new OtherPackage();
  }
}

listing 8
import java.util.Date;
import java.io.*;

listing 9
import java.lang.*;

listing 10
import java.util.*;
class MyDate extends Date {
}

listing 11
class MyDate extends java.util.Date {
}

listing 12
package MyPack;

/* Now, the Balance class, its constructor, and its
   show() method are public.  This means that they can
   be used by non-subclass code outside their package.
*/
public class Balance {
  String name;
  double bal;

  public Balance(String n, double b) {
    name = n;
    bal = b;
  }

  public void show() {
    if(bal<0) 
      System.out.print("-->> ");
    System.out.println(name + ": $" + bal);
  }
}

listing 13
import MyPack.*;
  
class TestBalance {
  public static void main(String args[]) {
    
    /* Because Balance is public, you may use Balance 
       class and call its constructor. */
    Balance test = new Balance("J. J. Jaspers", 99.88);

    test.show(); // you may also call show()
  }
}

listing 14
interface Callback {
  void callback(int param);
}

listing 15
class Client implements Callback {
  // Implement Callback's interface
  public void callback(int p) {
    System.out.println("callback called with " + p);
  }
}

listing 16
class Client implements Callback {
  // Implement Callback's interface
  public void callback(int p) {
    System.out.println("callback called with " + p);
  }

  void nonIfaceMeth() {
    System.out.println("Classes that implement interfaces " +
                       "may also define other members, too.");
  }
}

listing 17
class TestIface {
  public static void main(String args[]) {
    Callback c = new Client();
    c.callback(42);
  }
}

listing 18
// Another implementation of Callback.
class AnotherClient implements Callback {
  // Implement Callback's interface
  public void callback(int p) {
    System.out.println("Another version of callback");
    System.out.println("p squared is " + (p*p));
  }
}

listing 19
class TestIface2 {
  public static void main(String args[]) {
    Callback c = new Client();
    AnotherClient ob = new AnotherClient();

    c.callback(42);

    c = ob; // c now refers to AnotherClient object
    c.callback(42);
  }
}

listing 20
abstract class Incomplete implements Callback {
  int a, b;
  void show() {
    System.out.println(a + " " + b);
  }
  // ...
}

listing 21
// Define an integer stack interface.
interface IntStack {
  void push(int item); // store an item
  int pop(); // retrieve an item
}

listing 22
// An implementation of IntStack that uses fixed storage.
class FixedStack implements IntStack {
  private int stck[];
  private int tos;

  // allocate and initialize stack
  FixedStack(int size) {
    stck = new int[size];
    tos = -1;
  }

  // Push an item onto the stack
  public void push(int item) {
    if(tos==stck.length-1) // use length member 
      System.out.println("Stack is full.");
    else 
      stck[++tos] = item;
  }

  // Pop an item from the stack
  public int pop() {
    if(tos < 0) {
      System.out.println("Stack underflow.");
      return 0;
    }
    else 
      return stck[tos--];
  }
}

class IFTest {
  public static void main(String args[]) {
    FixedStack mystack1 = new FixedStack(5);
    FixedStack mystack2 = new FixedStack(8);

    // push some numbers onto the stack
    for(int i=0; i<5; i++) mystack1.push(i);
    for(int i=0; i<8; i++) mystack2.push(i);

    // pop those numbers off the stack
    System.out.println("Stack in mystack1:");
    for(int i=0; i<5; i++) 
       System.out.println(mystack1.pop());

    System.out.println("Stack in mystack2:");
    for(int i=0; i<8; i++) 
       System.out.println(mystack2.pop());
  }
}

listing 23
// Implement a "growable" stack.
class DynStack implements IntStack {
  private int stck[];
  private int tos;

  // allocate and initialize stack
  DynStack(int size) {
    stck = new int[size];
    tos = -1;
  }

  // Push an item onto the stack
  public void push(int item) {
    // if stack is full, allocate a larger stack
    if(tos==stck.length-1) {
      int temp[] = new int[stck.length * 2]; // double size
      for(int i=0; i<stck.length; i++) temp[i] = stck[i];
      stck = temp;
      stck[++tos] = item;
    }
    else 
      stck[++tos] = item;
  }

  // Pop an item from the stack
  public int pop() {
    if(tos < 0) {
      System.out.println("Stack underflow.");
      return 0;
    }
    else 
      return stck[tos--];
  }
}

class IFTest2 {
  public static void main(String args[]) {
    DynStack mystack1 = new DynStack(5);
    DynStack mystack2 = new DynStack(8);

    // these loops cause each stack to grow
    for(int i=0; i<12; i++) mystack1.push(i);
    for(int i=0; i<20; i++) mystack2.push(i);

    System.out.println("Stack in mystack1:");
    for(int i=0; i<12; i++) 
       System.out.println(mystack1.pop());

    System.out.println("Stack in mystack2:");
    for(int i=0; i<20; i++) 
       System.out.println(mystack2.pop());
  }
}

listing 24
/* Create an interface variable and
   access stacks through it.
*/
class IFTest3 {
  public static void main(String args[]) {
    IntStack mystack; // create an interface reference variable
    DynStack ds = new DynStack(5);
    FixedStack fs = new FixedStack(8);

    mystack = ds; // load dynamic stack
    // push some numbers onto the stack
    for(int i=0; i<12; i++) mystack.push(i);

    mystack = fs; // load fixed stack
    for(int i=0; i<8; i++) mystack.push(i);


    mystack = ds; 
    System.out.println("Values in dynamic stack:");
    for(int i=0; i<12; i++) 
       System.out.println(mystack.pop());

    mystack = fs;
    System.out.println("Values in fixed stack:");
    for(int i=0; i<8; i++) 
       System.out.println(mystack.pop());
  }
}

listing 25
import java.util.Random;

interface SharedConstants {
  int NO = 0;
  int YES = 1;
  int MAYBE = 2;
  int LATER = 3;
  int SOON = 4;
  int NEVER = 5;
}

class Question implements SharedConstants {
  Random rand = new Random();
  int ask() {
    int prob = (int) (100 * rand.nextDouble());
    if (prob < 30)
      return NO;           // 30%
    else if (prob < 60)
      return YES;          // 30%
    else if (prob < 75)
      return LATER;        // 15%
    else if (prob < 98)
      return SOON;         // 13%
    else
      return NEVER;        // 2%
  }
}

class AskMe implements SharedConstants {
  static void answer(int result) {
    switch(result) {
      case NO:
        System.out.println("No");
        break;
      case YES:
        System.out.println("Yes");
        break;
      case MAYBE:
        System.out.println("Maybe");
        break;
      case LATER:
        System.out.println("Later");
        break;
      case SOON:
        System.out.println("Soon");
        break;
      case NEVER:
        System.out.println("Never");
        break;
    }
  }

  public static void main(String args[]) {
    Question q = new Question();
    answer(q.ask());
    answer(q.ask());
    answer(q.ask());
    answer(q.ask());
  }
}

listing 26
// One interface an extend another.
interface A {
  void meth1();
  void meth2();
}

// B now includes meth1() and meth2() -- it adds meth3().
interface B extends A {
  void meth3();
}

// This class must implement all of A and B
class MyClass implements B {
  public void meth1() {
    System.out.println("Implement meth1().");
  }

  public void meth2() {
    System.out.println("Implement meth2().");
  }

  public void meth3() {
    System.out.println("Implement meth3().");
  }
}

class IFExtend {
  public static void main(String arg[]) {
    MyClass ob = new MyClass();

    ob.meth1();
    ob.meth2();
    ob.meth3();
  }
}


 
/**************** 
 * Chapter  10  *
 ****************/

listing 1
class Exc0 {
  public static void main(String args[]) {
    int d = 0;
    int a = 42 / d;
  }
}

listing 2
class Exc1 {
  static void subroutine() {
    int d = 0;
    int a = 10 / d;
  }
  public static void main(String args[]) {
    Exc1.subroutine();
  }
}

listing 3
class Exc2 {
  public static void main(String args[]) {
    int d, a;

    try { // monitor a block of code.
      d = 0;
      a = 42 / d;
      System.out.println("This will not be printed.");
    } catch (ArithmeticException e) { // catch divide-by-zero error
      System.out.println("Division by zero.");
    }
    System.out.println("After catch statement.");
  }
}

listing 4
// Handle an exception and move on.
import java.util.Random;

class HandleError {
  public static void main(String args[]) {
    int a=0, b=0, c=0;
    Random r = new Random();

    for(int i=0; i<32000; i++) {
      try {
        b = r.nextInt();
        c = r.nextInt();
        a = 12345 / (b/c);
      } catch (ArithmeticException e) {
        System.out.println("Division by zero.");
        a = 0; // set a to zero and continue
      }
      System.out.println("a: " + a);
    }
  }
}

listing 5
catch (ArithmeticException e) {
  System.out.println("Exception: " + e);
  a = 0; // set a to zero and continue
}

listing 6
// Demonstrate multiple catch statements.
class MultiCatch {
  public static void main(String args[]) {
    try {
      int a = args.length;
      System.out.println("a = " + a);
      int b = 42 / a;
      int c[] = { 1 };
      c[42] = 99;
    } catch(ArithmeticException e) {
      System.out.println("Divide by 0: " + e);
    } catch(ArrayIndexOutOfBoundsException e) {
      System.out.println("Array index oob: " + e);
    }
    System.out.println("After try/catch blocks.");
  }
}

listing 7
/*  This program contains an error.
 
   A subclass must come before its superclass in 
   a series of catch statements. If not, 
   unreachable code will be created and a
   compile-time error will result.
*/
class SuperSubCatch {
  public static void main(String args[]) {
    try {
      int a = 0;
      int b = 42 / a;
    } catch(Exception e) {
      System.out.println("Generic Exception catch.");
    }
    /* This catch is never reached because
       ArithmeticException is a subclass of Exception. */
    catch(ArithmeticException e) { // ERROR - unreachable
      System.out.println("This is never reached.");
    }
  }
}

listing 8
// An example nested try statements.
class NestTry {
  public static void main(String args[]) {
    try {
      int a = args.length;

      /* If no command line args are present,
         the following statement will generate
         a divide-by-zero exception. */
      int b = 42 / a;

      System.out.println("a = " + a);

      try { // nested try block
        /* If one command line arg is used,
           then an divide-by-zero exception 
           will be generated by the following code. */
        if(a==1) a = a/(a-a); // division by zero

        /* If two command line args are used
           then generate an out-of-bounds exception. */
        if(a==2) {
          int c[] = { 1 };
          c[42] = 99; // generate an out-of-bounds exception
        }
      } catch(ArrayIndexOutOfBoundsException e) {
        System.out.println("Array index out-of-bounds: " + e);
      }

    } catch(ArithmeticException e) {
      System.out.println("Divide by 0: " + e);
    }
  }
}

listing 9
/* Try statements can be implicitly nested via
   calls to methods. */
class MethNestTry {
  static void nesttry(int a) {
    try { // nested try block
      /* If one command line arg is used,
         then an divide-by-zero exception 
         will be generated by the following code. */
      if(a==1) a = a/(a-a); // division by zero

      /* If two command line args are used
         then generate an out-of-bounds exception. */     
      if(a==2) {
        int c[] = { 1 };
        c[42] = 99; // generate an out-of-bounds exception
      }
    } catch(ArrayIndexOutOfBoundsException e) {
      System.out.println("Array index out-of-bounds: " + e);
    }
  }

  public static void main(String args[]) {
    try {
      int a = args.length;

      /* If no command line args are present,
         the following statement will generate
         a divide-by-zero exception. */
      int b = 42 / a;

      System.out.println("a = " + a);

      nesttry(a);
    } catch(ArithmeticException e) {
      System.out.println("Divide by 0: " + e);
    }
  }
}

listing 10
// Demonstrate throw.
class ThrowDemo {
  static void demoproc() {
    try {
      throw new NullPointerException("demo");
    } catch(NullPointerException e) {
      System.out.println("Caught inside demoproc.");
      throw e; // re-throw the exception
    }
  }

  public static void main(String args[]) {
    try {
      demoproc();
    } catch(NullPointerException e) {
      System.out.println("Recaught: " + e);
    }
  }
}

listing 11
throw new NullPointerException("demo");

listing 12
// This program contains an error and will not compile.
class ThrowsDemo {
  static void throwOne() {
    System.out.println("Inside throwOne.");
    throw new IllegalAccessException("demo");
  }
  public static void main(String args[]) {
    throwOne();
  }
}

listing 13
// This is now correct.
class ThrowsDemo {
  static void throwOne() throws IllegalAccessException {
    System.out.println("Inside throwOne.");
    throw new IllegalAccessException("demo");
  }
  public static void main(String args[]) {
    try {
      throwOne();
    } catch (IllegalAccessException e) {
      System.out.println("Caught " + e);
    }
  }
}

listing 14
// Demonstrate finally.
class FinallyDemo {
  // Through an exception out of the method.
  static void procA() {
    try {
      System.out.println("inside procA");
      throw new RuntimeException("demo");
    } finally {
      System.out.println("procA's finally");
    }
  }

  // Return from within a try block.
  static void procB() {
    try {
      System.out.println("inside procB");
      return;
    } finally {
      System.out.println("procB's finally");
    }
  }

  // Execute a try block normally.
  static void procC() {
    try {
      System.out.println("inside procC");
    } finally {
      System.out.println("procC's finally");
    }
  }

  public static void main(String args[]) {
    try {
      procA();
    } catch (Exception e) {
      System.out.println("Exception caught");
    }
    procB();
    procC();
  }
}


listing 15
// This program creates a custom exception type.
class MyException extends Exception {
  private int detail;

  MyException(int a) {
    detail = a;
  }

  public String toString() {
    return "MyException[" + detail + "]";
  }
}

class ExceptionDemo {
  static void compute(int a) throws MyException {
    System.out.println("Called compute(" + a + ")");
    if(a > 10)
      throw new MyException(a);
    System.out.println("Normal exit");
  }

  public static void main(String args[]) {
    try {
      compute(1);
      compute(20);
    } catch (MyException e) {
      System.out.println("Caught " + e);
    }
  }
}

listing 16
// Demonstrate exception chaining.
class ChainExcDemo {
  static void demoproc() {
    // create an exception
    NullPointerException e = 
      new NullPointerException("top layer");
  
    // add a cause
    e.initCause(new ArithmeticException("cause"));

    throw e;
  }

  public static void main(String args[]) {
    try {
      demoproc();
    } catch(NullPointerException e) {
      // display top level exception
      System.out.println("Caught: " + e);

      // display cause exception
      System.out.println("Original cause: " +
                          e.getCause());
    }
  }
}

 
/**************** 
 * Chapter  11  *
 ****************/

listing 1
// Controlling the main Thread.
class CurrentThreadDemo {
  public static void main(String args[]) {
    Thread t = Thread.currentThread();

    System.out.println("Current thread: " + t);

    // change the name of the thread
    t.setName("My Thread");
    System.out.println("After name change: " + t);

    try {
      for(int n = 5; n > 0; n--) {
        System.out.println(n);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println("Main thread interrupted");
    }
  }
}

listing 2
// Create a second thread.
class NewThread implements Runnable {
  Thread t;

  NewThread() {
    // Create a new, second thread
    t = new Thread(this, "Demo Thread");
    System.out.println("Child thread: " + t);
    t.start(); // Start the thread
  }

  // This is the entry point for the second thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Child Thread: " + i);
        Thread.sleep(500);
      }
    } catch (InterruptedException e) {
      System.out.println("Child interrupted.");
    }
    System.out.println("Exiting child thread.");
  }
}

class ThreadDemo {
  public static void main(String args[]) {
    new NewThread(); // create a new thread

    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Main Thread: " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println("Main thread interrupted.");
    }
    System.out.println("Main thread exiting.");
  }
}

listing 3
// Create a second thread by extending Thread
class NewThread extends Thread {

  NewThread() {
    // Create a new, second thread
    super("Demo Thread");
    System.out.println("Child thread: " + this);
    start(); // Start the thread
  }

  // This is the entry point for the second thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Child Thread: " + i);
        Thread.sleep(500);
      }
    } catch (InterruptedException e) {
      System.out.println("Child interrupted.");
    }
    System.out.println("Exiting child thread.");
  }
}

class ExtendThread {
  public static void main(String args[]) {
    new NewThread(); // create a new thread

    try {
      for(int i = 5; i > 0; i--) {
        System.out.println("Main Thread: " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println("Main thread interrupted.");
    }
    System.out.println("Main thread exiting.");
  }
}

listing 4
// Create multiple threads.
class NewThread implements Runnable {
  String name; // name of thread
  Thread t;

  NewThread(String threadname) {
    name = threadname;
    t = new Thread(this, name);
    System.out.println("New thread: " + t);
    t.start(); // Start the thread
  }

  // This is the entry point for thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println(name + ": " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println(name + "Interrupted");
    }
    System.out.println(name + " exiting.");
  }
}

class MultiThreadDemo {
  public static void main(String args[]) {
    new NewThread("One"); // start threads
    new NewThread("Two");
    new NewThread("Three");

    try {
      // wait for other threads to end
      Thread.sleep(10000);
    } catch (InterruptedException e) {
      System.out.println("Main thread Interrupted");
    }

    System.out.println("Main thread exiting.");
  }
}

listing 5
// Using join() to wait for threads to finish.
class NewThread implements Runnable {
  String name; // name of thread
  Thread t;

  NewThread(String threadname) {
    name = threadname;
    t = new Thread(this, name);
    System.out.println("New thread: " + t);
    t.start(); // Start the thread
  }

  // This is the entry point for thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println(name + ": " + i);
        Thread.sleep(1000);
      }
    } catch (InterruptedException e) {
      System.out.println(name + " interrupted.");
    }
    System.out.println(name + " exiting.");
  }
}

class DemoJoin {
  public static void main(String args[]) {
    NewThread ob1 = new NewThread("One");
    NewThread ob2 = new NewThread("Two");
    NewThread ob3 = new NewThread("Three");

    System.out.println("Thread One is alive: "
                        + ob1.t.isAlive());
    System.out.println("Thread Two is alive: "
                        + ob2.t.isAlive());
    System.out.println("Thread Three is alive: "
                        + ob3.t.isAlive());
    // wait for threads to finish
    try {
      System.out.println("Waiting for threads to finish.");
      ob1.t.join();
      ob2.t.join();
      ob3.t.join();
    } catch (InterruptedException e) {
      System.out.println("Main thread Interrupted");
    }

    System.out.println("Thread One is alive: "
                        + ob1.t.isAlive());
    System.out.println("Thread Two is alive: "
                        + ob2.t.isAlive());
    System.out.println("Thread Three is alive: "
                        + ob3.t.isAlive());

    System.out.println("Main thread exiting.");
  }
}

listing 6
// Demonstrate thread priorities.
class clicker implements Runnable {
  int click = 0;
  Thread t;
  private volatile boolean running = true;

  public clicker(int p) {
    t = new Thread(this);
    t.setPriority(p);
  }

  public void run() {
    while (running) {
      click++;
    }
  }

  public void stop() {
    running = false;
  }

  public void start() {
    t.start();
  }
}

class HiLoPri {
  public static void main(String args[]) {
    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
    clicker hi = new clicker(Thread.NORM_PRIORITY + 2);
    clicker lo = new clicker(Thread.NORM_PRIORITY - 2);

    lo.start();
    hi.start();
    try {
      Thread.sleep(10000);
    } catch (InterruptedException e) {
        System.out.println("Main thread interrupted.");
    }

    lo.stop();
    hi.stop();

    // Wait for child threads to terminate.
    try {
      hi.t.join();
      lo.t.join();
    } catch (InterruptedException e) {
      System.out.println("InterruptedException caught");
    }

    System.out.println("Low-priority thread: " + lo.click); 
    System.out.println("High-priority thread: " + hi.click);
  }
}

listing 7
// This program is not synchronized.
class Callme {
  void call(String msg) {
    System.out.print("[" + msg);
    try {
      Thread.sleep(1000);
    } catch(InterruptedException e) {
      System.out.println("Interrupted");
    }
    System.out.println("]");
  }
}

class Caller implements Runnable {
  String msg;
  Callme target;
  Thread t;

  public Caller(Callme targ, String s) {
    target = targ;
    msg = s;
    t = new Thread(this);
    t.start();
  }

  public void run() {
    target.call(msg);
  }
}

class Synch {
  public static void main(String args[]) {
    Callme target = new Callme();
    Caller ob1 = new Caller(target, "Hello");
    Caller ob2 = new Caller(target, "Synchronized");
   Caller ob3 = new Caller(target, "World");

    // wait for threads to end
    try {
      ob1.t.join();
      ob2.t.join();
      ob3.t.join();
    } catch(InterruptedException e) {
      System.out.println("Interrupted");
    }
  }
}

listing 8
// This program uses a synchronized block.
class Callme {
  void call(String msg) {
    System.out.print("[" + msg);
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      System.out.println("Interrupted");
    }
    System.out.println("]");
  }
}

class Caller implements Runnable {
  String msg;
  Callme target;
  Thread t;

  public Caller(Callme targ, String s) {
    target = targ;
    msg = s;
    t = new Thread(this);
    t.start();
  }

  // synchronize calls to call()
  public void run() {
    synchronized(target) { // synchronized block
      target.call(msg);
    }
  }
}

class Synch1 {
  public static void main(String args[]) {
    Callme target = new Callme();
    Caller ob1 = new Caller(target, "Hello");
    Caller ob2 = new Caller(target, "Synchronized");
    Caller ob3 = new Caller(target, "World");

    // wait for threads to end
    try {
      ob1.t.join();
      ob2.t.join();
      ob3.t.join();
    } catch(InterruptedException e) {
      System.out.println("Interrupted");
    }
  }
}

listing 9
// An incorrect implementation of a producer and consumer.
class Q {
  int n;

  synchronized int get() {
    System.out.println("Got: " + n);
    return n;
  }

  synchronized void put(int n) {
    this.n = n;
    System.out.println("Put: " + n);
  }
}

class Producer implements Runnable {
  Q q;

  Producer(Q q) {
    this.q = q;
    new Thread(this, "Producer").start();
  }

  public void run() {
    int i = 0;

    while(true) {
      q.put(i++);
    }
  }
}

class Consumer implements Runnable {
  Q q;

  Consumer(Q q) {
    this.q = q;
    new Thread(this, "Consumer").start();
  }

  public void run() {
    while(true) {
      q.get();
    }
  }
}

class PC {
  public static void main(String args[]) {
    Q q = new Q();
    new Producer(q);
    new Consumer(q);

    System.out.println("Press Control-C to stop.");
  }
}

listing 10
// A correct implementation of a producer and consumer.
class Q {
  int n;
  boolean valueSet = false;

  synchronized int get() {
    if(!valueSet)
      try {
        wait();

     } catch(InterruptedException e) {
        System.out.println("InterruptedException caught");
      }

      System.out.println("Got: " + n);
      valueSet = false;
      notify();
      return n;
  }

  synchronized void put(int n) {
    if(valueSet)
      try {
        wait();
      } catch(InterruptedException e) {
        System.out.println("InterruptedException caught");
      }

      this.n = n;
      valueSet = true;
      System.out.println("Put: " + n);
      notify();
  }
}

class Producer implements Runnable {
  Q q;

  Producer(Q q) {
    this.q = q;
    new Thread(this, "Producer").start();
  }

  public void run() {
    int i = 0;

    while(true) {
      q.put(i++);
    }
  }
}

class Consumer implements Runnable {
  Q q;

  Consumer(Q q) {
    this.q = q;
    new Thread(this, "Consumer").start();
  }

  public void run() {
    while(true) {
      q.get();
    }
  }
}

class PCFixed {
  public static void main(String args[]) {
    Q q = new Q();
    new Producer(q);
    new Consumer(q);

    System.out.println("Press Control-C to stop.");
  }
}

listing 11
// An example of deadlock.
class A {
  synchronized void foo(B b) {
    String name = Thread.currentThread().getName();

    System.out.println(name + " entered A.foo");

    try {
      Thread.sleep(1000);
    } catch(Exception e) {
      System.out.println("A Interrupted");
    }

    System.out.println(name + " trying to call B.last()");
    b.last();
  }

  synchronized void last() {
    System.out.println("Inside A.last");
  }
}

class B {
  synchronized void bar(A a) {
    String name = Thread.currentThread().getName();
    System.out.println(name + " entered B.bar");

    try {
      Thread.sleep(1000);
    } catch(Exception e) {
      System.out.println("B Interrupted");
    }

    System.out.println(name + " trying to call A.last()");
    a.last();
  }

  synchronized void last() {
    System.out.println("Inside A.last");
  }
}

class Deadlock implements Runnable {
  A a = new A();
  B b = new B();

  Deadlock() {
    Thread.currentThread().setName("MainThread");
    Thread t = new Thread(this, "RacingThread");
    t.start();

    a.foo(b); // get lock on a in this thread.
    System.out.println("Back in main thread");
  }

  public void run() {
    b.bar(a); // get lock on b in other thread.
    System.out.println("Back in other thread");
  }

  public static void main(String args[]) {
    new Deadlock();
  }
}

listing 12
// Using suspend() and resume().
class NewThread implements Runnable {
  String name; // name of thread
  Thread t;

  NewThread(String threadname) {
    name = threadname;
    t = new Thread(this, name);
    System.out.println("New thread: " + t);
    t.start(); // Start the thread
  }

  // This is the entry point for thread.
  public void run() {
    try {
      for(int i = 15; i > 0; i--) {
        System.out.println(name + ": " + i);
        Thread.sleep(200);
      }
    } catch (InterruptedException e) {
      System.out.println(name + " interrupted.");
    }
    System.out.println(name + " exiting.");
  }
}

class SuspendResume {
  public static void main(String args[]) {
    NewThread ob1 = new NewThread("One");
    NewThread ob2 = new NewThread("Two");

    try {
      Thread.sleep(1000);
      ob1.t.suspend();
      System.out.println("Suspending thread One");
      Thread.sleep(1000);
      ob1.t.resume();
      System.out.println("Resuming thread One");
      ob2.t.suspend();
      System.out.println("Suspending thread Two");
      Thread.sleep(1000);
      ob2.t.resume();
      System.out.println("Resuming thread Two");
    } catch (InterruptedException e) {
      System.out.println("Main thread Interrupted");
    }

    // wait for threads to finish
    try {
      System.out.println("Waiting for threads to finish.");
      ob1.t.join();
      ob2.t.join();
    } catch (InterruptedException e) {
      System.out.println("Main thread Interrupted");
    }
    System.out.println("Main thread exiting.");
  }
}

listing 13
// Suspending and resuming a thread for Java 2
class NewThread implements Runnable {
  String name; // name of thread
  Thread t;
  boolean suspendFlag;
  
  NewThread(String threadname) {
    name = threadname;
    t = new Thread(this, name);
    System.out.println("New thread: " + t);
    suspendFlag = false;
    t.start(); // Start the thread
  }

  // This is the entry point for thread.
  public void run() {
    try {
      for(int i = 15; i > 0; i--) {
        System.out.println(name + ": " + i);
        Thread.sleep(200);
        synchronized(this) {
          while(suspendFlag) {
            wait();
          }
        }
      }
    } catch (InterruptedException e) {
      System.out.println(name + " interrupted.");
    }
    System.out.println(name + " exiting.");
  }

  void mysuspend() {
    suspendFlag = true;
  }

  synchronized void myresume() {
    suspendFlag = false;
    notify();
  }
}

class SuspendResume {
  public static void main(String args[]) {
    NewThread ob1 = new NewThread("One");
    NewThread ob2 = new NewThread("Two");

    try {
      Thread.sleep(1000);
      ob1.mysuspend();
      System.out.println("Suspending thread One");
      Thread.sleep(1000);
      ob1.myresume();
      System.out.println("Resuming thread One");
      ob2.mysuspend();
      System.out.println("Suspending thread Two");
      Thread.sleep(1000);
      ob2.myresume();
      System.out.println("Resuming thread Two");
    } catch (InterruptedException e) {
      System.out.println("Main thread Interrupted");
    }

    // wait for threads to finish
    try {
      System.out.println("Waiting for threads to finish.");
      ob1.t.join();
      ob2.t.join();
    } catch (InterruptedException e) {
      System.out.println("Main thread Interrupted");
    }
 
    System.out.println("Main thread exiting.");
  }
}

 
 
/**************** 
 * Chapter  12  *
 ****************/

listing 1
// Use a BufferedReader to read characters from the console.
import java.io.*;

class BRRead {
  public static void main(String args[]) 
    throws IOException
  {
    char c;
    BufferedReader br = new
            BufferedReader(new InputStreamReader(System.in));
    System.out.println("Enter characters, 'q' to quit.");

    // read characters
    do {
      c = (char) br.read();
      System.out.println(c);
    } while(c != 'q');
  }
}

listing 2
// Read a string from console using a BufferedReader.
import java.io.*;

class BRReadLines {
  public static void main(String args[]) 
    throws IOException
  {
    // create a BufferedReader using System.in
    BufferedReader br = new BufferedReader(new 
                            InputStreamReader(System.in));
    String str;

    System.out.println("Enter lines of text.");
    System.out.println("Enter 'stop' to quit.");
    do {
      str = br.readLine();
      System.out.println(str);
    } while(!str.equals("stop"));
  }
}

listing 3
// A tiny editor.
import java.io.*;

class TinyEdit {
  public static void main(String args[]) 
    throws IOException
  {
    // create a BufferedReader using System.in
    BufferedReader br = new BufferedReader(new 
                            InputStreamReader(System.in));
    String str[] = new String[100];

    System.out.println("Enter lines of text.");
    System.out.println("Enter 'stop' to quit.");
    for(int i=0; i<100; i++) {
      str[i] = br.readLine();
      if(str[i].equals("stop")) break;
    }

    System.out.println("\nHere is your file:");

    // display the lines 
    for(int i=0; i<100; i++) {
      if(str[i].equals("stop")) break;
      System.out.println(str[i]);
    }
  }
}

listing 4
// Demonstrate System.out.write().
class WriteDemo {
  public static void main(String args[]) {
    int b;

    b = 'A';
    System.out.write(b);
    System.out.write('\n');
  }
}

listing 5
// Demonstrate PrintWriter
import java.io.*;

public class PrintWriterDemo {
  public static void main(String args[]) {
    PrintWriter pw = new PrintWriter(System.out, true);
    pw.println("This is a string");
    int i = -7;
    pw.println(i);
    double d = 4.5e-7;
    pw.println(d);
  }
}

listing 6
/* Display a text file.

   To use this program, specify the name 
   of the file that you want to see.
   For example, to see a file called TEST.TXT,
   use the following command line.

   java ShowFile TEST.TXT
*/

import java.io.*;

class ShowFile {
  public static void main(String args[]) 
    throws IOException
  {
    int i;
    FileInputStream fin;

    try {
      fin = new FileInputStream(args[0]);
    } catch(FileNotFoundException e) {
      System.out.println("File Not Found");
      return;
    } catch(ArrayIndexOutOfBoundsException e) {
      System.out.println("Usage: ShowFile File");
      return;
    }

    // read characters until EOF is encountered
    do {
      i = fin.read();
      if(i != -1) System.out.print((char) i);
    } while(i != -1);

    fin.close();
  }
}

listing 7
/* Copy a text file.

   To use this program, specify the name 
   of the source file and the destination file.
   For example, to copy a file called FIRST.TXT
   to a file called SECOND.TXT, use the following
   command line.
   java CopyFile FIRST.TXT SECOND.TXT
*/

import java.io.*;

class CopyFile {
  public static void main(String args[]) 
    throws IOException
  {
    int i;
    FileInputStream fin;
    FileOutputStream fout;

    try {
      // open input file
      try {
        fin = new FileInputStream(args[0]);
      } catch(FileNotFoundException e) {
        System.out.println("Input File Not Found");
        return;
      }

      // open output file
      try {
        fout = new FileOutputStream(args[1]);
      } catch(FileNotFoundException e) {
        System.out.println("Error Opening Output File");
        return;
      }
    } catch(ArrayIndexOutOfBoundsException e) {
      System.out.println("Usage: CopyFile From To");
      return;
    }

    // Copy File
    try {
      do {
        i = fin.read();
        if(i != -1) fout.write(i);
      } while(i != -1);
    } catch(IOException e) {
      System.out.println("File Error");
    }

    fin.close();
    fout.close();
  }
}

listing 8
import java.awt.*;
import java.applet.*;

public class SimpleApplet extends Applet {
  public void paint(Graphics g) {
    g.drawString("A Simple Applet", 20, 20);
  }
}

listing 9
import java.awt.*;
import java.applet.*;
/*
<applet code="SimpleApplet" width=200 height=60>
</applet>
*/

public class SimpleApplet extends Applet {
  public void paint(Graphics g) {
    g.drawString("A Simple Applet", 20, 20);
  }
}

listing 10
// Demonstrate instanceof operator.
class A {
  int i, j;
}

class B {
  int i, j;
}

class C extends A {
  int k;
}

class D extends A {
  int k;
}

class InstanceOf {
  public static void main(String args[]) {
    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    if(a instanceof A) 
      System.out.println("a is instance of A");
    if(b instanceof B) 
      System.out.println("b is instance of B");
    if(c instanceof C) 
      System.out.println("c is instance of C");
    if(c instanceof A) 
      System.out.println("c can be cast to A");

    if(a instanceof C) 
      System.out.println("a can be cast to C");

    System.out.println();

    // compare types of derived types
    A ob;

    ob = d; // A reference to d
    System.out.println("ob now refers to d");
    if(ob instanceof D) 
      System.out.println("ob is instance of D");

    System.out.println();

    ob = c; // A reference to c
    System.out.println("ob now refers to c");

    if(ob instanceof D) 
      System.out.println("ob can be cast to D");
    else
      System.out.println("ob cannot be cast to D");

    if(ob instanceof A) 
      System.out.println("ob can be cast to A");

    System.out.println();

    // all objects can be cast to Object
    if(a instanceof Object) 
      System.out.println("a may be cast to Object");
    if(b instanceof Object) 
      System.out.println("b may be cast to Object");
    if(c instanceof Object) 
      System.out.println("c may be cast to Object");
    if(d instanceof Object) 
      System.out.println("d may be cast to Object");
  }
}

listing 11
// A simple example that uses a native method.
public class NativeDemo {
  int i;
  public static void main(String args[]) {
    NativeDemo ob = new NativeDemo();

    ob.i = 10;
    System.out.println("This is ob.i before the native method:" + 
                       ob.i);
    ob.test(); // call a native method
    System.out.println("This is ob.i after the native method:" + 
                       ob.i);
  }
  // declare native method
  public native void test() ;

  // load DLL that contains static method
  static {
    System.loadLibrary("NativeDemo");
  }
}

listing 12
/* This file contains the C version of the
   test() method.
*/

#include <jni.h>
#include "NativeDemo.h"
#include <stdio.h>

JNIEXPORT void JNICALL Java_NativeDemo_test(JNIEnv *env, jobject obj)
{
  jclass cls;
  jfieldID fid;
  jint i;

  printf("Starting the native method.\n");
  cls = (*env)->GetObjectClass(env, obj); 
  fid = (*env)->GetFieldID(env, cls, "i", "I");

  if(fid == 0) {
    printf("Could not get field id.\n");
    return;
  }
  i = (*env)->GetIntField(env, obj, fid);
  printf("i = %d\n", i);
  (*env)->SetIntField(env, obj, fid, 2*i);
  printf("Ending the native method.\n");
}

listing 13
// Demonstrate assert.
class AssertDemo {
  static int val = 3;
 
  // Return an integer.
  static int getnum() {
    return val--;
  }

  public static void main(String args[]) 
  {
    int n;

    for(int i=0; i < 10; i++) {
      n = getnum();

      assert n > 0; // will fail with n is 0
  
      System.out.println("n is " + n);
    } 
  }
}

listing 14
// A poor way to use assert!!!
class AssertDemo {
  // get a random number generator
  static int val = 3;
 
  // Return an integer.
  static int getnum() {
    return val--;
  }

  public static void main(String args[]) 
  {
    int n = 0;

    for(int i=0; i < 10; i++) {

      assert (n = getnum()) > 0; // This is not a good idea!
  
      System.out.println("n is " + n);
    } 
  }
}

 
 /**************** 
  * Chapter  13  *
  ****************/

listing 1
// Construct one String from another.
class MakeString {
  public static void main(String args[]) {
    char c[] = {'J', 'a', 'v', 'a'};
    String s1 = new String(c);
    String s2 = new String(s1); 

    System.out.println(s1);
    System.out.println(s2);
  }
}

listing 2
// Construct string from subset of char array.
class SubStringCons {
  public static void main(String args[]) {
    byte ascii[] = {65, 66, 67, 68, 69, 70 };

    String s1 = new String(ascii);
    System.out.println(s1);

    String s2 = new String(ascii, 2, 3);
    System.out.println(s2);
  }
}

listing 3
// Using concatenation to prevent long lines.
class ConCat {
  public static void main(String args[]) {
    String longStr = "This could have been " +
      "a very long line that would have " +
      "wrapped around.  But string concatenation " +
      "prevents this.";

    System.out.println(longStr);
  }
}

listing 4
// Override toString() for Box class.
class Box {
  double width;
  double height;
  double depth;

  Box(double w, double h, double d) {
    width = w;
    height = h;
    depth = d;
  }

  public String toString() {
    return "Dimensions are " + width + " by " + 
            depth + " by " + height + ".";
  }
}

class toStringDemo {
  public static void main(String args[]) {
    Box b = new Box(10, 12, 14);
    String s = "Box b: " + b; // concatenate Box object

    System.out.println(b); // convert Box to string
    System.out.println(s);
  }
}

listing 5
class getCharsDemo {
  public static void main(String args[]) {
    String s = "This is a demo of the getChars method.";
    int start = 10;
    int end = 14;
    char buf[] = new char[end - start];

    s.getChars(start, end, buf, 0);
    System.out.println(buf);
  }
}

listing 6
// Demonstrate equals() and equalsIgnoreCase().
class equalsDemo {
  public static void main(String args[]) {
    String s1 = "Hello";
    String s2 = "Hello";
    String s3 = "Good-bye";
    String s4 = "HELLO";
    System.out.println(s1 + " equals " + s2 + " -> " +
                       s1.equals(s2));
    System.out.println(s1 + " equals " + s3 + " -> " +
                       s1.equals(s3));
    System.out.println(s1 + " equals " + s4 + " -> " +
                       s1.equals(s4));
    System.out.println(s1 + " equalsIgnoreCase " + s4 + " -> " +
                       s1.equalsIgnoreCase(s4));
  }
}

listing 7
// equals() vs ==
class EqualsNotEqualTo {
  public static void main(String args[]) {
    String s1 = "Hello";
    String s2 = new String(s1);

    System.out.println(s1 + " equals " + s2 + " -> " +  
                       s1.equals(s2));
    System.out.println(s1 + " == " + s2 + " -> " + (s1 == s2));
  }
}

listing 8
// A bubble sort for Strings.
class SortString {
  static String arr[] = {
    "Now", "is", "the", "time", "for", "all", "good", "men",
    "to", "come", "to", "the", "aid", "of", "their", "country"
  };
  public static void main(String args[]) {
    for(int j = 0; j < arr.length; j++) {
      for(int i = j + 1; i < arr.length; i++) {
        if(arr[i].compareTo(arr[j]) < 0) {
          String t = arr[j];
          arr[j] = arr[i];
          arr[i] = t;
        }
      }
      System.out.println(arr[j]);
    }
  }
}

listing 9
// Demonstrate indexOf() and lastIndexOf().
class indexOfDemo {
  public static void main(String args[]) {
    String s = "Now is the time for all good men " +
               "to come to the aid of their country.";

    System.out.println(s);
    System.out.println("indexOf(t) = " +
                       s.indexOf('t'));
    System.out.println("lastIndexOf(t) = " +
                       s.lastIndexOf('t'));
    System.out.println("indexOf(the) = " +
                       s.indexOf("the"));
    System.out.println("lastIndexOf(the) = " +
                       s.lastIndexOf("the"));
    System.out.println("indexOf(t, 10) = " +
                       s.indexOf('t', 10));
    System.out.println("lastIndexOf(t, 60) = " +
                       s.lastIndexOf('t', 60));
    System.out.println("indexOf(the, 10) = " +
                       s.indexOf("the", 10));
    System.out.println("lastIndexOf(the, 60) = " +
                       s.lastIndexOf("the", 60));
  }
}

listing 10
// Substring replacement.
class StringReplace {
  public static void main(String args[]) {
    String org = "This is a test. This is, too.";
    String search = "is";
    String sub = "was";
    String result = "";
    int i;

    do { // replace all matching substrings
      System.out.println(org);
      i = org.indexOf(search);
      if(i != -1) {
        result = org.substring(0, i);
        result = result + sub;
        result = result + org.substring(i + search.length());
        org = result;
      }
    } while(i != -1);

  }
}

listing 11
// Using trim() to process commands.
import java.io.*;

class UseTrim {
  public static void main(String args[]) 
    throws IOException
  {
    // create a BufferedReader using System.in
    BufferedReader br = new
      BufferedReader(new InputStreamReader(System.in));
    String str;

    System.out.println("Enter 'stop' to quit.");
    System.out.println("Enter State: ");
    do {
      str = br.readLine();
      str = str.trim(); // remove whitespace

      if(str.equals("Illinois"))
        System.out.println("Capital is Springfield.");
      else if(str.equals("Missouri"))
        System.out.println("Capital is Jefferson City.");
      else if(str.equals("California"))
        System.out.println("Capital is Sacramento.");
      else if(str.equals("Washington"))
        System.out.println("Capital is Olympia.");
      // ... 
    } while(!str.equals("stop"));
  }
}

listing 12
// Demonstrate toUpperCase() and toLowerCase().

class ChangeCase {
  public static void main(String args[]) 
  {
    String s = "This is a test.";

    System.out.println("Original: " + s);

    String upper = s.toUpperCase();
    String lower = s.toLowerCase();

    System.out.println("Uppercase: " + upper);
    System.out.println("Lowercase: " + lower);
  }
}

listing 13
// StringBuffer length vs. capacity.
class StringBufferDemo {
  public static void main(String args[]) {
    StringBuffer sb = new StringBuffer("Hello");

    System.out.println("buffer = " + sb);
    System.out.println("length = " + sb.length());
    System.out.println("capacity = " + sb.capacity());
  }
}

listing 14
// Demonstrate charAt() and setCharAt().
class setCharAtDemo {
  public static void main(String args[]) {
    StringBuffer sb = new StringBuffer("Hello");
    System.out.println("buffer before = " + sb);
    System.out.println("charAt(1) before = " + sb.charAt(1));
      sb.setCharAt(1, 'i');
      sb.setLength(2);
      System.out.println("buffer after = " + sb);
      System.out.println("charAt(1) after = " + sb.charAt(1));
  }
}

listing 15
// Demonstrate append().
class appendDemo {
  public static void main(String args[]) {
    String s;
    int a = 42;
    StringBuffer sb = new StringBuffer(40);

    s = sb.append("a = ").append(a).append("!").toString();
    System.out.println(s);
  }
}

listing 16
// Demonstrate insert().
class insertDemo {
  public static void main(String args[]) {
    StringBuffer sb = new StringBuffer("I Java!");

    sb.insert(2, "like ");
    System.out.println(sb);
  }
}

listing 17
// Using reverse() to reverse a StringBuffer.
class ReverseDemo {
  public static void main(String args[]) {
    StringBuffer s = new StringBuffer("abcdef");

    System.out.println(s);
    s.reverse();
    System.out.println(s);
  }
}

listing 18
// Demonstrate delete() and deleteCharAt()
class deleteDemo {
  public static void main(String args[]) {
    StringBuffer sb = new StringBuffer("This is a test.");

    sb.delete(4, 7);
    System.out.println("After delete: " + sb);

    sb.deleteCharAt(0);
    System.out.println("After deleteCharAt: " + sb);
  }
}

listing 19
// Demonstrate replace()
class replaceDemo {
  public static void main(String args[]) {
    StringBuffer sb = new StringBuffer("This is a test.");

    sb.replace(5, 7, "was");
    System.out.println("After replace: " + sb);
  }
}

listing 20
// Demonstrate replace()
class IndexOfDemo {
  public static void main(String args[]) {
    StringBuffer sb = new StringBuffer("one two one");
    int i;

    i = sb.indexOf("one");
    System.out.println("First index: " + i);

    i = sb.lastIndexOf("one");
    System.out.println("Last index: " + i);
  }
}


 
/**************** 
 * Chapter  14  *
 ****************/

listing 1
class DoubleDemo {
  public static void main(String args[]) {
    Double d1 = new Double(3.14159);
    Double d2 = new Double("314159E-5");

    System.out.println(d1 + " = " + d2 + " -> " + d1.equals(d2));
  }
}

listing 2
// Demonstrate isInfinite() and isNaN().
class InfNaN {
  public static void main(String args[]) {
    Double d1 = new Double(1/0.);
    Double d2 = new Double(0/0.);

    System.out.println(d1 + ": " + d1.isInfinite() + ", " + d1.isNaN());
    System.out.println(d2 + ": " + d2.isInfinite() + ", " + d2.isNaN());
  }
}

listing 3
/* This program sums a list of numbers entered
   by the user.  It converts the string representation
   of each number into an int using parseInt().
*/

import java.io.*;

class ParseDemo {
  public static void main(String args[]) 
    throws IOException
  {
    // create a BufferedReader using System.in
    BufferedReader br = new
      BufferedReader(new InputStreamReader(System.in));
    String str;
    int i;
    int sum=0;
    
    System.out.println("Enter numbers, 0 to quit.");
    do {
      str = br.readLine();
      try {
        i = Integer.parseInt(str);
      } catch(NumberFormatException e) {
        System.out.println("Invalid format");
        i = 0;
      }
      sum += i;
      System.out.println("Current sum is: " + sum);
    } while(i != 0);
  }
}

listing 4
/* Convert an integer into binary, hexadecimal,
   and octal.
*/

class StringConversions {
  public static void main(String args[]) {
    int num = 19648;

    System.out.println(num + " in binary: " +
                       Integer.toBinaryString(num));

    System.out.println(num + " in octal: " +
                       Integer.toOctalString(num));

    System.out.println(num + " in hexadecimal: " +
                       Integer.toHexString(num));
  }
}

listing 5
// Demonstrate several Is... methods.

class IsDemo {
  public static void main(String args[]) {
    char a[] = {'a', 'b', '5', '?', 'A', ' '};

    for(int i=0; i<a.length; i++) {
      if(Character.isDigit(a[i]))
        System.out.println(a[i] + " is a digit.");
      if(Character.isLetter(a[i]))
        System.out.println(a[i] + " is a letter.");
      if(Character.isWhitespace(a[i]))
        System.out.println(a[i] + " is whitespace.");
      if(Character.isUpperCase(a[i]))
        System.out.println(a[i] + " is uppercase.");
      if(Character.isLowerCase(a[i]))
        System.out.println(a[i] + " is lowercase.");
    }
  }
}

listing 6
// Demonstrate totalMemory(), freeMemory() and gc().

class MemoryDemo {
  public static void main(String args[]) {
    Runtime r = Runtime.getRuntime();
    long mem1, mem2;
    Integer someints[] = new Integer[1000];

    System.out.println("Total memory is: " +
                       r.totalMemory());

    mem1 = r.freeMemory();
    System.out.println("Initial free memory: " + mem1);
    r.gc();
    mem1 = r.freeMemory();
    System.out.println("Free memory after garbage collection: "
                       + mem1);

    for(int i=0; i<1000; i++)
      someints[i] = new Integer(i); // allocate integers

    mem2 = r.freeMemory();
    System.out.println("Free memory after allocation: "
                       + mem2);
    System.out.println("Memory used by allocation: "
                       + (mem1-mem2));

    // discard Integers
    for(int i=0; i<1000; i++) someints[i] = null;

    r.gc(); // request garbage collection

    mem2 = r.freeMemory();
    System.out.println("Free memory after collecting" +
                       " discarded Integers: " + mem2);

  }
}

listing 7
// Demonstrate exec().
class ExecDemo {
  public static void main(String args[]) {
    Runtime r = Runtime.getRuntime();
    Process p = null;

    try {
      p = r.exec("notepad");
    } catch (Exception e) {
      System.out.println("Error executing notepad.");
    }
  }
}

listing 8
// Wait until notepad is terminated.
class ExecDemoFini {
  public static void main(String args[]) {
    Runtime r = Runtime.getRuntime();
    Process p = null;

    try {
      p = r.exec("notepad");
      p.waitFor();
    } catch (Exception e) {
      System.out.println("Error executing notepad.");
    }
    System.out.println("Notepad returned " + p.exitValue());
  }
}

listing 9
// Timing program execution.

class Elapsed {
  public static void main(String args[]) {
    long start, end;

    System.out.println("Timing a for loop from 0 to 1,000,000");

    // time a for loop from 0 to 1,000,000    
    start = System.currentTimeMillis(); // get starting time
    for(int i=0; i < 1000000; i++) ;
    end = System.currentTimeMillis(); // get ending time

    System.out.println("Elapsed time: " + (end-start));
  }
}

listing 10
// Using arraycopy().

class ACDemo {
  static byte a[] = { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74 };
  static byte b[] = { 77, 77, 77, 77, 77, 77, 77, 77, 77, 77 };

  public static void main(String args[]) {
    System.out.println("a = " + new String(a));
    System.out.println("b = " + new String(b));
    System.arraycopy(a, 0, b, 0, a.length);
    System.out.println("a = " + new String(a));
    System.out.println("b = " + new String(b));
    System.arraycopy(a, 0, a, 1, a.length - 1);
    System.arraycopy(b, 1, b, 0, b.length - 1);
    System.out.println("a = " + new String(a));
    System.out.println("b = " + new String(b));
  }
}

listing 11
class ShowUserDir {
  public static void main(String args[]) {
    System.out.println(System.getProperty("user.dir"));
  }
}

listing 12
// Demonstrate the clone() method.

class TestClone implements Cloneable {
  int a;
  double b;

  // This method calls Object's clone().
  TestClone cloneTest() {
    try {
      // call clone in Object.
      return (TestClone) super.clone();
    } catch(CloneNotSupportedException e) {
      System.out.println("Cloning not allowed.");
      return this;
    }
  }
}

class CloneDemo {
  public static void main(String args[]) {
    TestClone x1 = new TestClone();
    TestClone x2;

    x1.a = 10;
    x1.b = 20.98;

    x2 = x1.cloneTest(); // clone x1

    System.out.println("x1: " + x1.a + " " + x1.b);
    System.out.println("x2: " + x2.a + " " + x2.b);
  }
}

listing 13
// Override the clone() method.

class TestClone implements Cloneable {
  int a;
  double b;

  // clone() is now overridden and is public.
  public Object clone() {
    try {
      // call clone in Object.
      return super.clone();
    } catch(CloneNotSupportedException e) {
      System.out.println("Cloning not allowed.");
      return this;
    }
  }
}

class CloneDemo2 {
  public static void main(String args[]) {
    TestClone x1 = new TestClone();
    TestClone x2;

    x1.a = 10;
    x1.b = 20.98;

    // here, clone() is called directly.
    x2 = (TestClone) x1.clone(); 

    System.out.println("x1: " + x1.a + " " + x1.b);
    System.out.println("x2: " + x2.a + " " + x2.b);
  }
}

listing 14
// Demonstrate Run-Time Type Information.

class X {
  int a;
  float b;
}

class Y extends X {
  double c;
}

class RTTI {
  public static void main(String args[]) {
    X x = new X();
    Y y = new Y();
    Class clObj;

    clObj = x.getClass(); // get Class reference
    System.out.println("x is object of type: " +
                       clObj.getName());

    clObj = y.getClass(); // get Class reference
    System.out.println("y is object of type: " +
                       clObj.getName());
    clObj = clObj.getSuperclass();
    System.out.println("y's superclass is " +
                       clObj.getName());
  }
}

listing 15
// Demonstrate toDegrees() and toRadians().
class Angles {
  public static void main(String args[]) {
    double theta = 120.0;

    System.out.println(theta + " degrees is " +
                       Math.toRadians(theta) + " radians.");

    theta = 1.312;
    System.out.println(theta + " radians is " +
                       Math.toDegrees(theta) + " degrees.");
  }
}

listing 16
// Demonstrate thread groups.
class NewThread extends Thread {
  boolean suspendFlag;

  NewThread(String threadname, ThreadGroup tgOb) {
    super(tgOb, threadname);
    System.out.println("New thread: " + this);
    suspendFlag = false;
    start(); // Start the thread
  }

  // This is the entry point for thread.
  public void run() {
    try {
      for(int i = 5; i > 0; i--) {
        System.out.println(getName() + ": " + i);
        Thread.sleep(1000);
        synchronized(this) {
          while(suspendFlag) {
            wait();
          }
        }
      }
    } catch (Exception e) {
      System.out.println("Exception in " + getName());
    }
    System.out.println(getName() + " exiting.");
  }

  void mysuspend() {
    suspendFlag = true;
  }

  synchronized void myresume() {
    suspendFlag = false;
    notify();
  }
}

class ThreadGroupDemo {
  public static void main(String args[]) {
    ThreadGroup groupA = new ThreadGroup("Group A");
    ThreadGroup groupB = new ThreadGroup("Group B");

    NewThread ob1 = new NewThread("One", groupA);
    NewThread ob2 = new NewThread("Two", groupA);
    NewThread ob3 = new NewThread("Three", groupB);
    NewThread ob4 = new NewThread("Four", groupB);

    System.out.println("\nHere is output from list():");
    groupA.list();
    groupB.list();
    System.out.println();

    System.out.println("Suspending Group A");
    Thread tga[] = new Thread[groupA.activeCount()];
    groupA.enumerate(tga); // get threads in group
    for(int i = 0; i < tga.length; i++) {
      ((NewThread)tga[i]).mysuspend(); // suspend each thread
    }

    try {
      Thread.sleep(4000); 
    } catch (InterruptedException e) {
      System.out.println("Main thread interrupted.");
    }

    System.out.println("Resuming Group A");
    for(int i = 0; i < tga.length; i++) {
      ((NewThread)tga[i]).myresume(); // resume threads in group
    }

    // wait for threads to finish
    try {
      System.out.println("Waiting for threads to finish.");
      ob1.join();
      ob2.join();
      ob3.join();
      ob4.join();
    } catch (Exception e) {
      System.out.println("Exception in Main thread");
    }

    System.out.println("Main thread exiting.");
  }
}

listing 17
// Demonstrate Package
class PkgTest {
  public static void main(String args[]) {
    Package pkgs[];

    pkgs = Package.getPackages();

    for(int i=0; i < pkgs.length; i++)
      System.out.println(
             pkgs[i].getName() + " " +
             pkgs[i].getImplementationTitle() + " " +
             pkgs[i].getImplementationVendor() + " " +
             pkgs[i].getImplementationVersion()
      );

  }
}


 
/**************** 
 * Chapter  15  *
 ****************/

listing 1
// Demonstrate ArrayList.
import java.util.*;

class ArrayListDemo {
  public static void main(String args[]) {
    // create an array list
    ArrayList al = new ArrayList();
    
    System.out.println("Initial size of al: " +
                       al.size());

    // add elements to the array list
    al.add("C");
    al.add("A");
    al.add("E");
    al.add("B");
    al.add("D");
    al.add("F");
    al.add(1, "A2");

    System.out.println("Size of al after additions: " +
                       al.size());

    // display the array list
    System.out.println("Contents of al: " + al);

    // Remove elements from the array list
    al.remove("F");
    al.remove(2);

    System.out.println("Size of al after deletions: " +
                       al.size());
    System.out.println("Contents of al: " + al);
  }
}

listing 2
// Convert an ArrayList into an array.
import java.util.*;

class ArrayListToArray {
  public static void main(String args[]) {
    // Create an array list
    ArrayList al = new ArrayList();
    
    // Add elements to the array list
    al.add(new Integer(1));
    al.add(new Integer(2));
    al.add(new Integer(3));
    al.add(new Integer(4));

    System.out.println("Contents of al: " + al);
	
    // get array
    Object ia[] = al.toArray();
    int sum = 0;

    // sum the array
    for(int i=0; i<ia.length; i++)
      sum += ((Integer) ia[i]).intValue();

    System.out.println("Sum is: " + sum);
  }
}

listing 3
// Demonstrate LinkedList.
import java.util.*;

class LinkedListDemo {
  public static void main(String args[]) {
    // create a linked list
    LinkedList ll = new LinkedList();
    
    // add elements to the linked list
    ll.add("F");
    ll.add("B");
    ll.add("D");
    ll.add("E");
    ll.add("C");
    ll.addLast("Z");
    ll.addFirst("A");

    ll.add(1, "A2");

    System.out.println("Original contents of ll: " + ll);

    // remove elements from the linked list
    ll.remove("F");
    ll.remove(2);

    System.out.println("Contents of ll after deletion: "
                       + ll);

    // remove first and last elements
    ll.removeFirst();
    ll.removeLast();

    System.out.println("ll after deleting first and last: "
                       + ll);

    // get and set a value
    Object val = ll.get(2);
    ll.set(2, (String) val + " Changed");

    System.out.println("ll after change: " + ll);
  }
}

listing 4
// Demonstrate HashSet.
import java.util.*;

class HashSetDemo {
  public static void main(String args[]) {
    // create a hash set
    HashSet hs = new HashSet();
    
    // add elements to the hash set
    hs.add("B");
    hs.add("A");
    hs.add("D");
    hs.add("E");
    hs.add("C");
    hs.add("F");

    System.out.println(hs);
  }
}

listing 5
// Demonstrate TreeSet.
import java.util.*;

class TreeSetDemo {
  public static void main(String args[]) {
    // Create a tree set
    TreeSet ts = new TreeSet();
    
    // Add elements to the tree set
    ts.add("C");
    ts.add("A");
    ts.add("B");
    ts.add("E");
    ts.add("F");
    ts.add("D");

    System.out.println(ts);
  }
}

listing 6
// Demonstrate iterators.
import java.util.*;

class IteratorDemo {
  public static void main(String args[]) {
    // create an array list
    ArrayList al = new ArrayList();
    
    // add elements to the array list
    al.add("C");
    al.add("A");
    al.add("E");
    al.add("B");
    al.add("D");
    al.add("F");

    // use iterator to display contents of al
    System.out.print("Original contents of al: ");
    Iterator itr = al.iterator();
    while(itr.hasNext()) {
      Object element = itr.next();
      System.out.print(element + " ");
    }
    System.out.println();

    // modify objects being iterated
    ListIterator litr = al.listIterator(); 
    while(litr.hasNext()) {
      Object element = litr.next();
      litr.set(element + "+");
    }

    System.out.print("Modified contents of al: ");
    itr = al.iterator(); 
    while(itr.hasNext()) {
      Object element = itr.next();
      System.out.print(element + " ");
    }
    System.out.println();

    // now, display the list backwards
    System.out.print("Modified list backwards: ");
    while(litr.hasPrevious()) {
      Object element = litr.previous();
      System.out.print(element + " ");
    }
    System.out.println();
  }
}

listing 7
// A simple mailing list example.
import java.util.*;

class Address {
  private String name;
  private String street;
  private String city;
  private String state;
  private String code;

  Address(String n, String s, String c, 
          String st, String cd) {
    name = n;
    street = s;
    city = c;
    state = st;
    code = cd;
  }

  public String toString() {
    return name + "\n" + street + "\n" +
           city + " " + state + " " + code;
  }
}

class MailList {
  public static void main(String args[]) {
    LinkedList ml = new LinkedList();
    
    // add elements to the linked list
    ml.add(new Address("J.W. West", "11 Oak Ave",
                       "Urbana", "IL", "61801"));
    ml.add(new Address("Ralph Baker", "1142 Maple Lane",
                       "Mahome", "IL", "61853"));
    ml.add(new Address("Tom Carlton", "867 Elm St",
                       "Champaign", "IL", "61820"));

    Iterator itr = ml.iterator();
    while(itr.hasNext()) {
      Object element = itr.next();
      System.out.println(element + "\n");
    }
    System.out.println();
  }
}

listing 8
import java.util.*;

class HashMapDemo {
  public static void main(String args[]) {

    // Create a hash map
    HashMap hm = new HashMap();
    
    // Put elements to the map
    hm.put("John Doe", new Double(3434.34));
    hm.put("Tom Smith", new Double(123.22));
    hm.put("Jane Baker", new Double(1378.00));
    hm.put("Tod Hall", new Double(99.22));
    hm.put("Ralph Smith", new Double(-19.08));

    // Get a set of the entries
    Set set = hm.entrySet();

    // Get an iterator
    Iterator i = set.iterator();

    // Display elements
    while(i.hasNext()) {
      Map.Entry me = (Map.Entry)i.next();
      System.out.print(me.getKey() + ": ");
      System.out.println(me.getValue());
    }
    System.out.println();

    // Deposit 1000 into John Doe's account
    double balance =  ((Double)hm.get("John Doe")).doubleValue();
    hm.put("John Doe", new Double(balance + 1000));
    System.out.println("John Doe's new balance: " +
      hm.get("John Doe"));
  }
}

listing 9
import java.util.*;

class TreeMapDemo {
  public static void main(String args[]) {

    // Create a tree map
    TreeMap tm = new TreeMap();
    
    // Put elements to the map
    tm.put("John Doe", new Double(3434.34));
    tm.put("Tom Smith", new Double(123.22));
    tm.put("Jane Baker", new Double(1378.00));
    tm.put("Tod Hall", new Double(99.22));
    tm.put("Ralph Smith", new Double(-19.08));

    // Get a set of the entries
    Set set = tm.entrySet();

    // Get an iterator
    Iterator i = set.iterator();

    // Display elements
    while(i.hasNext()) {
      Map.Entry me = (Map.Entry)i.next();
      System.out.print(me.getKey() + ": ");
      System.out.println(me.getValue());
    }
    System.out.println();

    // Deposit 1000 into John Doe's account
    double balance =  ((Double)tm.get("John Doe")).doubleValue();
    tm.put("John Doe", new Double(balance + 1000));
    System.out.println("John Doe's new balance: " +
      tm.get("John Doe"));
  }
}

listing 10
// Use a custom comparator.
import java.util.*;

// A reverse comparator for strings.
class MyComp implements Comparator {
  public int compare(Object a, Object b) {
    String aStr, bStr;

    aStr = (String) a;
    bStr = (String) b;

    // reverse the comparison
    return bStr.compareTo(aStr);
  }

  // no need to override equals
}

class CompDemo {
  public static void main(String args[]) {
    // Create a tree set
    TreeSet ts = new TreeSet(new MyComp());
    
    // Add elements to the tree set
    ts.add("C");
    ts.add("A");
    ts.add("B");
    ts.add("E");
    ts.add("F");
    ts.add("D");

    // Get an iterator
    Iterator i = ts.iterator();

    // Display elements
    while(i.hasNext()) {
      Object element = i.next();
      System.out.print(element + " ");
    }
    System.out.println();
  }
}

listing 11
// Use a comparator to sort accounts by last name.
import java.util.*;

// Compare last whole words in two strings.
class TComp implements Comparator {
  public int compare(Object a, Object b) {
    int i, j, k;
    String aStr, bStr;

    aStr = (String) a;
    bStr = (String) b;

    // find index of beginning of last name
    i = aStr.lastIndexOf(' ');
    j = bStr.lastIndexOf(' ');

    k = aStr.substring(i).compareTo(bStr.substring(j));
    if(k==0) // last names match, check entire name
      return aStr.compareTo(bStr);
    else
      return k;
  }

  // no need to override equals
}

class TreeMapDemo2 {
  public static void main(String args[]) {
    // Create a tree map
    TreeMap tm = new TreeMap(new TComp());
    
    // Put elements to the map
    tm.put("John Doe", new Double(3434.34));
    tm.put("Tom Smith", new Double(123.22));
    tm.put("Jane Baker", new Double(1378.00));
    tm.put("Tod Hall", new Double(99.22));
    tm.put("Ralph Smith", new Double(-19.08));

    // Get a set of the entries
    Set set = tm.entrySet();

    // Get an iterator
    Iterator itr = set.iterator();

    // Display elements
    while(itr.hasNext()) {
      Map.Entry me = (Map.Entry)itr.next();
      System.out.print(me.getKey() + ": ");
      System.out.println(me.getValue());
    }
    System.out.println();

    // Deposit 1000 into John Doe's account
    double balance =  ((Double)tm.get("John Doe")).doubleValue();
    tm.put("John Doe", new Double(balance + 1000));
    System.out.println("John Doe's new balance: " +
      tm.get("John Doe"));
  }
}

listing 12
// Demonstrate various algorithms.
import java.util.*;

class AlgorithmsDemo {
  public static void main(String args[]) {

    // Create and initialize linked list
    LinkedList ll = new LinkedList();
    ll.add(new Integer(-8));
    ll.add(new Integer(20));
    ll.add(new Integer(-20));
    ll.add(new Integer(8));
    
    // Create a reverse order comparator
    Comparator r = Collections.reverseOrder();

    // Sort list by using the comparator
    Collections.sort(ll, r);

    // Get iterator
    Iterator li = ll.iterator();

    System.out.print("List sorted in reverse: ");    
    while(li.hasNext())
      System.out.print(li.next() + " ");
    System.out.println();

    Collections.shuffle(ll);

    // display randomized list
    li = ll.iterator();
    System.out.print("List shuffled: ");    
    while(li.hasNext())
      System.out.print(li.next() + " ");
    System.out.println();

    System.out.println("Minimum: " + Collections.min(ll));    
    System.out.println("Maximum: " + Collections.max(ll));        
  }
}

listing 13
// Demonstrate Arrays
import java.util.*;

class ArraysDemo {
  public static void main(String args[]) {

    // allocate and initialize array
    int array[] = new int[10];
    for(int i = 0; i < 10; i++)
      array[i] = -3 * i;

    // display, sort, display
    System.out.print("Original contents: ");
    display(array);
    Arrays.sort(array);
    System.out.print("Sorted: ");
    display(array);

    // fill and display
    Arrays.fill(array, 2, 6, -1);
    System.out.print("After fill(): ");
    display(array);

    // sort and display
    Arrays.sort(array);
    System.out.print("After sorting again: ");
    display(array);

    // binary search for -9
    System.out.print("The value -9 is at location ");
    int index = 
      Arrays.binarySearch(array, -9);
    System.out.println(index);
  }

  static void display(int array[]) {
    for(int i = 0; i < array.length; i++)
      System.out.print(array[i] + " ");
    System.out.println("");
  }
}

listing 14
// Demonstrate various Vector operations.
import java.util.*;

class VectorDemo {
  public static void main(String args[]) {

    // initial size is 3, increment is 2
    Vector v = new Vector(3, 2);

    System.out.println("Initial size: " + v.size());
    System.out.println("Initial capacity: " +
                       v.capacity());

    v.addElement(new Integer(1));
    v.addElement(new Integer(2));
    v.addElement(new Integer(3));
    v.addElement(new Integer(4));

    System.out.println("Capacity after four additions: " +
                       v.capacity());
    v.addElement(new Double(5.45));
    System.out.println("Current capacity: " +
                       v.capacity());
    v.addElement(new Double(6.08));
    v.addElement(new Integer(7));

    System.out.println("Current capacity: " +
                       v.capacity());
    v.addElement(new Float(9.4));
    v.addElement(new Integer(10));

    System.out.println("Current capacity: " +
                       v.capacity());
    v.addElement(new Integer(11));
    v.addElement(new Integer(12));


    System.out.println("First element: " +
                       (Integer)v.firstElement());
    System.out.println("Last element: " +
                       (Integer)v.lastElement());

    if(v.contains(new Integer(3)))
      System.out.println("Vector contains 3.");

    // enumerate the elements in the vector.
    Enumeration vEnum = v.elements();

    System.out.println("\nElements in vector:");
    while(vEnum.hasMoreElements())
      System.out.print(vEnum.nextElement() + " ");
    System.out.println();
  }
}

listing 15
// Demonstrate the Stack class.
import java.util.*;
 
class StackDemo {
  static void showpush(Stack st, int a) {
    st.push(new Integer(a));
    System.out.println("push(" + a + ")");
    System.out.println("stack: " + st);
  }

  static void showpop(Stack st) {
    System.out.print("pop -> ");
    Integer a = (Integer) st.pop();
    System.out.println(a);
    System.out.println("stack: " + st);
  }

  public static void main(String args[]) {
    Stack st = new Stack();

    System.out.println("stack: " + st);
    showpush(st, 42);
    showpush(st, 66);
    showpush(st, 99);
    showpop(st);
    showpop(st);
    showpop(st);
    try {
      showpop(st);
    } catch (EmptyStackException e) {
      System.out.println("empty stack");
    }
  }
}

listing 16
// Demonstrate a Hashtable
import java.util.*;
 
class HTDemo {
  public static void main(String args[]) {
    Hashtable balance = new Hashtable();
    Enumeration names;
    String str;
    double bal;

    balance.put("John Doe", new Double(3434.34));
    balance.put("Tom Smith", new Double(123.22));
    balance.put("Jane Baker", new Double(1378.00));
    balance.put("Tod Hall", new Double(99.22));
    balance.put("Ralph Smith", new Double(-19.08));

    // Show all balances in hashtable
    names = balance.keys();
    while(names.hasMoreElements()) {
      str = (String) names.nextElement();
      System.out.println(str + ": " +
                         balance.get(str));
    }

    System.out.println();

    // Deposit 1,000 into John Doe's account
    bal = ((Double)balance.get("John Doe")).doubleValue();
    balance.put("John Doe", new Double(bal+1000));
    System.out.println("John Doe's new balance: " +
                       balance.get("John Doe"));
  }
}

listing 17
// Use iterators with a Hashtable.
import java.util.*;

class HTDemo2 {
  public static void main(String args[]) {
    Hashtable balance = new Hashtable();
    String str;
    double bal;

    balance.put("John Doe", new Double(3434.34));
    balance.put("Tom Smith", new Double(123.22));
    balance.put("Jane Baker", new Double(1378.00));
    balance.put("Tod Hall", new Double(99.22));
    balance.put("Ralph Smith", new Double(-19.08));

    // show all balances in hashtable
    Set set = balance.keySet(); // get set view of keys

    // get iterator
    Iterator itr = set.iterator();
    while(itr.hasNext()) {
      str = (String) itr.next();
      System.out.println(str + ": " +
                         balance.get(str));
    }

    System.out.println();

    // Deposit 1,000 into John Doe's account
    bal = ((Double)balance.get("John Doe")).doubleValue();
    balance.put("John Doe", new Double(bal+1000));
    System.out.println("John Doe's new balance: " +
                       balance.get("John Doe"));
  }
}

listing 18
// Demonstrate a Property list.
import java.util.*;
 
class PropDemo {
  public static void main(String args[]) {
    Properties capitals = new Properties();
    Set states;
    String str;

    capitals.put("Illinois", "Springfield");
    capitals.put("Missouri", "Jefferson City");
    capitals.put("Washington", "Olympia");
    capitals.put("California", "Sacramento");
    capitals.put("Indiana", "Indianapolis");

    // Show all states and capitals in hashtable.
    states = capitals.keySet(); // get set-view of keys
    Iterator itr = states.iterator();

    while(itr.hasNext()) {
      str = (String) itr.next();
      System.out.println("The capital of " +
                         str + " is " +
                         capitals.getProperty(str)
                         + ".");
    }

    System.out.println();

    // look for state not in list -- specify default
    str = capitals.getProperty("Florida", "Not Found");
    System.out.println("The capital of Florida is "
                       + str + ".");
  }
}

listing 19
// Use a default property list.
import java.util.*;
 
class PropDemoDef {
  public static void main(String args[]) {
    Properties defList = new Properties();
    defList.put("Florida", "Tallahassee");
    defList.put("Wisconsin", "Madison");

    Properties capitals = new Properties(defList);
    Set states;
    String str;

    capitals.put("Illinois", "Springfield");
    capitals.put("Missouri", "Jefferson City");
    capitals.put("Washington", "Olympia");
    capitals.put("California", "Sacramento");
    capitals.put("Indiana", "Indianapolis");

    // Show all states and capitals in hashtable.
    states = capitals.keySet(); // get set-view of keys
    Iterator itr = states.iterator();

    while(itr.hasNext()) {
      str = (String) itr.next();
      System.out.println("The capital of " +
                         str + " is " +
                         capitals.getProperty(str)
                         + ".");
    }

    System.out.println();

    // Florida will now be found in the default list.
    str = capitals.getProperty("Florida");
    System.out.println("The capital of Florida is "
                       + str + ".");
  }
}

listing 20
/* A simple telephone number database that uses
   a property list. */
import java.io.*;
import java.util.*;

class Phonebook {
  public static void main(String args[]) 
    throws IOException
  {
    Properties ht = new Properties();
    BufferedReader br =
      new BufferedReader(new InputStreamReader(System.in));
    String name, number;
    FileInputStream fin = null;
    boolean changed = false;

    // Try to open phonebook.dat file.
    try {
      fin = new FileInputStream("phonebook.dat");
    } catch(FileNotFoundException e) {
      // ignore missing file
    }

    /* If phonebook file already exists, 
       load existing telephone numbers. */
    try {
      if(fin != null) {
        ht.load(fin);
        fin.close();
      }
    } catch(IOException e) {
      System.out.println("Error reading file.");
    }

    // Let user enter new names and numbers.
    do {
      System.out.println("Enter new name" + 
                         " ('quit' to stop): ");
      name = br.readLine();
      if(name.equals("quit")) continue;

      System.out.println("Enter number: ");
      number = br.readLine();

      ht.put(name, number);
      changed = true;
    } while(!name.equals("quit"));

    // If phone book data has changed, save it.
    if(changed) {
      FileOutputStream fout = new FileOutputStream("phonebook.dat");

      ht.store(fout, "Telephone Book");    
      fout.close();
    }

    // Look up numbers given a name.
    do {
      System.out.println("Enter name to find" +
                         " ('quit' to quit): ");
      name = br.readLine();
      if(name.equals("quit")) continue;

      number = (String) ht.get(name);
      System.out.println(number);
    } while(!name.equals("quit"));
  }
}


 
/**************** 
 * Chapter  16  *
 ****************/

listing 1
// Demonstrate StringTokenizer.
import java.util.StringTokenizer;

class STDemo {
  static String in = "title=Java: The Complete Reference;" +
    "author=Schildt;" +
    "publisher=Osborne/McGraw-Hill;" +
    "copyright=2002";

  public static void main(String args[]) {
    StringTokenizer st = new StringTokenizer(in, "=;");

    while(st.hasMoreTokens()) {
      String key = st.nextToken();
      String val = st.nextToken();
      System.out.println(key + "\t" + val);
    }
  }
}

listing 2
// BitSet Demonstration.
import java.util.BitSet;

class BitSetDemo {
  public static void main(String args[]) {
    BitSet bits1 = new BitSet(16);
    BitSet bits2 = new BitSet(16);

    // set some bits
    for(int i=0; i<16; i++) {
      if((i%2) == 0) bits1.set(i);
      if((i%5) != 0) bits2.set(i);
    }

    System.out.println("Initial pattern in bits1: ");
    System.out.println(bits1);
    System.out.println("\nInitial pattern in bits2: ");
    System.out.println(bits2);

    // AND bits
    bits2.and(bits1);
    System.out.println("\nbits2 AND bits1: ");
    System.out.println(bits2);

    // OR bits
    bits2.or(bits1);
    System.out.println("\nbits2 OR bits1: ");
    System.out.println(bits2);

    // XOR bits
    bits2.xor(bits1);
    System.out.println("\nbits2 XOR bits1: ");
    System.out.println(bits2);
  }
}

listing 3
// Show date and time using only Date methods.
import java.util.Date;

class DateDemo {
  public static void main(String args[]) {
    // Instantiate a Date object
    Date date = new Date();
    
    // display time and date using toString()
    System.out.println(date);

    // Display number of milliseconds since midnight, January 1, 1970 GMT
    long msec = date.getTime();
    System.out.println("Milliseconds since Jan. 1, 1970 GMT = " + msec);
  }
}

listing 4
// Demonstrate Calendar
import java.util.Calendar;

class CalendarDemo {
  public static void main(String args[]) {
    String months[] = {
             "Jan", "Feb", "Mar", "Apr", 
             "May", "Jun", "Jul", "Aug",
             "Sep", "Oct", "Nov", "Dec"};

    // Create a calendar initialized with the
    // current date and time in the default
    // locale and timezone.
    Calendar calendar = Calendar.getInstance();

    // Display current time and date information.
    System.out.print("Date: ");
    System.out.print(months[calendar.get(Calendar.MONTH)]);
    System.out.print(" " + calendar.get(Calendar.DATE) + " ");
    System.out.println(calendar.get(Calendar.YEAR));

    System.out.print("Time: ");
    System.out.print(calendar.get(Calendar.HOUR) + ":");
    System.out.print(calendar.get(Calendar.MINUTE) + ":");
    System.out.println(calendar.get(Calendar.SECOND));

    // Set the time and date information and display it.
    calendar.set(Calendar.HOUR, 10);
    calendar.set(Calendar.MINUTE, 29);
    calendar.set(Calendar.SECOND, 22);

    System.out.print("Updated time: ");
    System.out.print(calendar.get(Calendar.HOUR) + ":");
    System.out.print(calendar.get(Calendar.MINUTE) + ":");
    System.out.println(calendar.get(Calendar.SECOND));
  }
}

listing 5
// Demonstrate GregorianCalendar
import java.util.*;

class GregorianCalendarDemo {
  public static void main(String args[]) {
    String months[] = {
             "Jan", "Feb", "Mar", "Apr", 
             "May", "Jun", "Jul", "Aug",
             "Sep", "Oct", "Nov", "Dec"};
    int year;

    // Create a Gregorian calendar initialized 
    // with the current date and time in the
    // default locale and timezone.
    GregorianCalendar gcalendar = new GregorianCalendar();

    // Display current time and date information.
    System.out.print("Date: ");
    System.out.print(months[gcalendar.get(Calendar.MONTH)]);
    System.out.print(" " + gcalendar.get(Calendar.DATE) + " ");
    System.out.println(year = gcalendar.get(Calendar.YEAR));

    System.out.print("Time: ");
    System.out.print(gcalendar.get(Calendar.HOUR) + ":");
    System.out.print(gcalendar.get(Calendar.MINUTE) + ":");
    System.out.println(gcalendar.get(Calendar.SECOND));

    // Test if the current year is a leap year
    if(gcalendar.isLeapYear(year)) {
      System.out.println("The current year is a leap year");
    }
    else {
      System.out.println("The current year is not a leap year");
    }
  }
}

listing 6
// Demonstrate random Gaussian values.
import java.util.Random;

class RandDemo {
  public static void main(String args[]) {
    Random r = new Random();
    double val;
    double sum = 0;
    int bell[] = new int[10];

    for(int i=0; i<100; i++) {
      val = r.nextGaussian();
      sum += val;
      double t = -2;
      for(int x=0; x<10; x++, t += 0.5)
        if(val < t) {
          bell[x]++;
          break;
        }
    }
    System.out.println("Average of values: " +
                        (sum/100));

    // display bell curve, sideways
    for(int i=0; i<10; i++) {
      for(int x=bell[i]; x>0; x--)
        System.out.print("*");
      System.out.println();
    }
  }
}

listing 7
/* Demonstrate the Observable class and the
   Observer interface.
*/

import java.util.*;

// This is the observing class.
class Watcher implements Observer {
  public void update(Observable obj, Object arg) {
    System.out.println("update() called, count is " +
                       ((Integer)arg).intValue());
  }
}

// This is the class being observed.
class BeingWatched extends Observable {
  void counter(int period) {
    for( ; period >=0; period--) {
      setChanged();
      notifyObservers(new Integer(period));
      try {
        Thread.sleep(100);
      } catch(InterruptedException e) {
        System.out.println("Sleep interrupted");
      }
    }
  }

}

class ObserverDemo {
  public static void main(String args[]) {
    BeingWatched observed = new BeingWatched();
    Watcher observing = new Watcher();

    /* Add the observing to the list of observers for
       observed object.  */
    observed.addObserver(observing);

    observed.counter(10);
  }
}

listing 8
/* An object may be observed by two or more
   observers.
*/

import java.util.*;

// This is the first observing class.
class Watcher1 implements Observer {
  public void update(Observable obj, Object arg) {
    System.out.println("update() called, count is " +
                       ((Integer)arg).intValue());
  }
}

// This is the second observing class.
class Watcher2 implements Observer {
  public void update(Observable obj, Object arg) {
    // Ring bell when done
    if(((Integer)arg).intValue() == 0)
      System.out.println("Done" + '\7');
  }
}

// This is the class being observed.
class BeingWatched extends Observable {
  void counter(int period) {
    for( ; period >=0; period--) {
      setChanged();
      notifyObservers(new Integer(period));
      try {
        Thread.sleep(100);
      } catch(InterruptedException e) {
        System.out.println("Sleep interrupted");
      }
    }
  }
}

class TwoObservers {
  public static void main(String args[]) {
    BeingWatched observed = new BeingWatched();
    Watcher1 observing1 = new Watcher1();
    Watcher2 observing2 = new Watcher2();

    // add both observers
    observed.addObserver(observing1);
    observed.addObserver(observing2);

    observed.counter(10);
  }
}

listing 9
// Demonstrate Timer and TimerTask.

import java.util.*;

class MyTimerTask extends TimerTask {
  public void run() {
    System.out.println("Timer task executed.");
  }
}

class TTest {
  public static void main(String args[]) {
    MyTimerTask myTask = new MyTimerTask();
    Timer myTimer = new Timer();

    /* Set an initial delay of 1 second,
       then repeat every half second.
    */
    myTimer.schedule(myTask, 1000, 500);
    
    try {
      Thread.sleep(5000);
    } catch (InterruptedException exc) {}

    myTimer.cancel();
  }
}

listing 10
// Demonstrate Currency.
import java.util.*;

class CurDemo {
  public static void main(String args[]) {
    Currency c;

    c = Currency.getInstance(Locale.US);

    System.out.println("Symbol: " + c.getSymbol());
    System.out.println("Default fractional digits: " +
                       c.getDefaultFractionDigits());
  }
}
 
 
/**************** 
 * Chapter  17  *
 ****************/

listing 1
// Demonstrate File.
import java.io.File;

class FileDemo {
  static void p(String s) {
    System.out.println(s);
  }

  public static void main(String args[]) {
    File f1 = new File("/java/COPYRIGHT");
    p("File Name: " + f1.getName());
    p("Path: " + f1.getPath());
    p("Abs Path: " + f1.getAbsolutePath());
    p("Parent: " + f1.getParent());
    p(f1.exists() ? "exists" : "does not exist");
    p(f1.canWrite() ? "is writeable" : "is not writeable");
    p(f1.canRead() ? "is readable" : "is not readable");
    p("is " + (f1.isDirectory() ? "" : "not" + " a directory"));
    p(f1.isFile() ? "is normal file" : "might be a named pipe");
    p(f1.isAbsolute() ? "is absolute" : "is not absolute");
    p("File last modified: " + f1.lastModified());
    p("File size: " + f1.length() + " Bytes");
  }
}

listing 2
// Using directories.
import java.io.File;

class DirList {
  public static void main(String args[]) {
    String dirname = "/java";
    File f1 = new File(dirname);

    if (f1.isDirectory()) {
      System.out.println("Directory of " + dirname);
      String s[] = f1.list();

      for (int i=0; i < s.length; i++) {
        File f = new File(dirname + "/" + s[i]);
        if (f.isDirectory()) {
          System.out.println(s[i] + " is a directory");
        } else {
          System.out.println(s[i] + " is a file");
        }
      }
    } else {
      System.out.println(dirname + " is not a directory");
    }
  }
}

listing 3
import java.io.*;

public class OnlyExt implements FilenameFilter {
  String ext;

  public OnlyExt(String ext) {
    this.ext = "." + ext;
  }

  public boolean accept(File dir, String name) {
    return name.endsWith(ext);
  }
}

listing 4
// Directory of .HTML files.
import java.io.*;

class DirListOnly {
  public static void main(String args[]) {
    String dirname = "/java";
    File f1 = new File(dirname);
    FilenameFilter only = new OnlyExt("html");
    String s[] = f1.list(only);

    for (int i=0; i < s.length; i++) {
      System.out.println(s[i]);
    }
  }
}

listing 5
// Demonstrate FileInputStream.
import java.io.*;

class FileInputStreamDemo {
  public static void main(String args[]) throws Exception {
    int size;
    InputStream f =
      new FileInputStream("FileInputStreamDemo.java");

    System.out.println("Total Available Bytes: " +
                       (size = f.available()));
    int n = size/40;
    System.out.println("First " + n +
                       " bytes of the file one read() at a time");
    for (int i=0; i < n; i++) {
      System.out.print((char) f.read());
    }
    System.out.println("\nStill Available: " + f.available());
    System.out.println("Reading the next " + n +
                       " with one read(b[])");
    byte b[] = new byte[n];
    if (f.read(b) != n) {
      System.err.println("couldn't read " + n + " bytes.");
    }
    System.out.println(new String(b, 0, n));
    System.out.println("\nStill Available: " + (size = f.available()));
    System.out.println("Skipping half of remaining bytes with skip()");
    f.skip(size/2);
    System.out.println("Still Available: " + f.available());
    System.out.println("Reading " + n/2 + " into the end of array");
    if (f.read(b, n/2, n/2) != n/2) {
      System.err.println("couldn't read " + n/2 + " bytes.");
    }
    System.out.println(new String(b, 0, b.length));
    System.out.println("\nStill Available: " + f.available());
    f.close();
  }
}

listing 6
// Demonstrate FileOutputStream.
import java.io.*;

class FileOutputStreamDemo {
  public static void main(String args[]) throws Exception {
    String source = "Now is the time for all good men\n"
      + " to come to the aid of their country\n"
      + " and pay their due taxes.";
    byte buf[] = source.getBytes();
    OutputStream f0 = new FileOutputStream("file1.txt");
    for (int i=0; i < buf.length; i += 2) {
      f0.write(buf[i]);
    }
    f0.close();

    OutputStream f1 = new FileOutputStream("file2.txt");
    f1.write(buf);
    f1.close();

    OutputStream f2 = new FileOutputStream("file3.txt");
    f2.write(buf,buf.length-buf.length/4,buf.length/4);
    f2.close();
  }
}

listing 7
// Demonstrate ByteArrayInputStream.
import java.io.*;

class ByteArrayInputStreamDemo {
  public static void main(String args[]) throws IOException {
    String tmp = "abcdefghijklmnopqrstuvwxyz";
    byte b[] = tmp.getBytes();
    ByteArrayInputStream input1 = new ByteArrayInputStream(b);
    ByteArrayInputStream input2 = new ByteArrayInputStream(b, 0, 3);
  }
}

listing 8
import java.io.*;

class ByteArrayInputStreamReset {
  public static void main(String args[]) throws IOException {
    String tmp = "abc";
    byte b[] = tmp.getBytes();
    ByteArrayInputStream in = new ByteArrayInputStream(b);

    for (int i=0; i<2; i++) {
      int c;
      while ((c = in.read()) != -1) {
        if (i == 0) {
          System.out.print((char) c);
        } else {
          System.out.print(Character.toUpperCase((char) c));
        }
      }
      System.out.println();
      in.reset();
    }
  }
}

listing 9
// Demonstrate ByteArrayOutputStream.
import java.io.*;

class ByteArrayOutputStreamDemo {
  public static void main(String args[]) throws IOException {
    ByteArrayOutputStream f = new ByteArrayOutputStream();
    String s = "This should end up in the array";
    byte buf[] = s.getBytes();

    f.write(buf);
    System.out.println("Buffer as a string");
    System.out.println(f.toString());
    System.out.println("Into array");
    byte b[] = f.toByteArray();
    for (int i=0; i<b.length; i++) {
      System.out.print((char) b[i]);
    }
    System.out.println("\nTo an OutputStream()");
    OutputStream f2 = new FileOutputStream("test.txt");

    f.writeTo(f2);
    f2.close();
    System.out.println("Doing a reset");
    f.reset();
    for (int i=0; i<3; i++)
      f.write('X');
    System.out.println(f.toString());
  }
}

listing 10
// Use buffered input.
import java.io.*;

class BufferedInputStreamDemo {
  public static void main(String args[]) throws IOException {
    String s = "This is a &copy; copyright symbol " +
      "but this is &copy not.\n";
    byte buf[] = s.getBytes(); 
    ByteArrayInputStream in = new ByteArrayInputStream(buf);
    BufferedInputStream f = new BufferedInputStream(in);
    int c;
    boolean marked = false;

    while ((c = f.read()) != -1) {
      switch(c) {
      case '&':
        if (!marked) {
          f.mark(32);
          marked = true;
        } else {
          marked = false;
        }
        break;
      case ';':
        if (marked) {
          marked = false;
          System.out.print("(c)");
        } else
          System.out.print((char) c);
        break;
      case ' ':
        if (marked) {
          marked = false;
          f.reset();
          System.out.print("&");
        } else
          System.out.print((char) c);
        break;
     default:
       if (!marked)
           System.out.print((char) c);
       break;
      }
    }
  }
}

listing 11
// Demonstrate unread().
import java.io.*;

class PushbackInputStreamDemo {
  public static void main(String args[]) throws IOException {
    String s = "if (a == 4) a = 0;\n";
    byte buf[] = s.getBytes(); 
    ByteArrayInputStream in = new ByteArrayInputStream(buf);
    PushbackInputStream f = new PushbackInputStream(in);
    int c;

    while ((c = f.read()) != -1) {
      switch(c) {
      case '=':
        if ((c = f.read()) == '=')
          System.out.print(".eq.");
        else {
          System.out.print("<-");
          f.unread(c);
        }
        break;
     default:
       System.out.print((char) c);
       break;
      }
    }
  }
}

listing 12
// Demonstrate sequenced input.
import java.io.*;
import java.util.*;

class InputStreamEnumerator implements Enumeration {
  private Enumeration files;
  public InputStreamEnumerator(Vector files) {
    this.files = files.elements();
  }

  public boolean hasMoreElements() {
    return files.hasMoreElements();
  }

  public Object nextElement() {
    try {
      return new FileInputStream(files.nextElement().toString());
    } catch (Exception e) {
      return null;
    }
  }
}

class SequenceInputStreamDemo {
  public static void main(String args[]) throws Exception {
    int c;
    Vector files = new Vector();

    files.addElement("/autoexec.bat");
    files.addElement("/config.sys");
    InputStreamEnumerator e = new InputStreamEnumerator(files);
    InputStream input = new SequenceInputStream(e);

    while ((c = input.read()) != -1) {
      System.out.print((char) c);
    }
    input.close();
  }
}

listing 13
// Demonstrate FileReader.
import java.io.*;

class FileReaderDemo {
  public static void main(String args[]) throws Exception {
    FileReader fr = new FileReader("FileReaderDemo.java");
    BufferedReader br = new BufferedReader(fr);
    String s;

    while((s = br.readLine()) != null) {
      System.out.println(s);
    }

    fr.close();
  }
}

listing 14
// Demonstrate FileWriter.
import java.io.*;

class FileWriterDemo {
  public static void main(String args[]) throws Exception {
    String source = "Now is the time for all good men\n"
      + " to come to the aid of their country\n"
      + " and pay their due taxes.";
    char buffer[] = new char[source.length()];
    source.getChars(0, source.length(), buffer, 0);

    FileWriter f0 = new FileWriter("file1.txt");
    for (int i=0; i < buffer.length; i += 2) {
      f0.write(buffer[i]);
    }
    f0.close();

    FileWriter f1 = new FileWriter("file2.txt");
    f1.write(buffer);
    f1.close();

    FileWriter f2 = new FileWriter("file3.txt");

    f2.write(buffer,buffer.length-buffer.length/4,buffer.length/4);
    f2.close();
  }
}

listing 15
// Demonstrate CharArrayReader.
import java.io.*;

public class CharArrayReaderDemo {
  public static void main(String args[]) throws IOException {
    String tmp = "abcdefghijklmnopqrstuvwxyz";
    int length = tmp.length();
    char c[] = new char[length];

    tmp.getChars(0, length, c, 0);
    CharArrayReader input1 = new CharArrayReader(c);
    CharArrayReader input2 = new CharArrayReader(c, 0, 5);

    int i;
    System.out.println("input1 is:");
    while((i = input1.read()) != -1) {
      System.out.print((char)i);
    }
    System.out.println();

    System.out.println("input2 is:");
    while((i = input2.read()) != -1) {
      System.out.print((char)i);
    }
    System.out.println();
  }
}

listing 16
// Demonstrate CharArrayWriter.
import java.io.*;

class CharArrayWriterDemo {
  public static void main(String args[]) throws IOException {
    CharArrayWriter f = new CharArrayWriter();
    String s = "This should end up in the array";
    char buf[] = new char[s.length()];

    s.getChars(0, s.length(), buf, 0);
    f.write(buf);
    System.out.println("Buffer as a string");
    System.out.println(f.toString());
    System.out.println("Into array");

    char c[] = f.toCharArray();
    for (int i=0; i<c.length; i++) {
      System.out.print(c[i]);
    }

    System.out.println("\nTo a FileWriter()");
    FileWriter f2 = new FileWriter("test.txt");
    f.writeTo(f2);
    f2.close();
    System.out.println("Doing a reset");
    f.reset();
    for (int i=0; i<3; i++)
      f.write('X');
    System.out.println(f.toString());
  }
}

listing 17
// Use buffered input.
import java.io.*;

class BufferedReaderDemo {
  public static void main(String args[]) throws IOException {
    String s = "This is a &copy; copyright symbol " +
      "but this is &copy not.\n";
    char buf[] = new char[s.length()];
    s.getChars(0, s.length(), buf, 0); 
    CharArrayReader in = new CharArrayReader(buf);
    BufferedReader f = new BufferedReader(in);
    int c;
    boolean marked = false;

    while ((c = f.read()) != -1) {
      switch(c) {
      case '&':
        if (!marked) {
          f.mark(32);
          marked = true;
        } else {
          marked = false;
        }
        break;
      case ';':
        if (marked) {
          marked = false;
          System.out.print("(c)");
        } else
          System.out.print((char) c);
        break;
      case ' ':
        if (marked) {
          marked = false;
          f.reset();
          System.out.print("&");
        } else
          System.out.print((char) c);
        break;
     default:
       if (!marked)
           System.out.print((char) c);
       break;
      }
    }
  }
}

listing 18
// Demonstrate unread().
import java.io.*;

class PushbackReaderDemo {
  public static void main(String args[]) throws IOException {
    String s = "if (a == 4) a = 0;\n";
    char buf[] = new char[s.length()];
    s.getChars(0, s.length(), buf, 0); 
    CharArrayReader in = new CharArrayReader(buf);
    PushbackReader f = new PushbackReader(in);
    int c;

    while ((c = f.read()) != -1) {
      switch(c) {
      case '=':
        if ((c = f.read()) == '=')
          System.out.print(".eq.");
        else {
          System.out.print("<-");
          f.unread(c);
        }
        break;
     default:
       System.out.print((char) c);
       break;
      }
    }
  }
}

listing 19
// A word counting utility.
import java.io.*;

class WordCount {
  public static int words = 0;
  public static int lines = 0;
  public static int chars = 0;

  public static void wc(InputStreamReader isr)
    throws IOException {
    int c = 0;
    boolean lastWhite = true;
    String whiteSpace = " \t\n\r";

    while ((c = isr.read()) != -1) {
      // Count characters
      chars++;
      // Count lines
      if (c == '\n') {
        lines++;
      }
      // Count words by detecting the start of a word
      int index = whiteSpace.indexOf(c);
      if(index == -1) {
        if(lastWhite == true) {
          ++words;
        }
        lastWhite = false;
      }
      else {
        lastWhite = true;
      }
    }
    if(chars != 0) {
      ++lines;
    }
  }

  public static void main(String args[]) {
    FileReader fr;
    try {
      if (args.length == 0) { // We're working with stdin
        wc(new InputStreamReader(System.in));
      } 
      else { // We're working with a list of files
        for (int i = 0; i < args.length; i++) {
          fr = new FileReader(args[i]);
          wc(fr);
        }
      }
    } 
    catch (IOException e) {
      return;
    }
    System.out.println(lines + " " + words + " " + chars);
  }
}

listing 20
// Enhanced word count program that uses a StreamTokenizer
import java.io.*;

class WordCount {
  public static int words=0;
  public static int lines=0;
  public static int chars=0;

  public static void wc(Reader r) throws IOException {
    StreamTokenizer tok = new StreamTokenizer(r);

    tok.resetSyntax();
    tok.wordChars(33, 255);
    tok.whitespaceChars(0, ' ');
    tok.eolIsSignificant(true);

    while (tok.nextToken() != tok.TT_EOF) {
      switch (tok.ttype) {
        case StreamTokenizer.TT_EOL:
          lines++;
          chars++;
          break;
        case StreamTokenizer.TT_WORD:
          words++;
        default: // FALLSTHROUGH
          chars += tok.sval.length();
          break;
      }
    }
  }

  public static void main(String args[]) {
    if (args.length == 0) { // We're working with stdin
      try {
        wc(new InputStreamReader(System.in));
        System.out.println(lines + " " + words + " " + chars);
      } catch (IOException e) {};
    } else { // We're working with a list of files
      int twords = 0, tchars = 0, tlines = 0;
      for (int i=0; i<args.length; i++) {
        try {
          words = chars = lines = 0;
          wc(new FileReader(args[i]));
          twords += words;
          tchars += chars;
          tlines += lines;
          System.out.println(args[i] + ": " +
            lines + " " + words + " " + chars);
        } catch (IOException e) {
          System.out.println(args[i] + ": error.");
        }
      }
      System.out.println("total: " +
      tlines + " " + twords + " " + tchars);
    }
  }
}

listing 21
import java.io.*;

public class SerializationDemo {
  public static void main(String args[]) {
    
    // Object serialization
    try {
      MyClass object1 = new MyClass("Hello", -7, 2.7e10);
      System.out.println("object1: " + object1);
      FileOutputStream fos = new FileOutputStream("serial");
      ObjectOutputStream oos = new ObjectOutputStream(fos);
      oos.writeObject(object1);
      oos.flush();
      oos.close();
    }
    catch(Exception e) {
      System.out.println("Exception during serialization: " + e);
      System.exit(0);
    }

    // Object deserialization
    try {
      MyClass object2;
      FileInputStream fis = new FileInputStream("serial");
      ObjectInputStream ois = new ObjectInputStream(fis);
      object2 = (MyClass)ois.readObject();
      ois.close();
      System.out.println("object2: " + object2);
    }
    catch(Exception e) {
      System.out.println("Exception during deserialization: " + e);
      System.exit(0);
    }
  }
}

class MyClass implements Serializable {
  String s;
  int i;
  double d;
  public MyClass(String s, int i, double d) {
    this.s = s;
    this.i = i;
    this.d = d;
  }
  public String toString() {
    return "s=" + s + "; i=" + i + "; d=" + d;
  }
}


 
/***************** 
 * Chapter  18   *
 *****************/

listing 1
// Demonstrate InetAddress.
import java.net.*;

class InetAddressTest 
{
  public static void main(String args[]) throws UnknownHostException {
    InetAddress Address = InetAddress.getLocalHost();
    System.out.println(Address);
    Address = InetAddress.getByName("osborne.com");
    System.out.println(Address);
    InetAddress SW[] = InetAddress.getAllByName("www.nba.com");
    for (int i=0; i<SW.length; i++)
      System.out.println(SW[i]);
  }
}

listing 2
//Demonstrate Sockets.
import java.net.*;
import java.io.*;

class Whois {
  public static void main(String args[]) throws Exception {
    int c;
    Socket s = new Socket("internic.net", 43);
    InputStream in = s.getInputStream();
    OutputStream out = s.getOutputStream();
    String str = (args.length == 0 ? "osborne.com" : args[0]) + "\n";
    byte buf[] = str.getBytes();
    out.write(buf);
    while ((c = in.read()) != -1) {
      System.out.print((char) c);
    }
    s.close();
  }
}

listing 3
// Demonstrate URL.
import java.net.*;
class URLDemo {
  public static void main(String args[]) throws MalformedURLException {
    URL hp = new URL("http://www.osborne/downloads");

    System.out.println("Protocol: " + hp.getProtocol());
    System.out.println("Port: " + hp.getPort());
    System.out.println("Host: " + hp.getHost());
    System.out.println("File: " + hp.getFile());
    System.out.println("Ext:" + hp.toExternalForm());
  }
}

listing 4
// Demonstrate URLConnection.
import java.net.*;
import java.io.*;
import java.util.Date;

class UCDemo 
{
  public static void main(String args[]) throws Exception {
    int c;
    URL hp = new URL("http://www.internic.net");
    URLConnection hpCon = hp.openConnection();

    // get date
    long d = hpCon.getDate(); 
    if(d==0)
      System.out.println("No date information.");
    else
      System.out.println("Date: " + new Date(d));

    // get content type
    System.out.println("Content-Type: " + hpCon.getContentType());

    // get expiration date
    d = hpCon.getExpiration(); 
    if(d==0)
      System.out.println("No expiration information.");
    else
      System.out.println("Expires: " + new Date(d));

    // get last-modified date
    d = hpCon.getLastModified(); 
    if(d==0)
      System.out.println("No last-modified information.");
    else
      System.out.println("Last-Modified: " + new Date(d));

    // get content length
    int len = hpCon.getContentLength();
    if(len == -1)
      System.out.println("Content length unavailable.");
    else
      System.out.println("Content-Length: " + len);

    if(len != 0) {
      System.out.println("=== Content ===");
      InputStream input = hpCon.getInputStream();
      int i = len;
      while (((c = input.read()) != -1)) { // && (--i > 0)) {
        System.out.print((char) c);
      }
      input.close();

    } else {
      System.out.println("No content available.");
    }

  }
}

listing 5
import java.util.*;

class MimeHeader extends Hashtable {
  void parse(String data) {
    StringTokenizer st = new StringTokenizer(data, "\r\n");

    while (st.hasMoreTokens()) {
      String s = st.nextToken();
      int colon = s.indexOf(':');
      String key = s.substring(0, colon);
      String val = s.substring(colon + 2); // skip ": "
      put(key, val);
    }
  }

  MimeHeader() {}

  MimeHeader(String d) {
    parse(d);
  }

  public String toString() {
    String ret = "";
    Enumeration e = keys();

    while(e.hasMoreElements()) {
      String key = (String) e.nextElement();
      String val = (String) get(key);
      ret += key + ": " + val + "\r\n";
    }
    return ret;
  }

  // This simple function converts a mime string from
  // any variant of capitalization to a canonical form.
  // For example: CONTENT-TYPE or content-type to Content-Type,
  // or Content-length or CoNTeNT-LENgth to Content-Length.
  private String fix(String ms) {
    char chars[] = ms.toLowerCase().toCharArray();
    boolean upcaseNext = true;

    for (int i = 0; i < chars.length - 1; i++) {
      char ch = chars[i];
      if (upcaseNext && 'a' <= ch && ch <= 'z') {
        chars[i] = (char) (ch - ('a' - 'A'));
      }
      upcaseNext = ch == '-';
    }
    return new String(chars);
  }

  public String get(String key) {
    return (String) super.get(fix(key));
  }

  public void put(String key, String val) {
    super.put(fix(key), val);
  }
}

listing 6
import java.io.*;
/*
 * HttpResponse
 * Parse a return message and MIME header from a server.
 * HTTP/1.0 302 Found  =  redirection, check Location for where.
 * HTTP/1.0 200 OK = file data comes after mime header.
 */

class HttpResponse
{
  int statusCode;      // Status-Code in spec
  String reasonPhrase; // Reason-Phrase in spec
  MimeHeader mh;
  static String CRLF = "\r\n";

  void parse(String request) {
    int fsp = request.indexOf(' ');
    int nsp = request.indexOf(' ', fsp+1);
    int eol = request.indexOf('\n');
    String protocol = request.substring(0, fsp);
    statusCode = Integer.parseInt(request.substring(fsp+1, nsp));
    reasonPhrase = request.substring(nsp+1, eol);
    String raw_mime_header = request.substring(eol + 1);
    mh = new MimeHeader(raw_mime_header);
  }

  HttpResponse(String request) {
    parse(request);
  }

  HttpResponse(int code, String reason, MimeHeader m) {
    statusCode = code;
    reasonPhrase = reason;
    mh = m;
  }

  public String toString() {
    return "HTTP/1.0 " + statusCode + " " + reasonPhrase + CRLF +
      mh + CRLF;
  }
}

listing 7
class UrlCacheEntry 
{
  String url;
  MimeHeader mh;
  byte data[];
  int length = 0;

  public UrlCacheEntry(String u, MimeHeader m) {
    url = u;
    mh = m;
    String cl = mh.get("Content-Length");
    if (cl != null) {
      data = new byte[Integer.parseInt(cl)];
    }
  }

  void append(byte d[], int n) {
    if (data == null) {
      data = new byte[n];
      System.arraycopy(d, 0, data, 0, n);
      length = n;
    } else if (length + n > data.length) {
      byte old[] = data;
      data = new byte[old.length + n];
      System.arraycopy(old, 0, data, 0, old.length);
      System.arraycopy(d, 0, data, old.length, n);
    } else {
      System.arraycopy(d, 0, data, length, n);
      length += n;
    }
  }
}

listing 8
interface LogMessage {
  public void log(String msg);
}

listing 9
import java.net.*;
import java.io.*;
import java.text.*;
import java.util.*;

class httpd implements Runnable, LogMessage {
  private int port;
  private String docRoot;
  private LogMessage log;
  private Hashtable cache = new Hashtable();
  private boolean stopFlag;

  private static String version = "1.0";
  private static String mime_text_html = "text/html";
  private static String CRLF = "\r\n";
  private static String indexfile = "index.html";
  private static int buffer_size = 8192;
  static String mt[] = {  // mapping from file ext to Mime-Type
    "txt", "text/plain",
    "html", mime_text_html,
    "htm", "text/html",
    "gif", "image/gif",
    "jpg", "image/jpg",
    "jpeg", "image/jpg",
    "class", "application/octet-stream"
  };
  static String defaultExt = "txt";
  static Hashtable types = new Hashtable();
  static {
    for (int i=0; i<mt.length;i+=2)
      types.put(mt[i], mt[i+1]);
  }

  static String fnameToMimeType(String filename) {
    if (filename.endsWith("/"))      // special for index files.
      return mime_text_html;
    int dot = filename.lastIndexOf('.');
    String ext = (dot > 0) ? filename.substring(dot + 1) : defaultExt;
    String ret = (String) types.get(ext);
    return ret != null ? ret : (String)types.get(defaultExt);
  }

  int hits_served = 0;
  int bytes_served = 0;
  int files_in_cache = 0;
  int bytes_in_cache = 0;
  int hits_to_cache = 0;
  
  private final byte toBytes(String s)[] {
    byte b[] = s.getBytes();
    return b;
  }

  private MimeHeader makeMimeHeader(String type, int length) {
    MimeHeader mh = new MimeHeader();
    Date curDate = new Date();
    TimeZone gmtTz = TimeZone.getTimeZone("GMT");
    SimpleDateFormat sdf =
      new SimpleDateFormat("dd MMM yyyy hh:mm:ss zzz");
    sdf.setTimeZone(gmtTz);
    mh.put("Date", sdf.format(curDate));
    mh.put("Server", "JavaCompleteReference/" + version);
    mh.put("Content-Type", type);
    if (length >= 0)
      mh.put("Content-Length", String.valueOf(length));
    return mh;
  }

  private String error(int code, String msg, String url) {
    String html_page = "<body>" + CRLF +
                 "<h1>" + code + " " + msg + "</h1>" + CRLF;
    if (url != null) 
      html_page += "Error when fetching URL: " + url + CRLF;
    html_page += "</body>" + CRLF;
    MimeHeader mh = makeMimeHeader(mime_text_html, html_page.length());
    HttpResponse hr = new HttpResponse(code, msg, mh);

    logEntry("GET", url, code, 0);
    return hr + html_page;
  }

  // Read 'in' until you get two \n's in a row.
  // Return up to that point as a String.
  // Discard all \r's.
  private String getRawRequest(InputStream in)
    throws IOException {
    byte buf[] = new byte[buffer_size];
    int pos=0;
    int c;
    while ((c = in.read()) != -1) {
      switch (c) {
        case '\r':
        break;
        case '\n': 
          if (buf[pos-1] == c) {
            return new String(buf,0,pos);
          }
        default:
          buf[pos++] = (byte) c;
      }
    }
    return null;
  }

  static String months[] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
  };
  private String host;
  // fmt02d is the same as C's printf("%02d", i)
  private final String fmt02d(int i) {
    if(i < 0) {
      i = -i;
      return ((i < 9) ? "-0" : "-") + i;
    }
    else {
      return ((i < 9) ? "0" : "") + i;
    }
  }
  private void logEntry(String cmd, String url, int code, int size) {
    Calendar calendar = Calendar.getInstance();
    int tzmin = calendar.get(Calendar.ZONE_OFFSET)/(60*1000);  
    int tzhour = tzmin / 60;
    tzmin -= tzhour * 60;
    log.log(host + " - - [" +
      fmt02d(calendar.get(Calendar.DATE) ) + "/" +
      months[calendar.get(Calendar.MONTH)] + "/" +
      calendar.get(Calendar.YEAR) + ":" + 
      fmt02d(calendar.get(Calendar.HOUR) ) + ":" + 
      fmt02d(calendar.get(Calendar.MINUTE) ) + ":" + 
      fmt02d(calendar.get(Calendar.SECOND)) + " " + 
      fmt02d(tzhour) + fmt02d(tzmin) +
      "] \"" +
      cmd + " " +
      url + " HTTP/1.0\" " +
      code + " " +
      size + "\n");
    hits_served++;
    bytes_served += size;
  }

  private void writeString(OutputStream out, String s)
    throws IOException {
    out.write(toBytes(s));
  }

  private void writeUCE(OutputStream out, UrlCacheEntry uce)
    throws IOException {
      HttpResponse hr = new HttpResponse(200, "OK", uce.mh);
      writeString(out, hr.toString());
      out.write(uce.data, 0, uce.length);
      logEntry("GET", uce.url, 200, uce.length);
  }

  private boolean serveFromCache(OutputStream out, String url)
    throws IOException {
    UrlCacheEntry uce;
    if ((uce = (UrlCacheEntry)cache.get(url)) != null) {
      writeUCE(out, uce);
      hits_to_cache++;
      return true;
    }
    return false;
  }

  private UrlCacheEntry loadFile(InputStream in, String url,
                                 MimeHeader mh)
    throws IOException {

    UrlCacheEntry uce;
    byte file_buf[] = new byte[buffer_size];
    uce = new UrlCacheEntry(url, mh);
    int size = 0;
    int n;
    while ((n = in.read(file_buf)) >= 0) {
      uce.append(file_buf, n);
      size += n;
    }
    in.close();
    cache.put(url, uce);
    files_in_cache++;
    bytes_in_cache += uce.length;
    return uce;
  }

  private UrlCacheEntry readFile(File f, String url)
    throws IOException {

    if (!f.exists())
      return null;
    InputStream in = new FileInputStream(f);
    int file_length = in.available();
    String mime_type = fnameToMimeType(url);
    MimeHeader mh = makeMimeHeader(mime_type, file_length);
    UrlCacheEntry uce = loadFile(in, url, mh);
    return uce;
  }

  private void writeDiskCache(UrlCacheEntry uce)
    throws IOException {

    String path = docRoot + uce.url;
    String dir = path.substring(0, path.lastIndexOf("/"));
    dir.replace('/', File.separatorChar);
    new File(dir).mkdirs();
    FileOutputStream out = new FileOutputStream(path);
    out.write(uce.data, 0, uce.length);
    out.close();
  }

  // A client asks us for a url that looks like this:
  // http://the.internet.site/the/url
  // we go get it from the site and return it...
  private void handleProxy(OutputStream out, String url,
                           MimeHeader inmh) {
    try {
      int start = url.indexOf("://") + 3;
      int path = url.indexOf('/', start);
      String site = url.substring(start, path).toLowerCase();
      int port = 80;
      String server_url = url.substring(path);
      int colon = site.indexOf(':');
      if (colon > 0) {
        port = Integer.parseInt(site.substring(colon + 1));
        site = site.substring(0, colon);
      }
      url = "/cache/" + site + ((port != 80) ? (":" + port) : "") +
            server_url;
      if (url.endsWith("/"))
        url += indexfile;

      if (!serveFromCache(out, url)) {
        if (readFile(new File(docRoot + url), url) != null) {
          serveFromCache(out, url);
          return;
        }

        // If we haven't already cached this page, open a socket
        // to the site's port and send a GET command to it.
        // We modify the user-agent to add ourselves... "via".

        Socket server = new Socket(site, port);
        InputStream server_in = server.getInputStream();
        OutputStream server_out = server.getOutputStream();
        inmh.put("User-Agent", inmh.get("User-Agent") +
                 " via JavaCompleteReferenceProxy/" + version);
        String req = "GET " + server_url + " HTTP/1.0" + CRLF +
                     inmh + CRLF;
        writeString(server_out, req);
        String raw_request = getRawRequest(server_in);
        HttpResponse server_response =
                       new HttpResponse(raw_request);
        writeString(out, server_response.toString());
        if (server_response.statusCode == 200) {
          UrlCacheEntry uce = loadFile(server_in, url,
                                       server_response.mh);
          out.write(uce.data, 0, uce.length);
          writeDiskCache(uce);
          logEntry("GET", site + server_url, 200, uce.length);
        }
        server_out.close();
        server.close();
      }
    } catch (IOException e) {
      log.log("Exception: " + e);
    }
  }

  private void handleGet(OutputStream out, String url,
                         MimeHeader inmh) {
    byte file_buf[] = new byte[buffer_size];
    String filename = docRoot + url +
                      (url.endsWith("/") ? indexfile : "");
    try {
      if (!serveFromCache(out, url)) {
        File f = new File(filename);
        if (! f.exists()) {
          writeString(out, error(404, "Not Found", filename));
          return;
        }
        if (! f.canRead()) {
          writeString(out, error(404, "Permission Denied", filename));
          return;
        }
        UrlCacheEntry uce = readFile(f, url);
        writeUCE(out, uce);
      }
    } catch (IOException e) {
      log.log("Exception: " + e);
    }
  }

  private void doRequest(Socket s) throws IOException {
    if(stopFlag)
      return;
    InputStream in = s.getInputStream();
    OutputStream out = s.getOutputStream();

    String request = getRawRequest(in);
    int fsp = request.indexOf(' ');
    int nsp = request.indexOf(' ', fsp+1);
    int eol = request.indexOf('\n');
    String method = request.substring(0, fsp);
    String url = request.substring(fsp+1, nsp);
    String raw_mime_header = request.substring(eol + 1);

    MimeHeader inmh = new MimeHeader(raw_mime_header);

    request = request.substring(0, eol);

    if (method.equalsIgnoreCase("get")) {
      if (url.indexOf("://") >= 0) {
        handleProxy(out, url, inmh);
      } else {
        handleGet(out, url, inmh);
      }
    } else {
      writeString(out, error(405, "Method Not Allowed", method));
    }
    in.close();
    out.close();
  }

  public void run() {
    try {
      ServerSocket acceptSocket;
      acceptSocket = new ServerSocket(port);
      while (true) {
        Socket s = acceptSocket.accept();
        host = s.getInetAddress().getHostName();
        doRequest(s);
        s.close();
      }
    } catch (IOException e) {
      log.log("accept loop IOException: " + e + "\n");
    } catch (Exception e) {
      log.log("Exception: " + e);
    }
  }

  private Thread t;
  public synchronized void start() {
    stopFlag = false;
    if (t == null) {
      t = new Thread(this);
      t.start();
    }
  }

  public synchronized void stop() {
    stopFlag = true;
    log.log("Stopped at " + new Date() + "\n");
  }
  
  public httpd(int p, String dr, LogMessage lm) {
    port = p;
    docRoot = dr;
    log = lm;
  }

  // This main and log method allow httpd to be run from the console.
  public static void main(String args[]) {
    httpd h = new httpd(80, "c:\\www", null);
    h.log = h;
    h.start();
    try {
      Thread.currentThread().join();
    } catch (InterruptedException e) {};
  }

  public void log(String m) {
    System.out.print(m);
  }
}

listing 10
import java.util.*;
import java.applet.*;
import java.awt.*;
import java.awt.event.*;

public class HTTP extends Applet implements LogMessage,
                                            ActionListener
{
  private int m_port = 80;
  private String m_docroot = "c:\\www";
  private httpd m_httpd;
  private TextArea m_log;
  private Label status;

  private final String PARAM_port = "port";
  private final String PARAM_docroot = "docroot";
  public HTTP()  {
  }

  public void init()  {
    setBackground(Color.white);
    String param;

    // port: Port number to listen on
    param = getParameter(PARAM_port);
    if (param != null)
      m_port = Integer.parseInt(param);

    // docroot: web document root
    param = getParameter(PARAM_docroot);
    if (param != null)
      m_docroot = param;

    setLayout(new BorderLayout());

    Label lab = new Label("Java HTTPD");

    lab.setFont(new Font("SansSerif", Font.BOLD, 18));
    add("North", lab);
    m_log = new TextArea("", 24, 80);
    add("Center", m_log);
    Panel p = new Panel();
    p.setLayout(new FlowLayout(FlowLayout.CENTER,1,1));
    add("South", p);
    Button bstart = new Button("Start");
    bstart.addActionListener(this);
    p.add(bstart);
    Button bstop = new Button("Stop");
    bstop.addActionListener(this);
    p.add(bstop);
    status = new Label("raw");
    status.setForeground(Color.green);
    status.setFont(new Font("SansSerif", Font.BOLD, 10));
    p.add(status);
    m_httpd = new httpd(m_port, m_docroot, this);
  }

  public void destroy()  {
    stop();
  }

  public void paint(Graphics g)  {
  }

  public void start()  {
    m_httpd.start();
    status.setText("Running  ");
    clear_log("Log started on " + new Date() + "\n"); 
  }

  public void stop()  {
    m_httpd.stop();
    status.setText("Stopped  ");
  }

  public void actionPerformed(ActionEvent ae) {
    String label = ae.getActionCommand();
    if(label.equals("Start")) {
      start();
    }
    else {
      stop();
    }
  }

  public void clear_log(String msg) {
    m_log.setText(msg + "\n");
  }

  public void log(String msg) {
    m_log.append(msg);
    status.setText(m_httpd.hits_served + " hits (" +
            (m_httpd.bytes_served / 1024) + "K), " +
            m_httpd.files_in_cache + " cached files (" +
            (m_httpd.bytes_in_cache / 1024) + "K), " +
            m_httpd.hits_to_cache + " cached hits");
    status.setSize(status.getPreferredSize());
  }
}

listing 11
// Demonstrate Datagrams.
import java.net.*;

class WriteServer {
  public static int serverPort = 998;
  public static int clientPort = 999;
  public static int buffer_size = 1024;
  public static DatagramSocket ds;
  public static byte buffer[] = new byte[buffer_size];

  public static void TheServer() throws Exception {
    int pos=0;
    while (true) {
      int c = System.in.read();
      switch (c) {
        case -1: 
          System.out.println("Server Quits.");
          return;
        case '\r': 
          break;
        case '\n':
          ds.send(new DatagramPacket(buffer,pos,
             InetAddress.getLocalHost(),clientPort));
          pos=0;
          break;
        default:
          buffer[pos++] = (byte) c;
      }
    }
  }

  public static void TheClient() throws Exception {
    while(true) {
      DatagramPacket p = new DatagramPacket(buffer, buffer.length);
      ds.receive(p);
      System.out.println(new String(p.getData(), 0, p.getLength()));
    }
  }

  public static void main(String args[]) throws Exception {
    if(args.length == 1) {
      ds = new DatagramSocket(serverPort);
      TheServer();
    } else {
      ds = new DatagramSocket(clientPort);
      TheClient();
    }
  }
}

 
 
/**************** 
 * Chapter  19  *
 ****************/

listing 1
// An Applet skeleton.
import java.awt.*;
import java.applet.*;
/*
<applet code="AppletSkel" width=300 height=100>
</applet>
*/

public class AppletSkel extends Applet {
  // Called first.
  public void init() {
    // initialization
  }

  /* Called second, after init().  Also called whenever
     the applet is restarted. */
  public void start() {
    // start or resume execution
  }

  // Called when the applet is stopped.
  public void stop() {
    // suspends execution
  }

  /* Called when applet is terminated.  This is the last
     method executed. */
  public void destroy() {
    // perform shutdown activities
  }

  // Called when an applet's window must be restored.
  public void paint(Graphics g) {
    // redisplay contents of window
  }
}

listing 2
public void update(Graphics g) {
  // redisplay your window, here.
}

public void paint(Graphics g) {
  update(g);
}

listing 3
/* A simple applet that sets the foreground and
   background colors and outputs a string. */
import java.awt.*;
import java.applet.*;
/*
<applet code="Sample" width=300 height=50>
</applet>
*/

public class Sample extends Applet{
  String msg;

  // set the foreground and background colors.
  public void init() {
    setBackground(Color.cyan);
    setForeground(Color.red);
    msg = "Inside init( ) --";
  }

  // Initialize the string to be displayed.
  public void start() {
    msg += " Inside start( ) --";
  }

  // Display msg in applet window.
  public void paint(Graphics g) {
    msg += " Inside paint( ).";
    g.drawString(msg, 10, 30);
  }
}

listing 4
/* A simple banner applet.

   This applet creates a thread that scrolls
   the message contained in msg right to left
   across the applet's window.
*/
import java.awt.*;
import java.applet.*;
/*
<applet code="SimpleBanner" width=300 height=50>
</applet>
*/

public class SimpleBanner extends Applet implements Runnable {
  String msg = " A Simple Moving Banner.";
  Thread t = null;
  int state;
  boolean stopFlag;

  // Set colors and initialize thread.
  public void init() {
    setBackground(Color.cyan);
    setForeground(Color.red);
  }

  // Start thread
  public void start() {
    t = new Thread(this);
    stopFlag = false;
    t.start();
  }

  // Entry point for the thread that runs the banner.
  public void run() {
    char ch;

    // Display banner 
    for( ; ; ) {
      try {
        repaint();
        Thread.sleep(250);
        ch = msg.charAt(0);
        msg = msg.substring(1, msg.length());
        msg += ch;
        if(stopFlag)
          break;
      } catch(InterruptedException e) {}
    }
  }

  // Pause the banner.
  public void stop() {
    stopFlag = true;
    t = null;
  }

  // Display the banner.
  public void paint(Graphics g) {
    g.drawString(msg, 50, 30);
  }
}

listing 5
// Using the Status Window.
import java.awt.*;
import java.applet.*;
/*
<applet code="StatusWindow" width=300 height=50>
</applet>
*/

public class StatusWindow extends Applet{
  public void init() {
    setBackground(Color.cyan);
  }

  // Display msg in applet window.
  public void paint(Graphics g) {
    g.drawString("This is in the applet window.", 10, 20);
    showStatus("This is shown in the status window.");
  }
}

listing 6
// Use Parameters
import java.awt.*;
import java.applet.*;
/*
<applet code="ParamDemo" width=300 height=80>
<param name=fontName value=Courier>
<param name=fontSize value=14>
<param name=leading value=2>
<param name=accountEnabled value=true>
</applet>
*/

public class ParamDemo extends Applet{
  String fontName;
  int fontSize;
  float leading;
  boolean active;

  // Initialize the string to be displayed.
  public void start() {
    String param;

    fontName = getParameter("fontName");
    if(fontName == null)
      fontName = "Not Found";

    param = getParameter("fontSize");
    try {
      if(param != null) // if not found
        fontSize = Integer.parseInt(param);
      else
        fontSize = 0;
    } catch(NumberFormatException e) {
      fontSize = -1;
    }

    param = getParameter("leading");
    try {
      if(param != null) // if not found
        leading = Float.valueOf(param).floatValue();
      else
        leading = 0;
    } catch(NumberFormatException e) {
      leading = -1;
    }

    param = getParameter("accountEnabled");
    if(param != null)
      active = Boolean.valueOf(param).booleanValue();
  }

  // Display parameters.
  public void paint(Graphics g) {
    g.drawString("Font name: " + fontName, 0, 10);
    g.drawString("Font size: " + fontSize, 0, 26);
    g.drawString("Leading: " + leading, 0, 42);
    g.drawString("Account Active: " + active, 0, 58);
  }
}

listing 7
// A parameterized banner
import java.awt.*;
import java.applet.*;
/*
<applet code="ParamBanner" width=300 height=50>
<param name=message value="Java makes the Web move!">
</applet>
*/

public class ParamBanner extends Applet implements Runnable {
  String msg;
  Thread t = null;
  int state;
  boolean stopFlag;

  // Set colors and initialize thread.
  public void init() {
    setBackground(Color.cyan);
    setForeground(Color.red);
  }

  // Start thread
  public void start() {
    msg = getParameter("message");
    if(msg == null) msg = "Message not found.";
    msg = " " + msg;
    t = new Thread(this);
    stopFlag = false;
    t.start();
  }

  // Entry point for the thread that runs the banner.
  public void run() {
    char ch;

    // Display banner 
    for( ; ; ) {
      try {
        repaint();
        Thread.sleep(250);
        ch = msg.charAt(0);
        msg = msg.substring(1, msg.length());
        msg += ch;
        if(stopFlag)
          break;
      } catch(InterruptedException e) {}
    }
  }

  // Pause the banner.
  public void stop() {
    stopFlag = true;
    t = null;
  }

  // Display the banner.
  public void paint(Graphics g) {
    g.drawString(msg, 50, 30);
  }
}

listing 8
// Display code and document bases.
import java.awt.*;
import java.applet.*;
import java.net.*;
/*
<applet code="Bases" width=300 height=50>
</applet>
*/

public class Bases extends Applet{ 
  // Display code and document bases.
  public void paint(Graphics g) {
    String msg;

    URL url = getCodeBase(); // get code base
    msg = "Code base: " + url.toString();
    g.drawString(msg, 10, 20);

    url = getDocumentBase(); // get document base
    msg = "Document base: " + url.toString();
    g.drawString(msg, 10, 40);
  }
}

listing 9
/* Using an applet context, getCodeBase(),
   and showDocument() to display an HTML file.
*/

import java.awt.*;
import java.applet.*;
import java.net.*;
/*
<applet code="ACDemo" width=300 height=50>
</applet>
*/

public class ACDemo extends Applet{
  public void start() {
    AppletContext ac = getAppletContext();
    URL url = getCodeBase(); // get url of this applet

    try {
      ac.showDocument(new URL(url+"Test.html"));
    } catch(MalformedURLException e) {
      showStatus("URL not found");
    }
  }
}

 
 
/**************** 
 * Chapter  20  *
 ****************/

listing 1
// Demonstrate the mouse event handlers.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="MouseEvents" width=300 height=100>
  </applet>
*/

public class MouseEvents extends Applet
  implements MouseListener, MouseMotionListener {

  String msg = "";
  int mouseX = 0, mouseY = 0; // coordinates of mouse

  public void init() {
     addMouseListener(this);
     addMouseMotionListener(this);
  }

  // Handle mouse clicked.
  public void mouseClicked(MouseEvent me) {
    // save coordinates
    mouseX = 0;
    mouseY = 10;
    msg = "Mouse clicked.";
    repaint();
  }

  // Handle mouse entered.
  public void mouseEntered(MouseEvent me) {
    // save coordinates
    mouseX = 0;
    mouseY = 10;
    msg = "Mouse entered.";
    repaint();
  }

  // Handle mouse exited.
  public void mouseExited(MouseEvent me) {
    // save coordinates
    mouseX = 0;
    mouseY = 10;
    msg = "Mouse exited.";
    repaint();
  }

  // Handle button pressed.
  public void mousePressed(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    msg = "Down";
    repaint();
  }

  // Handle button released.
  public void mouseReleased(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    msg = "Up";
    repaint();
  }

  // Handle mouse dragged.
  public void mouseDragged(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    msg = "*";
    showStatus("Dragging mouse at " + mouseX + ", " + mouseY);
    repaint();
  }

  // Handle mouse moved.
  public void mouseMoved(MouseEvent me) {
    // show status
    showStatus("Moving mouse at " + me.getX() + ", " + me.getY());
  }

  // Display msg in applet window at current X,Y location.
  public void paint(Graphics g) {
    g.drawString(msg, mouseX, mouseY);
  }    
}

listing 2
// Demonstrate the key event handlers.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="SimpleKey" width=300 height=100>
  </applet>
*/

public class SimpleKey extends Applet
  implements KeyListener {

  String msg = "";
  int X = 10, Y = 20; // output coordinates

  public void init() {
    addKeyListener(this);
    requestFocus(); // request input focus
  }

  public void keyPressed(KeyEvent ke) {
    showStatus("Key Down");
  }

  public void keyReleased(KeyEvent ke) {
    showStatus("Key Up");
  }

  public void keyTyped(KeyEvent ke) {
    msg += ke.getKeyChar();
    repaint();
  }

  // Display keystrokes.
  public void paint(Graphics g) {
    g.drawString(msg, X, Y);
  }    
}

listing 3
// Demonstrate some virutal key codes.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="KeyEvents" width=300 height=100>
  </applet>
*/

public class KeyEvents extends Applet
  implements KeyListener {

  String msg = "";
  int X = 10, Y = 20; // output coordinates

  public void init() {
    addKeyListener(this);
    requestFocus(); // request input focus
  }

  public void keyPressed(KeyEvent ke) {
    showStatus("Key Down");

    int key = ke.getKeyCode(); 
    switch(key) {
      case KeyEvent.VK_F1:
        msg += "<F1>";
        break;
      case KeyEvent.VK_F2:
        msg += "<F2>";
        break;
      case KeyEvent.VK_F3:
        msg += "<F3>";
        break;
      case KeyEvent.VK_PAGE_DOWN:
        msg += "<PgDn>";
        break;
      case KeyEvent.VK_PAGE_UP:
        msg += "<PgUp>";
        break;
      case KeyEvent.VK_LEFT:
        msg += "<Left Arrow>";
        break;
      case KeyEvent.VK_RIGHT:
        msg += "<Right Arrow>";
        break;
    }

    repaint();
  }

  public void keyReleased(KeyEvent ke) {
    showStatus("Key Up");
  }

  public void keyTyped(KeyEvent ke) {
    msg += ke.getKeyChar();
    repaint();
  }

  // Display keystrokes.
  public void paint(Graphics g) {
    g.drawString(msg, X, Y);
  }    
}

listing 4
// Demonstrate an adaptor.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="AdapterDemo" width=300 height=100>
  </applet>
*/

public class AdapterDemo extends Applet {
  public void init() {
     addMouseListener(new MyMouseAdapter(this));
     addMouseMotionListener(new MyMouseMotionAdapter(this));
  }
}

class MyMouseAdapter extends MouseAdapter {
  AdapterDemo adapterDemo;
  public MyMouseAdapter(AdapterDemo adapterDemo) {
    this.adapterDemo = adapterDemo;
  }

  // Handle mouse clicked.
  public void mouseClicked(MouseEvent me) {
    adapterDemo.showStatus("Mouse clicked");
  }
}

class MyMouseMotionAdapter extends MouseMotionAdapter {
  AdapterDemo adapterDemo;
  public MyMouseMotionAdapter(AdapterDemo adapterDemo) {
    this.adapterDemo = adapterDemo;
  }

  // Handle mouse dragged.
  public void mouseDragged(MouseEvent me) {
    adapterDemo.showStatus("Mouse dragged");
  } 
}

listing 5
// This applet does NOT use an inner class.
import java.applet.*;
import java.awt.event.*;
/*
  <applet code="MousePressedDemo" width=200 height=100>
  </applet>
 
*/
 
public class MousePressedDemo extends Applet {
  public void init() {
    addMouseListener(new MyMouseAdapter(this));
  }
}

class MyMouseAdapter extends MouseAdapter {
  MousePressedDemo mousePressedDemo;
  public MyMouseAdapter(MousePressedDemo mousePressedDemo) {
    this.mousePressedDemo = mousePressedDemo;
  }
  public void mousePressed(MouseEvent me) {
    mousePressedDemo.showStatus("Mouse Pressed.");
  }
}

listing 6
// Inner class demo
import java.applet.*;
import java.awt.event.*;
/*
  <applet code="InnerClassDemo" width=200 height=100>
  </applet>
 
*/
 
public class InnerClassDemo extends Applet {
  public void init() {
    addMouseListener(new MyMouseAdapter());
  }
  class MyMouseAdapter extends MouseAdapter {
    public void mousePressed(MouseEvent me) {
      showStatus("Mouse Pressed");
    }
  }
}

listing 7
// Anonymous inner class demo.
import java.applet.*;
import java.awt.event.*;
/*
  <applet code="AnonymousInnerClassDemo" width=200 height=100>
  </applet>
*/
 
public class AnonymousInnerClassDemo extends Applet {
  public void init() {
    addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent me) {
        showStatus("Mouse Pressed");
      }
    });
  }
}

 
 
/**************** 
 * Chapter  21  *
 ****************/

listing 1
//  Create a child frame window from within an applet.
import java.awt.*; 
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="AppletFrame" width=300 height=50>
  </applet>
*/

// Create a subclass of Frame.
class SampleFrame extends Frame {
  SampleFrame(String title) {
    super(title);
    // create an object to handle window events
    MyWindowAdapter adapter = new MyWindowAdapter(this);
     // register it to receive those events
    addWindowListener(adapter);
  }
  public void paint(Graphics g) {
    g.drawString("This is in frame window", 10, 40);
  }    
}

class MyWindowAdapter extends WindowAdapter {
  SampleFrame sampleFrame;
  public MyWindowAdapter(SampleFrame sampleFrame) {
    this.sampleFrame = sampleFrame;
  }
  public void windowClosing(WindowEvent we) {
    sampleFrame.setVisible(false);
  }
}

// Create frame window.
public class AppletFrame extends Applet {
  Frame f;
  public void init() {
    f = new SampleFrame("A Frame Window");
    
    f.setSize(250, 250);
    f.setVisible(true);
  }
  public void start() {
    f.setVisible(true);
  }
  public void stop() {
    f.setVisible(false);
  }  
  public void paint(Graphics g) {
    g.drawString("This is in applet window", 10, 20);
  }  
}

listing 2
// Handle mouse events in both child and applet windows.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="WindowEvents" width=300 height=50>
  </applet>
*/

// Create a subclass of Frame.
class SampleFrame extends Frame
  implements MouseListener, MouseMotionListener {

  String msg = "";
  int mouseX=10, mouseY=40;
  int movX=0, movY=0;

  SampleFrame(String title) {
    super(title);
    // register this object to receive its own mouse events
    addMouseListener(this);
    addMouseMotionListener(this);
    // create an object to handle window events
    MyWindowAdapter adapter = new MyWindowAdapter(this);
    // register it to receive those events
    addWindowListener(adapter);
  }

  // Handle mouse clicked.
  public void mouseClicked(MouseEvent me) {
  }
  

  // Handle mouse entered.
  public void mouseEntered(MouseEvent evtObj) {
    // save coordinates
    mouseX = 10;
    mouseY = 54;
    msg = "Mouse just entered child.";
    repaint();
  }

  // Handle mouse exited.
  public void mouseExited(MouseEvent evtObj) {
    // save coordinates
    mouseX = 10;
    mouseY = 54;
    msg = "Mouse just left child window.";
    repaint();
  }

  // Handle mouse pressed.
  public void mousePressed(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    msg = "Down";
    repaint();
  }

  // Handle mouse released.
  public void mouseReleased(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    msg = "Up";
    repaint();
  }

  // Handle mouse dragged.
  public void mouseDragged(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    movX = me.getX();
    movY = me.getY();
    msg = "*";
    repaint();
  }

  // Handle mouse moved.
  public void mouseMoved(MouseEvent me) {
    // save coordinates
    movX = me.getX();
    movY = me.getY();
    repaint(0, 0, 100, 60);
  }

  public void paint(Graphics g) {
    g.drawString(msg, mouseX, mouseY);
    g.drawString("Mouse at " + movX + ", " + movY, 10, 40);
  }    
}

class MyWindowAdapter extends WindowAdapter {
  SampleFrame sampleFrame;
  public MyWindowAdapter(SampleFrame sampleFrame) {
    this.sampleFrame = sampleFrame;
  }
  public void windowClosing(WindowEvent we) {
    sampleFrame.setVisible(false);
  }
}

// Applet window.
public class WindowEvents extends Applet
  implements MouseListener, MouseMotionListener {

  SampleFrame f;
  String msg = "";
  int mouseX=0, mouseY=10;
  int movX=0, movY=0;
  
  // Create a frame window.
  public void init() {
    f = new SampleFrame("Handle Mouse Events");
    f.setSize(300, 200);
    f.setVisible(true);

    // register this object to receive its own mouse events
    addMouseListener(this);
    addMouseMotionListener(this);
  }

  // Remove frame window when stopping applet.
  public void stop() {
    f.setVisible(false); 
  }

  // Show frame window when starting applet.
  public void start() {
    f.setVisible(true); 
  }

  // Handle mouse clicked.
  public void mouseClicked(MouseEvent me) {
  }

  // Handle mouse entered.
  public void mouseEntered(MouseEvent me) {
    // save coordinates
    mouseX = 0;
    mouseY = 24;
    msg = "Mouse just entered applet window.";
    repaint();
  }

  // Handle mouse exited.
  public void mouseExited(MouseEvent me) {
    // save coordinates
    mouseX = 0;
    mouseY = 24;
    msg = "Mouse just left applet window.";
    repaint();
  }

  // Handle button pressed.
  public void mousePressed(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    msg = "Down";
    repaint();
  }

  // Handle button released.
  public void mouseReleased(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    msg = "Up";
    repaint();
  }
  
  // Handle mouse dragged.
  public void mouseDragged(MouseEvent me) {
    // save coordinates
    mouseX = me.getX();
    mouseY = me.getY();
    movX = me.getX();
    movY = me.getY();
    msg = "*";
    repaint();
  }

  // Handle mouse moved.
  public void mouseMoved(MouseEvent me) {
    // save coordinates
    movX = me.getX();
    movY = me.getY();
    repaint(0, 0, 100, 20);
  }

  // Display msg in applet window.
  public void paint(Graphics g) {
    g.drawString(msg, mouseX, mouseY);
    g.drawString("Mouse at " + movX + ", " + movY, 0, 10);
 }    
}

listing 3
// Create an AWT-based application.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

// Create a frame window.
public class AppWindow extends Frame {
  String keymsg = "This is a test.";
  String mousemsg = "";
  int mouseX=30, mouseY=30;

  public AppWindow() {
    addKeyListener(new MyKeyAdapter(this));
    addMouseListener(new MyMouseAdapter(this));
    addWindowListener(new MyWindowAdapter());
  }

  public void paint(Graphics g) {
    g.drawString(keymsg, 10, 40);
    g.drawString(mousemsg, mouseX, mouseY);
  }

  // Create the window.
  public static void main(String args[]) {
    AppWindow appwin = new AppWindow();

    appwin.setSize(new Dimension(300, 200));
    appwin.setTitle("An AWT-Based Application");
    appwin.setVisible(true);
  }
}

class MyKeyAdapter extends KeyAdapter {
  AppWindow appWindow;
  public MyKeyAdapter(AppWindow appWindow) {
    this.appWindow = appWindow;
  }
  public void keyTyped(KeyEvent ke) {
    appWindow.keymsg += ke.getKeyChar();
    appWindow.repaint();
  };
}

class MyMouseAdapter extends MouseAdapter {
  AppWindow appWindow;
  public MyMouseAdapter(AppWindow appWindow) {
    this.appWindow = appWindow;
  }
  public void mousePressed(MouseEvent me) {
    appWindow.mouseX = me.getX();
    appWindow.mouseY = me.getY();
    appWindow.mousemsg = "Mouse Down at " + appWindow.mouseX +
                         ", " + appWindow.mouseY;
    appWindow.repaint();
  }
}

class MyWindowAdapter extends WindowAdapter {
  public void windowClosing(WindowEvent we) {
    System.exit(0);
  }
}

listing 4
// Draw lines
import java.awt.*;
import java.applet.*;
/*
<applet code="Lines" width=300 height=200>
</applet>
*/
public class Lines extends Applet {
  public void paint(Graphics g) {
    g.drawLine(0, 0, 100, 100);
    g.drawLine(0, 100, 100, 0);
    g.drawLine(40, 25, 250, 180);
    g.drawLine(75, 90, 400, 400);
    g.drawLine(20, 150, 400, 40);
    g.drawLine(5, 290, 80, 19);
  }
}

listing 5
// Draw rectangles
import java.awt.*;
import java.applet.*;
/*
<applet code="Rectangles" width=300 height=200>
</applet>
*/

public class Rectangles extends Applet {
  public void paint(Graphics g) {
    g.drawRect(10, 10, 60, 50);
    g.fillRect(100, 10, 60, 50);
    g.drawRoundRect(190, 10, 60, 50, 15, 15);
    g.fillRoundRect(70, 90, 140, 100, 30, 40);
  }
}

listing 6
// Draw Ellipses
import java.awt.*;
import java.applet.*;
/*
<applet code="Ellipses" width=300 height=200>
</applet>
*/

public class Ellipses extends Applet {
  public void paint(Graphics g) {
    g.drawOval(10, 10, 50, 50);
    g.fillOval(100, 10, 75, 50);
    g.drawOval(190, 10, 90, 30);
    g.fillOval(70, 90, 140, 100);
  }
}

listing 7
// Draw Arcs
import java.awt.*;
import java.applet.*;
/*
<applet code="Arcs" width=300 height=200>
</applet>
*/

public class Arcs extends Applet {
  public void paint(Graphics g) {
    g.drawArc(10, 40, 70, 70, 0, 75);
    g.fillArc(100, 40, 70, 70, 0, 75);
    g.drawArc(10, 100, 70, 80, 0, 175);
    g.fillArc(100, 100, 70, 90, 0, 270);
    g.drawArc(200, 80, 80, 80, 0, 180);
  }
}

listing 8
// Draw Polygon
import java.awt.*;
import java.applet.*;
/*
<applet code="HourGlass" width=230 height=210>
</applet>
*/

public class HourGlass extends Applet {
  public void paint(Graphics g) {
    int xpoints[] = {30, 200, 30, 200, 30};
    int ypoints[] = {30, 30, 200, 200, 30};
    int num = 5;

    g.drawPolygon(xpoints, ypoints, num);
  }
}

listing 9
// Resizing output to fit the current size of a window.
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
/*
  <applet code="ResizeMe" width=200 height=200>
  </applet>
 */
 
public class ResizeMe extends Applet {
  final int inc = 25;
  int max = 500;
  int min = 200;
  Dimension d;

  public ResizeMe() {
    addMouseListener(new MouseAdapter() {
      public void mouseReleased(MouseEvent me) {
        int w = (d.width + inc) > max?min :(d.width + inc);
        int h = (d.height + inc) > max?min :(d.height + inc);
        setSize(new Dimension(w, h));
      }
    });
  }
  public void paint(Graphics g) {
    d = getSize();

    g.drawLine(0, 0, d.width-1, d.height-1);
    g.drawLine(0, d.height-1, d.width-1, 0);
    g.drawRect(0, 0, d.width-1, d.height-1);
  }
}

listing 10
// Demonstrate color.
import java.awt.*;
import java.applet.*;
/*
<applet code="ColorDemo" width=300 height=200>
</applet>
*/

public class ColorDemo extends Applet {
  // draw lines
  public void paint(Graphics g) {
    Color c1 = new Color(255, 100, 100);
    Color c2 = new Color(100, 255, 100);
    Color c3 = new Color(100, 100, 255);

    g.setColor(c1);
    g.drawLine(0, 0, 100, 100);
    g.drawLine(0, 100, 100, 0);

    g.setColor(c2);
    g.drawLine(40, 25, 250, 180);
    g.drawLine(75, 90, 400, 400);

    g.setColor(c3);
    g.drawLine(20, 150, 400, 40);
    g.drawLine(5, 290, 80, 19);

    g.setColor(Color.red);
    g.drawOval(10, 10, 50, 50);
    g.fillOval(70, 90, 140, 100);

    g.setColor(Color.blue);
    g.drawOval(190, 10, 90, 30);
    g.drawRect(10, 10, 60, 50);

    g.setColor(Color.cyan);
    g.fillRect(100, 10, 60, 50);
    g.drawRoundRect(190, 10, 60, 50, 15, 15);
  }
}

listing 11
// Demonstrate XOR mode.
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="XOR" width=400 height=200>
  </applet>
*/

public class XOR extends Applet {
  int chsX=100, chsY=100;

  public XOR() {
    addMouseMotionListener(new MouseMotionAdapter() {
      public void mouseMoved(MouseEvent me) {
        int x = me.getX();
        int y = me.getY();
        chsX = x-10;
        chsY = y-10;
        repaint();
      }
    });
  }
   
  public void paint(Graphics g) {
    g.drawLine(0, 0, 100, 100);
    g.drawLine(0, 100, 100, 0);
    g.setColor(Color.blue);
    g.drawLine(40, 25, 250, 180);
    g.drawLine(75, 90, 400, 400);
    g.setColor(Color.green);
    g.drawRect(10, 10, 60, 50);
    g.fillRect(100, 10, 60, 50);
    g.setColor(Color.red);
    g.drawRoundRect(190, 10, 60, 50, 15, 15);
    g.fillRoundRect(70, 90, 140, 100, 30, 40);
    g.setColor(Color.cyan);
    g.drawLine(20, 150, 400, 40);
    g.drawLine(5, 290, 80, 19);

    // xor cross hairs
    g.setXORMode(Color.black);
    g.drawLine(chsX-10, chsY, chsX+10, chsY);
    g.drawLine(chsX, chsY-10, chsX, chsY+10);
    g.setPaintMode();  
  }    
}

listing 12
// Display Fonts
/*
<applet code="ShowFonts" width=550 height=60>
</applet>
*/
import java.applet.*;
import java.awt.*;

public class ShowFonts extends Applet {
  public void paint(Graphics g) {
    String msg = "";
    String FontList[];

    GraphicsEnvironment ge = 
      GraphicsEnvironment.getLocalGraphicsEnvironment();
    FontList = ge.getAvailableFontFamilyNames();
    for(int i = 0; i < FontList.length; i++)
      msg += FontList[i] + " ";

    g.drawString(msg, 4, 16);
  }
}

listing 13
// Show fonts.
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
/*
  <applet code="SampleFonts" width=200 height=100>
  </applet>
*/
 
public class SampleFonts extends Applet {
  int next = 0;
  Font f;
  String msg;
  public void init() {
    f = new Font("Dialog", Font.PLAIN, 12);
    msg = "Dialog";
    setFont(f);
    addMouseListener(new MyMouseAdapter(this));
  }
  
  public void paint(Graphics g) {
    g.drawString(msg, 4, 20);
  }
}

class MyMouseAdapter extends MouseAdapter {
  SampleFonts sampleFonts;
  public MyMouseAdapter(SampleFonts sampleFonts) {
    this.sampleFonts = sampleFonts;
  }
  public void mousePressed(MouseEvent me) {
    // Switch fonts with each mouse click.
    sampleFonts.next++;
    switch(sampleFonts.next) {
    case 0:
      sampleFonts.f = new Font("Dialog", Font.PLAIN, 12);
      sampleFonts.msg = "Dialog";
      break;
    case 1:
      sampleFonts.f = new Font("DialogInput", Font.PLAIN, 12);
      sampleFonts.msg = "DialogInput";
      break;
    case 2:
      sampleFonts.f = new Font("SansSerif", Font.PLAIN, 12);
      sampleFonts.msg = "SansSerif";
      break;
    case 3:
      sampleFonts.f = new Font("Serif", Font.PLAIN, 12);
      sampleFonts.msg = "Serif";
      break;
    case 4:
      sampleFonts.f = new Font("Monospaced", Font.PLAIN, 12);
      sampleFonts.msg = "Monospaced";
      break;
    }
    if(sampleFonts.next == 4) sampleFonts.next = -1;
    sampleFonts.setFont(sampleFonts.f);
    sampleFonts.repaint();
  }
}

listing 14
// Display font info.
import java.applet.*;
import java.awt.*;
/*
<applet code="FontInfo" width=350 height=60>
</applet>
*/

public class FontInfo extends Applet {
  public void paint(Graphics g) {
    Font f = g.getFont();
    String fontName = f.getName();
    String fontFamily = f.getFamily();
    int fontSize = f.getSize();
    int fontStyle = f.getStyle();

    String msg = "Family: " + fontName;
    msg += ", Font: " + fontFamily;
    msg += ", Size: " + fontSize + ", Style: ";
    if((fontStyle & Font.BOLD) == Font.BOLD)
      msg += "Bold ";
    if((fontStyle & Font.ITALIC) == Font.ITALIC)
      msg += "Italic ";
    if((fontStyle & Font.PLAIN) == Font.PLAIN)
      msg += "Plain ";

    g.drawString(msg, 4, 16);
  }
}

listing 15
// Demonstrate multiline output.
import java.applet.*;
import java.awt.*;
/*
<applet code="MultiLine" width=300 height=100>
</applet>
*/

public class MultiLine extends Applet {
  int curX=0, curY=0; // current position

  public void init() {
    Font f = new Font("SansSerif", Font.PLAIN, 12);
    setFont(f);
  }
  public void paint(Graphics g) {
    FontMetrics fm = g.getFontMetrics();

    nextLine("This is on line one.", g);
    nextLine("This is on line two.", g);
    sameLine(" This is on same line.", g);
    sameLine(" This, too.", g);
    nextLine("This is on line three.", g);
  }

  // Advance to next line.
  void nextLine(String s, Graphics g) {
    FontMetrics fm = g.getFontMetrics();

    curY += fm.getHeight(); // advance to next line
    curX = 0;
    g.drawString(s, curX, curY);
    curX = fm.stringWidth(s); // advance to end of line
  }

  // Display on same line.
  void sameLine(String s, Graphics g) {
    FontMetrics fm = g.getFontMetrics();

    g.drawString(s, curX, curY);
    curX += fm.stringWidth(s); // advance to end of line
  }
}

listing 16
// Center text.
import java.applet.*;
import java.awt.*;
/*
  <applet code="CenterText" width=200 height=100>
  </applet> 
*/
 
public class CenterText extends Applet {
  final Font f = new Font("SansSerif", Font.BOLD, 18);

  public void paint(Graphics g) {
    Dimension d = this.getSize();

    g.setColor(Color.white);
    g.fillRect(0, 0, d.width,d.height);
    g.setColor(Color.black);
    g.setFont(f);
    drawCenteredString("This is centered.", d.width, d.height, g);
    g.drawRect(0, 0, d.width-1, d.height-1);
  }

  public void drawCenteredString(String s, int w, int h,
                                 Graphics g) {
    FontMetrics fm = g.getFontMetrics();
    int x = (w - fm.stringWidth(s)) / 2;
    int y = (fm.getAscent() + (h - (fm.getAscent()
             + fm.getDescent()))/2);
    g.drawString(s, x, y);
  }
}

listing 17
// Demonstrate text alignment. 
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
/* <title>Text Layout</title>
   <applet code="TextLayout" width=200 height=200>
   <param name="text" value="Output to a Java window is actually quite easy. 
      As you have seen, the AWT provides support for
      fonts, colors, text, and graphics. <P>  Of course,
      you must effectively utilize these items
      if you are to achieve professional results.">
    <param name="fontname" value="Serif">
    <param name="fontSize" value="14">
   </applet>
 */

 public class TextLayout extends Applet {
  final int LEFT = 0;
  final int RIGHT = 1;
  final int CENTER = 2;
  final int LEFTRIGHT =3;
  int align;
  Dimension d;
  Font f;
  FontMetrics fm;
  int fontSize;
  int fh, bl;
  int space;
  String text;

  public void init() {
    setBackground(Color.white);
    text = getParameter("text");
    try {
      fontSize = Integer.parseInt(getParameter("fontSize"));}
    catch (NumberFormatException e) {
      fontSize=14;
    }
    align = LEFT;
    addMouseListener(new MyMouseAdapter(this));
  }

  public void paint(Graphics g) {
    update(g);
  }

  public void update(Graphics g) {
    d = getSize();
    g.setColor(getBackground());
    g.fillRect(0,0,d.width, d.height);
    if(f==null) f = new Font(getParameter("fontname"),
                             Font.PLAIN, fontSize);
    g.setFont(f);
    if(fm == null) {
        fm = g.getFontMetrics();
        bl = fm.getAscent();
        fh = bl + fm.getDescent();
        space = fm.stringWidth(" ");
    }

    g.setColor(Color.black);
    StringTokenizer st = new StringTokenizer(text);
    int x = 0;
    int nextx;
    int y = 0;
    String word, sp;
    int wordCount = 0;
    String line = "";
    while (st.hasMoreTokens()) {
      word = st.nextToken();
      if(word.equals("<P>")) {
        drawString(g, line, wordCount,
                   fm.stringWidth(line), y+bl);
        line = "";
        wordCount = 0;
        x = 0;
        y = y + (fh * 2);
      }
      else {
        int w = fm.stringWidth(word);
        if(( nextx = (x+space+w)) > d.width ) {
          drawString(g, line, wordCount,
                     fm.stringWidth(line), y+bl);
          line = "";
          wordCount = 0;
          x = 0;
          y = y + fh;
        }
        if(x!=0) {sp = " ";} else {sp = "";}
        line = line + sp + word;
        x = x + space + w;
        wordCount++;
      }
    }
    drawString(g, line, wordCount, fm.stringWidth(line), y+bl);
  }

  public void drawString(Graphics g, String line,
                         int wc, int lineW, int y) {
    switch(align) {
      case LEFT: g.drawString(line, 0, y);
        break;
      case RIGHT: g.drawString(line, d.width-lineW ,y);
        break;
      case CENTER: g.drawString(line, (d.width-lineW)/2, y);
        break;
      case LEFTRIGHT:
        if(lineW < (int)(d.width*.75)) {
          g.drawString(line, 0, y);
        }
        else {
          int toFill = (int)((d.width - lineW)/wc);
          int nudge = d.width - lineW - (toFill*wc);
          int s = fm.stringWidth(" ");
          StringTokenizer st = new StringTokenizer(line);
          int x = 0;
          while(st.hasMoreTokens()) {
            String word = st.nextToken();
            g.drawString(word, x, y);
            if(nudge>0) {
              x = x + fm.stringWidth(word) + space + toFill + 1;
              nudge--;
            } else {
              x = x + fm.stringWidth(word) + space + toFill;
            }
          }
        }
        break;
      }

  }

}

class MyMouseAdapter extends MouseAdapter {
  TextLayout tl;
  public MyMouseAdapter(TextLayout tl) {
    this.tl = tl;
  }
  public void mouseClicked(MouseEvent me) {
    tl.align = (tl.align + 1) % 4;
    tl.repaint();
  }
}

 
 
/**************** 
 * Chapter  22  *
 ****************/

listing 1
// Demonstrate Labels
import java.awt.*;
import java.applet.*;
/*
<applet code="LabelDemo" width=300 height=200>
</applet>
*/

public class LabelDemo extends Applet {
  public void init() {
    Label one = new Label("One");
    Label two = new Label("Two");
    Label three = new Label("Three");

    // add labels to applet window
    add(one);
    add(two);
    add(three);
  }
}

listing 2
// Demonstrate Buttons 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="ButtonDemo" width=250 height=150>
  </applet>
*/

public class ButtonDemo extends Applet implements ActionListener {
  String msg = "";
  Button yes, no, maybe;

  public void init() {
    yes = new Button("Yes");
    no = new Button("No");
    maybe = new Button("Undecided");

    add(yes);
    add(no);
    add(maybe);

    yes.addActionListener(this);
    no.addActionListener(this);
    maybe.addActionListener(this);
  }

  public void actionPerformed(ActionEvent ae) {
    String str = ae.getActionCommand();
    if(str.equals("Yes")) {
      msg = "You pressed Yes.";
    }
    else if(str.equals("No")) {
      msg = "You pressed No.";
    }
    else {
      msg = "You pressed Undecided.";
    }
    repaint();
  }

  public void paint(Graphics g) {
     g.drawString(msg, 6, 100);
  }
}

listing 3
// Recognize Button objects. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="ButtonList" width=250 height=150>
  </applet>
*/

public class ButtonList extends Applet implements ActionListener {
  String msg = "";
  Button bList[] = new Button[3];

  public void init() {
    Button yes = new Button("Yes");
    Button no = new Button("No");
    Button maybe = new Button("Undecided");

    // store references to buttons as added
    bList[0] = (Button) add(yes);
    bList[1] = (Button) add(no);
    bList[2] = (Button) add(maybe);

    // register to receive action events
    for(int i = 0; i < 3; i++) {
      bList[i].addActionListener(this);
    }
  }

  public void actionPerformed(ActionEvent ae) {
    for(int i = 0; i < 3; i++) {
      if(ae.getSource() == bList[i]) {
        msg = "You pressed " + bList[i].getLabel();
      }
    }
    repaint();
  }

  public void paint(Graphics g) {
     g.drawString(msg, 6, 100);
  }
}

listing 4
// Demonstrate check boxes. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="CheckboxDemo" width=250 height=200>
  </applet>
*/

public class CheckboxDemo extends Applet implements ItemListener {
  String msg = "";
  Checkbox Win98, winNT, solaris, mac;

  public void init() {
    Win98 = new Checkbox("Windows 98/XP", null, true);
    winNT = new Checkbox("Windows NT/2000");
    solaris = new Checkbox("Solaris");
    mac = new Checkbox("MacOS");

    add(Win98);
    add(winNT);
    add(solaris);
    add(mac);

    Win98.addItemListener(this);
    winNT.addItemListener(this);
    solaris.addItemListener(this);
    mac.addItemListener(this);
  }

  public void itemStateChanged(ItemEvent ie) {
    repaint();
  }

  // Display current state of the check boxes.
  public void paint(Graphics g) {
    msg = "Current state: ";
    g.drawString(msg, 6, 80);
    msg = "  Windows 98/XP: " + Win98.getState();
    g.drawString(msg, 6, 100);
    msg = "  Windows NT/2000: " + winNT.getState();
    g.drawString(msg, 6, 120);
    msg = "  Solaris: " + solaris.getState();
    g.drawString(msg, 6, 140);
    msg = "  MacOS: " + mac.getState();
    g.drawString(msg, 6, 160);
  }
}

listing 5
// Demonstrate check box group. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="CBGroup" width=250 height=200>
  </applet>
*/

public class CBGroup extends Applet implements ItemListener {
  String msg = "";
  Checkbox Win98, winNT, solaris, mac;
  CheckboxGroup cbg;

  public void init() {
    cbg = new CheckboxGroup();
    Win98 = new Checkbox("Windows 98/XP", cbg, true);
    winNT = new Checkbox("Windows NT/2000", cbg, false);
    solaris = new Checkbox("Solaris", cbg, false);
    mac = new Checkbox("MacOS", cbg, false);

    add(Win98);
    add(winNT);
    add(solaris);
    add(mac);

    Win98.addItemListener(this);
    winNT.addItemListener(this);
    solaris.addItemListener(this);
    mac.addItemListener(this);
  }

  public void itemStateChanged(ItemEvent ie) {
    repaint();
  }

  // Display current state of the check boxes.
  public void paint(Graphics g) {
    msg = "Current selection: ";
    msg += cbg.getSelectedCheckbox().getLabel();
    g.drawString(msg, 6, 100);
  }
}

listing 6
// Demonstrate Choice lists. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="ChoiceDemo" width=300 height=180>
  </applet>
*/

public class ChoiceDemo extends Applet implements ItemListener {
  Choice os, browser;
  String msg = "";

  public void init() {
    os = new Choice();
    browser = new Choice();

    // add items to os list
    os.add("Windows 98/XP");
    os.add("Windows NT/2000");
    os.add("Solaris");
    os.add("MacOS");

    // add items to browser list
    browser.add("Netscape 3.x");
    browser.add("Netscape 4.x");
    browser.add("Netscape 5.x");
    browser.add("Netscape 6.x");

    browser.add("Internet Explorer 4.0");
    browser.add("Internet Explorer 5.0");
    browser.add("Internet Explorer 6.0");

    browser.add("Lynx 2.4");

    browser.select("Netscape 4.x");

    // add choice lists to window
    add(os);
    add(browser);

    // register to receive item events
    os.addItemListener(this);
    browser.addItemListener(this);
  }

  public void itemStateChanged(ItemEvent ie) {
    repaint();
  }

  // Display current selections.
  public void paint(Graphics g) {
    msg = "Current OS: ";
    msg += os.getSelectedItem();
    g.drawString(msg, 6, 120);
    msg = "Current Browser: ";
    msg += browser.getSelectedItem();
    g.drawString(msg, 6, 140);
  }
}

listing 7
// Demonstrate Lists. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="ListDemo" width=300 height=180>
  </applet>
*/

public class ListDemo extends Applet implements ActionListener {
  List os, browser;
  String msg = "";

  public void init() {
    os = new List(4, true);
    browser = new List(4, false);

    // add items to os list
    os.add("Windows 98/XP");
    os.add("Windows NT/2000");
    os.add("Solaris");
    os.add("MacOS");

    // add items to browser list
    browser.add("Netscape 3.x");
    browser.add("Netscape 4.x");
    browser.add("Netscape 5.x");
    browser.add("Netscape 6.x");

    browser.add("Internet Explorer 4.0");
    browser.add("Internet Explorer 5.0");
    browser.add("Internet Explorer 6.0");

    browser.add("Lynx 2.4");

    browser.select(1);

    // add lists to window
    add(os);
    add(browser);

    // register to receive action events
    os.addActionListener(this);
    browser.addActionListener(this);
  }

  public void actionPerformed(ActionEvent ae) {
    repaint();
  }

  // Display current selections.
  public void paint(Graphics g) {
    int idx[];

    msg = "Current OS: ";
    idx = os.getSelectedIndexes();
    for(int i=0; i<idx.length; i++)
      msg += os.getItem(idx[i]) + "  ";
    g.drawString(msg, 6, 120);
    msg = "Current Browser: ";
    msg += browser.getSelectedItem();
    g.drawString(msg, 6, 140);
  }
}

listing 8
// Demonstrate scroll bars. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="SBDemo" width=300 height=200>
  </applet>
*/

public class SBDemo extends Applet
  implements AdjustmentListener, MouseMotionListener {
  String msg = "";
  Scrollbar vertSB, horzSB;

  public void init() {
    int width = Integer.parseInt(getParameter("width"));
    int height = Integer.parseInt(getParameter("height"));

    vertSB = new Scrollbar(Scrollbar.VERTICAL,
                           0, 1, 0, height);
    horzSB = new Scrollbar(Scrollbar.HORIZONTAL,
                           0, 1, 0, width);

    add(vertSB);
    add(horzSB);

    // register to receive adjustment events
    vertSB.addAdjustmentListener(this);
    horzSB.addAdjustmentListener(this);

    addMouseMotionListener(this);
  }

  public void adjustmentValueChanged(AdjustmentEvent ae) {
    repaint();
  }

  // Update scroll bars to reflect mouse dragging.
  public void mouseDragged(MouseEvent me) {
    int x = me.getX();
    int y = me.getY();
    vertSB.setValue(y);
    horzSB.setValue(x);
    repaint();
  }

  // Necessary for MouseMotionListener
  public void mouseMoved(MouseEvent me) {
  }

  // Display current value of scroll bars.
  public void paint(Graphics g) {
     msg = "Vertical: " + vertSB.getValue();
     msg += ",  Horizontal: " + horzSB.getValue();
     g.drawString(msg, 6, 160);

     // show current mouse drag position
     g.drawString("*", horzSB.getValue(),
                  vertSB.getValue());
  }
}

listing 9
// Demonstrate text field. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="TextFieldDemo" width=380 height=150>
  </applet>
*/

public class TextFieldDemo extends Applet
  implements ActionListener {

  TextField name, pass;

  public void init() {
    Label namep = new Label("Name: ", Label.RIGHT);
    Label passp = new Label("Password: ", Label.RIGHT);
    name = new TextField(12);
    pass = new TextField(8);
    pass.setEchoChar('?');

    add(namep);
    add(name);
    add(passp);
    add(pass);

    // register to receive action events
    name.addActionListener(this);
    pass.addActionListener(this);
  }

  // User pressed Enter.
  public void actionPerformed(ActionEvent ae) {
    repaint();
  }

  public void paint(Graphics g) {
     g.drawString("Name: " + name.getText(), 6, 60);
     g.drawString("Selected text in name: "
                  + name.getSelectedText(), 6, 80);
     g.drawString("Password: " + pass.getText(), 6, 100);
  }
}

listing 10
// Demonstrate TextArea.
import java.awt.*;
import java.applet.*;
/*
<applet code="TextAreaDemo" width=300 height=250>
</applet>
*/

public class TextAreaDemo extends Applet {
  public void init() {
    String val = "There are two ways of constructing " +
      "a software design.\n" +
      "One way is to make it so simple\n" +
      "that there are obviously no deficiencies.\n" +
      "And the other way is to make it so complicated\n" +
      "that there are no obvious deficiencies.\n\n" +
      "        -C.A.R. Hoare\n\n" +
      "There's an old story about the person who wished\n" +
      "his computer were as easy to use as his telephone.\n" +
      "That wish has come true,\n" +
      "since I no longer know how to use my telephone.\n\n" +
      "        -Bjarne Stroustrup, AT&T, (inventor of C++)";

    TextArea text = new TextArea(val, 10, 30);
    add(text);
  }
}

listing 11
// Use left-aligned flow layout. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="FlowLayoutDemo" width=250 height=200>
  </applet>
*/

public class FlowLayoutDemo extends Applet
  implements ItemListener {

  String msg = "";
  Checkbox Win98, winNT, solaris, mac;

  public void init() {
    // set left-aligned flow layout
    setLayout(new FlowLayout(FlowLayout.LEFT));

    Win98 = new Checkbox("Windows 98/XP", null, true);
    winNT = new Checkbox("Windows NT/2000");
    solaris = new Checkbox("Solaris");
    mac = new Checkbox("MacOS");

    add(Win98);
    add(winNT);
    add(solaris);
    add(mac);

    // register to receive item events
    Win98.addItemListener(this);
    winNT.addItemListener(this);
    solaris.addItemListener(this);
    mac.addItemListener(this);
  }

  // Repaint when status of a check box changes.
  public void itemStateChanged(ItemEvent ie) {
    repaint();
  }

  // Display current state of the checkboxes.
  public void paint(Graphics g) {
    msg = "Current state: ";
    g.drawString(msg, 6, 80);
    msg = "  Windows 98/XP: " + Win98.getState();
    g.drawString(msg, 6, 100);
    msg = "  Windows NT/2000: " + winNT.getState();
    g.drawString(msg, 6, 120);
    msg = "  Solaris: " + solaris.getState();
    g.drawString(msg, 6, 140);
    msg = "  Mac: " + mac.getState();
    g.drawString(msg, 6, 160);
  }
}

listing 12
// Demonstrate BorderLayout.
import java.awt.*;
import java.applet.*;
import java.util.*;
/*
<applet code="BorderLayoutDemo" width=400 height=200>
</applet>
*/

public class BorderLayoutDemo extends Applet {
  public void init() {
    setLayout(new BorderLayout());

    add(new Button("This is across the top."),
        BorderLayout.NORTH);
    add(new Label("The footer message might go here."),
        BorderLayout.SOUTH);
    add(new Button("Right"), BorderLayout.EAST);
    add(new Button("Left"), BorderLayout.WEST);

    String msg = "The reasonable man adapts " +
      "himself to the world;\n" +
      "the unreasonable one persists in " +
      "trying to adapt the world to himself.\n" +
      "Therefore all progress depends " +
      "on the unreasonable man.\n\n" +
      "        - George Bernard Shaw\n\n";

    add(new TextArea(msg), BorderLayout.CENTER);
  }
}


listing 13
// Demonstrate BorderLayout with insets. 
import java.awt.*;
import java.applet.*;
import java.util.*;
/*
<applet code="InsetsDemo" width=400 height=200>
</applet>
*/

public class InsetsDemo extends Applet {
  public void init() {
    // set background color so insets can be easily seen
    setBackground(Color.cyan);

    setLayout(new BorderLayout());

    add(new Button("This is across the top."),
        BorderLayout.NORTH);
    add(new Label("The footer message might go here."),
        BorderLayout.SOUTH);
    add(new Button("Right"), BorderLayout.EAST);
    add(new Button("Left"), BorderLayout.WEST);

    String msg = "The reasonable man adapts " +
      "himself to the world;\n" +
      "the unreasonable one persists in " +
      "trying to adapt the world to himself.\n" +
      "Therefore all progress depends " +
      "on the unreasonable man.\n\n" +
      "        - George Bernard Shaw\n\n";

    add(new TextArea(msg), BorderLayout.CENTER);
  }

  // add insets
  public Insets getInsets() {
    return new Insets(10, 10, 10, 10);
  }
}

listing 14
// Demonstrate GridLayout
import java.awt.*;
import java.applet.*;
/*
<applet code="GridLayoutDemo" width=300 height=200>
</applet>
*/

public class GridLayoutDemo extends Applet {
  static final int n = 4;
  public void init() {
    setLayout(new GridLayout(n, n));

    setFont(new Font("SansSerif", Font.BOLD, 24));

    for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
        int k = i * n + j;
        if(k > 0)
          add(new Button("" + k));
      }
    }
  }
}

listing 15
// Demonstrate CardLayout. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="CardLayoutDemo" width=300 height=100>
  </applet>
*/

public class CardLayoutDemo extends Applet
  implements ActionListener, MouseListener {

  Checkbox Win98, winNT, solaris, mac;
  Panel osCards;
  CardLayout cardLO;
  Button Win, Other;

  public void init() {
    Win = new Button("Windows");
    Other = new Button("Other");
    add(Win);
    add(Other);

    cardLO = new CardLayout();
    osCards = new Panel();
    osCards.setLayout(cardLO); // set panel layout to card layout

    Win98 = new Checkbox("Windows 98/XP", null, true);
    winNT = new Checkbox("Windows NT/2000");
    solaris = new Checkbox("Solaris");
    mac = new Checkbox("MacOS");

    // add Windows check boxes to a panel
    Panel winPan = new Panel();
    winPan.add(Win98);
    winPan.add(winNT);

    // Add other OS check boxes to a panel
    Panel otherPan = new Panel();
    otherPan.add(solaris);
    otherPan.add(mac);

    // add panels to card deck panel
    osCards.add(winPan, "Windows");
    osCards.add(otherPan, "Other");

    // add cards to main applet panel
    add(osCards);

    // register to receive action events
    Win.addActionListener(this);
    Other.addActionListener(this);

    // register mouse events
    addMouseListener(this);
  }

  // Cycle through panels.
  public void mousePressed(MouseEvent me) {
    cardLO.next(osCards);
  }

  // Provide empty implementations for the other MouseListener methods.
  public void mouseClicked(MouseEvent me) {
  }
  public void mouseEntered(MouseEvent me) {
  }
  public void mouseExited(MouseEvent me) {
  }
  public void mouseReleased(MouseEvent me) {
  }

  public void actionPerformed(ActionEvent ae) {
    if(ae.getSource() == Win) {
      cardLO.show(osCards, "Windows");
    }
    else {
      cardLO.show(osCards, "Other");
    }
  }
}


listing 16
// Illustrate menus. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="MenuDemo" width=250 height=250>
  </applet>
*/

// Create a subclass of Frame
class MenuFrame extends Frame {
  String msg = "";
  CheckboxMenuItem debug, test;

  MenuFrame(String title) {
    super(title);

    // create menu bar and add it to frame
    MenuBar mbar = new MenuBar();
    setMenuBar(mbar);

    // create the menu items
    Menu file = new Menu("File");
    MenuItem item1, item2, item3, item4, item5;
    file.add(item1 = new MenuItem("New..."));
    file.add(item2 = new MenuItem("Open..."));
    file.add(item3 = new MenuItem("Close"));
    file.add(item4 = new MenuItem("-"));
    file.add(item5 = new MenuItem("Quit..."));
    mbar.add(file);

    Menu edit = new Menu("Edit");
    MenuItem item6, item7, item8, item9;
    edit.add(item6 = new MenuItem("Cut"));
    edit.add(item7 = new MenuItem("Copy"));
    edit.add(item8 = new MenuItem("Paste"));
    edit.add(item9 = new MenuItem("-"));
    Menu sub = new Menu("Special");
    MenuItem item10, item11, item12;
    sub.add(item10 = new MenuItem("First"));
    sub.add(item11 = new MenuItem("Second"));
    sub.add(item12 = new MenuItem("Third"));
    edit.add(sub);

    // these are checkable menu items
    debug = new CheckboxMenuItem("Debug");
    edit.add(debug);
    test = new CheckboxMenuItem("Testing");
    edit.add(test);

    mbar.add(edit);

    // create an object to handle action and item events
    MyMenuHandler handler = new MyMenuHandler(this);
    // register it to receive those events
    item1.addActionListener(handler);
    item2.addActionListener(handler);
    item3.addActionListener(handler);
    item4.addActionListener(handler);
    item5.addActionListener(handler);
    item6.addActionListener(handler);
    item7.addActionListener(handler);
    item8.addActionListener(handler);
    item9.addActionListener(handler);
    item10.addActionListener(handler);
    item11.addActionListener(handler);
    item12.addActionListener(handler);
    debug.addItemListener(handler);
    test.addItemListener(handler);

    // create an object to handle window events
    MyWindowAdapter adapter = new MyWindowAdapter(this);
     // register it to receive those events
    addWindowListener(adapter);
  }

  public void paint(Graphics g) {
    g.drawString(msg, 10, 200);

    if(debug.getState())
      g.drawString("Debug is on.", 10, 220);
    else
      g.drawString("Debug is off.", 10, 220);

    if(test.getState())
      g.drawString("Testing is on.", 10, 240);
    else
      g.drawString("Testing is off.", 10, 240);
  }
}

class MyWindowAdapter extends WindowAdapter {
  MenuFrame menuFrame;
  public MyWindowAdapter(MenuFrame menuFrame) {
    this.menuFrame = menuFrame;
  }
  public void windowClosing(WindowEvent we) {
    menuFrame.setVisible(false);
  }
}

class MyMenuHandler implements ActionListener, ItemListener {
  MenuFrame menuFrame;
  public MyMenuHandler(MenuFrame menuFrame) {
    this.menuFrame = menuFrame;
  }
  // Handle action events
  public void actionPerformed(ActionEvent ae) {
      String msg = "You selected ";
      String arg = (String)ae.getActionCommand();
      if(arg.equals("New..."))
        msg += "New.";
      else if(arg.equals("Open..."))
        msg += "Open.";
      else if(arg.equals("Close"))
        msg += "Close.";
      else if(arg.equals("Quit..."))
        msg += "Quit.";
      else if(arg.equals("Edit"))
        msg += "Edit.";
      else if(arg.equals("Cut"))
        msg += "Cut.";
      else if(arg.equals("Copy"))
        msg += "Copy.";
      else if(arg.equals("Paste"))
        msg += "Paste.";
      else if(arg.equals("First"))
        msg += "First.";
      else if(arg.equals("Second"))
        msg += "Second.";
      else if(arg.equals("Third"))
        msg += "Third.";
      else if(arg.equals("Debug"))
        msg += "Debug.";
      else if(arg.equals("Testing"))
        msg += "Testing.";
      menuFrame.msg = msg;
      menuFrame.repaint();
  }
  // Handle item events
  public void itemStateChanged(ItemEvent ie) {
    menuFrame.repaint();
  }
}

// Create frame window.
public class MenuDemo extends Applet {
  Frame f;

  public void init() {
    f = new MenuFrame("Menu Demo");
    int width = Integer.parseInt(getParameter("width"));
    int height = Integer.parseInt(getParameter("height"));

    setSize(new Dimension(width, height));

    f.setSize(width, height);
    f.setVisible(true);
  }

  public void start() {
    f.setVisible(true);
  }

  public void stop() {
    f.setVisible(false);
  }
}

listing 17
// Demonstrate Dialog box. 
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
/*
  <applet code="DialogDemo" width=250 height=250>
  </applet>
*/

// Create a subclass of Dialog.
class SampleDialog extends Dialog implements ActionListener {
  SampleDialog(Frame parent, String title) {
    super(parent, title, false);
    setLayout(new FlowLayout());
    setSize(300, 200);

    add(new Label("Press this button:"));
    Button b;
    add(b = new Button("Cancel"));
    b.addActionListener(this);
  }

  public void actionPerformed(ActionEvent ae) {
     dispose();
  }

  public void paint(Graphics g) {
    g.drawString("This is in the dialog box", 10, 70);
  }
}

// Create a subclass of Frame.
class MenuFrame extends Frame {
  String msg = "";
  CheckboxMenuItem debug, test;

  MenuFrame(String title) {
    super(title);

    // create menu bar and add it to frame
    MenuBar mbar = new MenuBar();
    setMenuBar(mbar);

    // create the menu items
    Menu file = new Menu("File");
    MenuItem item1, item2, item3, item4;
    file.add(item1 = new MenuItem("New..."));
    file.add(item2 = new MenuItem("Open..."));
    file.add(item3 = new MenuItem("Close"));
    file.add(new MenuItem("-"));
    file.add(item4 = new MenuItem("Quit..."));
    mbar.add(file);

    Menu edit = new Menu("Edit");
    MenuItem item5, item6, item7;
    edit.add(item5 = new MenuItem("Cut"));
    edit.add(item6 = new MenuItem("Copy"));
    edit.add(item7 = new MenuItem("Paste"));
    edit.add(new MenuItem("-"));

    Menu sub = new Menu("Special", true);
    MenuItem item8, item9, item10;
    sub.add(item8 = new MenuItem("First"));
    sub.add(item9 = new MenuItem("Second"));
    sub.add(item10 = new MenuItem("Third"));
    edit.add(sub);

    // these are checkable menu items
    debug = new CheckboxMenuItem("Debug");
    edit.add(debug);
    test = new CheckboxMenuItem("Testing");
    edit.add(test);

    mbar.add(edit);

    // create an object to handle action and item events
    MyMenuHandler handler = new MyMenuHandler(this);

    // register it to receive those events
    item1.addActionListener(handler);
    item2.addActionListener(handler);
    item3.addActionListener(handler);
    item4.addActionListener(handler);
    item5.addActionListener(handler);
    item6.addActionListener(handler);
    item7.addActionListener(handler);
    item8.addActionListener(handler);
    item9.addActionListener(handler);
    item10.addActionListener(handler);
    debug.addItemListener(handler);
    test.addItemListener(handler);

    // create an object to handle window events
    MyWindowAdapter adapter = new MyWindowAdapter(this);
     // register it to receive those events
    addWindowListener(adapter);
  }
  public void paint(Graphics g) {
    g.drawString(msg, 10, 200);

    if(debug.getState())
      g.drawString("Debug is on.", 10, 220);
    else
      g.drawString("Debug is off.", 10, 220);

    if(test.getState())
      g.drawString("Testing is on.", 10, 240);
    else
      g.drawString("Testing is off.", 10, 240);
  }
}

class MyWindowAdapter extends WindowAdapter {
  MenuFrame menuFrame;
  public MyWindowAdapter(MenuFrame menuFrame) {
    this.menuFrame = menuFrame;
  }
  public void windowClosing(WindowEvent we) {
    menuFrame.dispose();
  }
}

class MyMenuHandler implements ActionListener, ItemListener {
  MenuFrame menuFrame;
  public MyMenuHandler(MenuFrame menuFrame) {
    this.menuFrame = menuFrame;
  }
  // Handle action events
  public void actionPerformed(ActionEvent ae) {
      String msg = "You selected ";
      String arg = (String)ae.getActionCommand();
     // Activate a dialog box when New is selected.
     if(arg.equals("New...")) {
        msg += "New.";
        SampleDialog d = new
          SampleDialog(menuFrame, "New Dialog Box");
        d.setVisible(true);
      }
      // Try defining other dialog boxes for these options.
      else if(arg.equals("Open..."))
        msg += "Open.";
      else if(arg.equals("Close"))
        msg += "Close.";
      else if(arg.equals("Quit..."))
        msg += "Quit.";
      else if(arg.equals("Edit"))
        msg += "Edit.";
      else if(arg.equals("Cut"))
        msg += "Cut.";
      else if(arg.equals("Copy"))
        msg += "Copy.";
      else if(arg.equals("Paste"))
        msg += "Paste.";
      else if(arg.equals("First"))
        msg += "First.";
      else if(arg.equals("Second"))
        msg += "Second.";
      else if(arg.equals("Third"))
        msg += "Third.";
      else if(arg.equals("Debug"))
        msg += "Debug.";
      else if(arg.equals("Testing"))
        msg += "Testing.";
      menuFrame.msg = msg;
      menuFrame.repaint();
  }
  public void itemStateChanged(ItemEvent ie) {
      menuFrame.repaint();
  }
}

// Create frame window.
public class DialogDemo extends Applet {
  Frame f;

  public void init() {
    f = new MenuFrame("Menu Demo");
    int width = Integer.parseInt(getParameter("width"));
    int height = Integer.parseInt(getParameter("height"));

    setSize(width, height);

    f.setSize(width, height);
    f.setVisible(true);
  }

  public void start() {
    f.setVisible(true);
  }

  public void stop() {
    f.setVisible(false);
  }
}

listing 18
/* Demonstrate File Dialog box. 

   This is an application, not an applet.
*/
import java.awt.*;
import java.awt.event.*;

// Create a subclass of Frame
class SampleFrame extends Frame {
  SampleFrame(String title) {
    super(title);
    // create an object to handle window events
    MyWindowAdapter adapter = new MyWindowAdapter(this);
    // register it to receive those events
    addWindowListener(adapter);
  }
}

class MyWindowAdapter extends WindowAdapter {
  SampleFrame sampleFrame;
  public MyWindowAdapter(SampleFrame sampleFrame) {
    this.sampleFrame = sampleFrame;
  }
  public void windowClosing(WindowEvent we) {
    sampleFrame.setVisible(false);
  }
}

// Create frame window.
class FileDialogDemo {
  public static void main(String args[]) {
    Frame f = new SampleFrame("File Dialog Demo");
    f.setVisible(true);
    f.setSize(100, 100);

    FileDialog fd = new FileDialog(f, "File Dialog");
    fd.setVisible(true);
  }
}

listing 19
/*
* <applet code=ButtonDemo2 width=200 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class ButtonDemo2 extends Applet {
  MyButton myButton;
  static int i = 0;
  public void init() {
    myButton = new MyButton("Test Button");
    add(myButton);
  }
  class MyButton extends Button {
    public MyButton(String label) {
      super(label);
      enableEvents(AWTEvent.ACTION_EVENT_MASK);
    }
    protected void processActionEvent(ActionEvent ae) {
      showStatus("action event: " + i++);
      super.processActionEvent(ae);
    }
  }
}

listing 20
/*
* <applet code=CheckboxDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class CheckboxDemo2 extends Applet {
  MyCheckbox myCheckbox1, myCheckbox2, myCheckbox3;
  public void init() {
    myCheckbox1 = new MyCheckbox("Item 1");
    add(myCheckbox1);
    myCheckbox2 = new MyCheckbox("Item 2");
    add(myCheckbox2);
    myCheckbox3 = new MyCheckbox("Item 3");
    add(myCheckbox3);
  }
  class MyCheckbox extends Checkbox {
    public MyCheckbox(String label) {
      super(label);
      enableEvents(AWTEvent.ITEM_EVENT_MASK);
    }
    protected void processItemEvent(ItemEvent ie) {
      showStatus("Checkbox name/state: " + getLabel() +
                 "/" + getState());
      super.processItemEvent(ie);
    }
  }
}

listing 21
/*
* <applet code=CheckboxGroupDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class CheckboxGroupDemo2 extends Applet {
  CheckboxGroup cbg;
  MyCheckbox myCheckbox1, myCheckbox2, myCheckbox3;
  public void init() {
    cbg = new CheckboxGroup();
    myCheckbox1 = new MyCheckbox("Item 1", cbg, true);
    add(myCheckbox1);
    myCheckbox2 = new MyCheckbox("Item 2", cbg, false);
    add(myCheckbox2);
    myCheckbox3 = new MyCheckbox("Item 3", cbg, false);
    add(myCheckbox3);
  }
  class MyCheckbox extends Checkbox {
    public MyCheckbox(String label, CheckboxGroup cbg,
                      boolean flag) {
      super(label, cbg, flag);
      enableEvents(AWTEvent.ITEM_EVENT_MASK);
    }
    protected void processItemEvent(ItemEvent ie) {
      showStatus("Checkbox name/state: " + getLabel() +
                 "/" + getState());
      super.processItemEvent(ie);
    }
  }
}

listing 22
/*
* <applet code=ChoiceDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class ChoiceDemo2 extends Applet {
  MyChoice choice;
  public void init() {
    choice = new MyChoice();
    choice.add("Red");
    choice.add("Green");
    choice.add("Blue");
    add(choice);
  }
  class MyChoice extends Choice {
    public MyChoice() {
      enableEvents(AWTEvent.ITEM_EVENT_MASK);
    }
    protected void processItemEvent(ItemEvent ie) {
      showStatus("Choice selection: " + getSelectedItem());
      super.processItemEvent(ie);
    }
  }
}

listing 23
/*
* <applet code=ListDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class ListDemo2 extends Applet {
  MyList list;
  public void init() {
    list = new MyList();
    list.add("Red");
    list.add("Green");
    list.add("Blue");
    add(list);
  }
  class MyList extends List {
    public MyList() {
      enableEvents(AWTEvent.ITEM_EVENT_MASK |
                   AWTEvent.ACTION_EVENT_MASK);
    }
    protected void processActionEvent(ActionEvent ae) {
      showStatus("Action event: " + ae.getActionCommand());
      super.processActionEvent(ae);
    }
    protected void processItemEvent(ItemEvent ie) {
      showStatus("Item event: " + getSelectedItem());
      super.processItemEvent(ie);
    }
  }
}

listing 24
/*
* <applet code=ScrollbarDemo2 width=300 height=100>
* </applet>
*/
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class ScrollbarDemo2 extends Applet {
  MyScrollbar myScrollbar;
  public void init() {
    myScrollbar = new MyScrollbar(Scrollbar.HORIZONTAL,
                                  0, 1, 0, 100);
    add(myScrollbar);
  }
  class MyScrollbar extends Scrollbar {
    public MyScrollbar(int style, int initial, int thumb,
                       int min, int max) {
      super(style, initial, thumb, min, max);
      enableEvents(AWTEvent.ADJUSTMENT_EVENT_MASK);
    }
    protected void processAdjustmentEvent(AdjustmentEvent ae) {
      showStatus("Adjustment event: " + ae.getValue());
      setValue(getValue());
      super.processAdjustmentEvent(ae);
    }
  }
}

 
 
/**************** 
 * Chapter  23  *
 ****************/

listing 1
/*
 * <applet code="SimpleImageLoad" width=248 height=146>
 *  <param name="img" value="seattle.jpg">
 * </applet>
 */
import java.awt.*;
import java.applet.*;

public class SimpleImageLoad extends Applet
{
  Image img;

  public void init() {
    img = getImage(getDocumentBase(), getParameter("img"));
  }

  public void paint(Graphics g) {
    g.drawImage(img, 0, 0, this);
  }
}

listing 2
public boolean imageUpdate(Image img, int flags,
                           int x, int y, int w, int h) {
  if ((flags & ALLBITS) == 0) {
    System.out.println("Still processing the image.");
    return true;
  } else {
    System.out.println("Done processing the image.");
    return false;
  }
}

listing 3
/*
 * <applet code="ObservedImageLoad" width=248 height=146>
 *  <param name="img" value="seattle.jpg">
 * </applet>
 */
import java.awt.*;
import java.applet.*;

public class ObservedImageLoad extends Applet {
  Image img;
  boolean error = false;
  String imgname;

  public void init() {
    setBackground(Color.blue);
    imgname = getParameter("img");
    img = getImage(getDocumentBase(), imgname);
  }

  public void paint(Graphics g) {
    if (error) {
      Dimension d = getSize();
      g.setColor(Color.red);
      g.fillRect(0, 0, d.width, d.height);
      g.setColor(Color.black);
      g.drawString("Image not found: " + imgname, 10, d.height/2);
    } else {
      g.drawImage(img, 0, 0, this);
    }
  }

  public void update(Graphics g) {
    paint(g);
  }

  public boolean imageUpdate(Image img, int flags,
                             int x, int y, int w, int h) {
    if ((flags & SOMEBITS) != 0) {  // new partial data
      repaint(x, y, w, h);          // paint new pixels
    } else if ((flags & ABORT) != 0) {
      error = true;                 // file not found
      repaint();                    // paint whole applet
    } 
    return (flags & (ALLBITS|ABORT)) == 0;
  }
}

listing 4
public boolean imageUpdate(Image img, int flags,
                           int x, int y, int w, int h) {
  if ((flags & ALLBITS) != 0) {
    repaint();
  } else if ((flags & (ABORT|ERROR)) != 0) {
    error = true; // file not found
    repaint();
  } 
  return (flags & (ALLBITS|ABORT|ERROR)) == 0;
}

listing 5
/*
 * <applet code=DoubleBuffer width=250 height=250>
 * </applet>
 */
import java.awt.*;
import java.awt.event.*;
import java.applet.*;

public class DoubleBuffer extends Applet {
  int gap = 3;
  int mx, my;
  boolean flicker = true;
  Image buffer = null;
  int w, h;

  public void init() {
    Dimension d = getSize();
    w = d.width;
    h = d.height;
    buffer = createImage(w, h);
    addMouseMotionListener(new MouseMotionAdapter() {
      public void mouseDragged(MouseEvent me) {
        mx = me.getX();
        my = me.getY();
        flicker = false;
        repaint();
      }
      public void mouseMoved(MouseEvent me) {
        mx = me.getX();
        my = me.getY();
        flicker = true;
        repaint();
      }
    }); 
  }

  public void paint(Graphics g) {
    Graphics screengc = null;

    if (!flicker) {
      screengc = g;
      g = buffer.getGraphics();
    }

    g.setColor(Color.blue);
    g.fillRect(0, 0, w, h);
    
    g.setColor(Color.red);
    for (int i=0; i<w; i+=gap)
      g.drawLine(i, 0, w-i, h);
    for (int i=0; i<h; i+=gap)
      g.drawLine(0, i, w, h-i);
    
    g.setColor(Color.black);
    g.drawString("Press mouse button to double buffer", 10, h/2);

    g.setColor(Color.yellow);
    g.fillOval(mx - gap, my - gap, gap*2+1, gap*2+1);

    if (!flicker) {
      screengc.drawImage(buffer, 0, 0, null);
    }
  }
  public void update(Graphics g) {
    paint(g);
  }
}

listing 6
/*
 * <applet code="TrackedImageLoad" width=300 height=400>
 * <param name="img"
 * value="vincent+leonardo+matisse+picasso+renoir+seurat+vermeer">
 * </applet>
 */
import java.util.*;
import java.applet.*;
import java.awt.*;

public class TrackedImageLoad extends Applet implements Runnable {
  MediaTracker tracker;
  int tracked;
  int frame_rate = 5;
  int current_img = 0;
  Thread motor;
  static final int MAXIMAGES = 10;
  Image img[] = new Image[MAXIMAGES];
  String name[] = new String[MAXIMAGES];
  boolean stopFlag;

  public void init() {
    tracker = new MediaTracker(this);
    StringTokenizer st = new StringTokenizer(getParameter("img"),
                                             "+");

    while(st.hasMoreTokens() && tracked <= MAXIMAGES) {
      name[tracked] = st.nextToken();
      img[tracked] = getImage(getDocumentBase(),
                              name[tracked] + ".jpg");
      tracker.addImage(img[tracked], tracked);
      tracked++;
    }
  }

  public void paint(Graphics g) {
    String loaded = "";
    int donecount = 0;

    for(int i=0; i<tracked; i++) {
      if (tracker.checkID(i, true)) {
        donecount++;
        loaded += name[i] + " ";
      }
    }

    Dimension d = getSize();
    int w = d.width;
    int h = d.height;

    if (donecount == tracked) {
      frame_rate = 1;
      Image i = img[current_img++];
      int iw = i.getWidth(null);
      int ih = i.getHeight(null);
      g.drawImage(i, (w - iw)/2, (h - ih)/2, null);
      if (current_img >= tracked)
        current_img = 0;
    } else {
      int x = w * donecount / tracked;
      g.setColor(Color.black);
      g.fillRect(0, h/3, x, 16);
      g.setColor(Color.white);
      g.fillRect(x, h/3, w-x, 16);
      g.setColor(Color.black);
      g.drawString(loaded, 10, h/2);
    }
  }

  public void start() {
    motor = new Thread(this);
    stopFlag = false;
    motor.start();
  }

  public void stop() {
    stopFlag = true;
  }

  public void run() {
    motor.setPriority(Thread.MIN_PRIORITY);
    while (true) {
      repaint();
      try {
        Thread.sleep(1000/frame_rate);
      } catch (InterruptedException e) { };
      if(stopFlag)
        return;
    }
  }       
}

listing 7
/*
 * <applet code="MemoryImageGenerator" width=256 height=256>
 * </applet>
 */
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

public class MemoryImageGenerator extends Applet {
  Image img;
  public void init() {
    Dimension d = getSize();
    int w = d.width;
    int h = d.height;
    int pixels[] = new int[w * h];
    int i = 0;

    for(int y=0; y<h; y++) {
      for(int x=0; x<w; x++) {
        int r = (x^y)&0xff;
        int g = (x*2^y*2)&0xff;
        int b = (x*4^y*4)&0xff;
        pixels[i++] = (255 << 24) | (r << 16) | (g << 8) | b;
      }
    }
    img = createImage(new MemoryImageSource(w, h, pixels, 0, w));
  }
  public void paint(Graphics g) {
    g.drawImage(img, 0, 0, this);
  }
}

listing 8
/*
 * <applet code=HistoGrab.class width=341 height=400>
 * <param name=img value=vermeer.jpg>
 * </applet> */
import java.applet.*;
import java.awt.* ;
import java.awt.image.* ;

public class HistoGrab extends Applet {
  Dimension d;
  Image img;
  int iw, ih;
  int pixels[];
  int w, h;
  int hist[] = new int[256];
  int max_hist = 0;

  public void init() {
    d = getSize();
    w = d.width;
    h = d.height;

    try {
      img = getImage(getDocumentBase(), getParameter("img"));
      MediaTracker t = new MediaTracker(this);
      t.addImage(img, 0);
      t.waitForID(0);
      iw = img.getWidth(null);
      ih = img.getHeight(null);
      pixels = new int[iw * ih];
      PixelGrabber pg = new PixelGrabber(img, 0, 0, iw, ih,
                                         pixels, 0, iw);
      pg.grabPixels();
    } catch (InterruptedException e) { };

    for (int i=0; i<iw*ih; i++) {
      int p = pixels[i];
      int r = 0xff & (p >> 16);
      int g = 0xff & (p >> 8);
      int b = 0xff & (p);
      int y = (int) (.33 * r + .56 * g + .11 * b);
      hist[y]++;
    }
    for (int i=0; i<256; i++) {
      if (hist[i] > max_hist)
        max_hist = hist[i];
    }
  }

  public void update() {}

  public void paint(Graphics g) {
    g.drawImage(img, 0, 0, null);
    int x = (w - 256) / 2;
    int lasty = h - h * hist[0] / max_hist;
    for (int i=0; i<256; i++, x++) {
      int y = h - h * hist[i] / max_hist;
      g.setColor(new Color(i, i, i));
      g.fillRect(x, y, 1, h);
      g.setColor(Color.red);
      g.drawLine(x-1,lasty,x,y);
      lasty = y;
    }
  }
}

listing 9
/*
 * <applet code=TileImage.class width=288 height=399>
 * <param name=img value=picasso.jpg>
 * </applet>
 */
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

public class TileImage extends Applet {
  Image img;
  Image cell[] = new Image[4*4];
  int iw, ih;
  int tw, th;

  public void init() {
    try {
      img = getImage(getDocumentBase(), getParameter("img"));
      MediaTracker t = new MediaTracker(this);
      t.addImage(img, 0);
      t.waitForID(0);
      iw = img.getWidth(null);
      ih = img.getHeight(null);
      tw = iw / 4;
      th = ih / 4;
      CropImageFilter f;
      FilteredImageSource fis;
      t = new MediaTracker(this);
      for (int y=0; y<4; y++) {
        for (int x=0; x<4; x++) {
          f = new CropImageFilter(tw*x, th*y, tw, th);
          fis = new FilteredImageSource(img.getSource(), f);
          int i = y*4+x;
          cell[i] = createImage(fis);
          t.addImage(cell[i], i);
        }
      }
      t.waitForAll();
      for (int i=0; i<32; i++) {
        int si = (int)(Math.random() * 16);
        int di = (int)(Math.random() * 16);
        Image tmp = cell[si];
        cell[si] = cell[di];
        cell[di] = tmp;
      }
    } catch (InterruptedException e) { };
  }

  public void update(Graphics g) {
    paint(g);
  }

  public void paint(Graphics g) {
    for (int y=0; y<4; y++) {
      for (int x=0; x<4; x++) {
        g.drawImage(cell[y*4+x], x * tw, y * th, null);
      }
    }
  }
}

listing 10
/*
 * <applet code=ImageFilterDemo width=350 height=450>
 * <param name=img value=vincent.jpg>
 * <param name=filters value="Grayscale+Invert+Contrast+Blur+Sharpen">
 * </applet>
 */
import java.applet.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class ImageFilterDemo extends Applet implements ActionListener {
  Image img;
  PlugInFilter pif;
  Image fimg;
  Image curImg;
  LoadedImage lim;
  Label lab;
  Button reset;

  public void init() {
    setLayout(new BorderLayout());
    Panel p = new Panel();
    add(p, BorderLayout.SOUTH);
    reset = new Button("Reset");
    reset.addActionListener(this);
    p.add(reset);
    StringTokenizer st = new StringTokenizer(getParameter("filters"), "+");
    while(st.hasMoreTokens()) {
      Button b = new Button(st.nextToken());
      b.addActionListener(this);
      p.add(b);
    }
    
    lab = new Label("");
    add(lab, BorderLayout.NORTH);

    img = getImage(getDocumentBase(), getParameter("img"));
    lim = new LoadedImage(img);
    add(lim, BorderLayout.CENTER);
   
  }

  public void actionPerformed(ActionEvent ae) {
    String a = "";

    try {
      a = (String)ae.getActionCommand();
      if (a.equals("Reset")) {
        lim.set(img);
        lab.setText("Normal");
      }
      else {
        pif = (PlugInFilter) Class.forName(a).newInstance();
        fimg = pif.filter(this, img);
        lim.set(fimg);
        lab.setText("Filtered: " + a);
      }
      repaint();
    } catch (ClassNotFoundException e) {
      lab.setText(a + " not found");
      lim.set(img);
      repaint();
    } catch (InstantiationException e) {
      lab.setText("could't new " + a);
    } catch (IllegalAccessException e) {
      lab.setText("no access: " + a);
    }
  }
}

listing 11
interface PlugInFilter {
  java.awt.Image filter(java.applet.Applet a, java.awt.Image in);
}

listing 12
import java.awt.*;

public class LoadedImage extends Canvas {
  Image img;

  public LoadedImage(Image i) {
    set(i);
  }

  void set(Image i) {
    MediaTracker mt = new MediaTracker(this);
    mt.addImage(i, 0);
    try {
      mt.waitForAll();
    } catch (InterruptedException e) { };
    img = i;
    repaint();
  }
  
  public void paint(Graphics g) {
    if (img == null) {
      g.drawString("no image", 10, 30);
    } else {
      g.drawImage(img, 0, 0, this);
    } 
  }

  public Dimension getPreferredSize()  {
    return new Dimension(img.getWidth(this), img.getHeight(this));
  }
  
  public Dimension getMinimumSize()  {
    return getPreferredSize();
  }
}

listing 13
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

class Grayscale extends RGBImageFilter implements PlugInFilter {
  public Image filter(Applet a, Image in) {
    return a.createImage(new FilteredImageSource(in.getSource(), this));
  }

  public int filterRGB(int x, int y, int rgb) {
    int r = (rgb >> 16) & 0xff;
    int g = (rgb >> 8) & 0xff;
    int b = rgb & 0xff;
    int k = (int) (.56 * g + .33 * r + .11 * b);
    return (0xff000000 | k << 16 | k << 8 | k);
  }
}

listing 14
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

class Invert extends RGBImageFilter implements PlugInFilter {
  public Image filter(Applet a, Image in) {
    return a.createImage(new FilteredImageSource(in.getSource(), this));
  }
  public int filterRGB(int x, int y, int rgb) {
    int r = 0xff - (rgb >> 16) & 0xff;
    int g = 0xff - (rgb >> 8) & 0xff;
    int b = 0xff - rgb & 0xff;
    return (0xff000000 | r << 16 | g << 8 | b);
  }
}

listing 15
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

public class Contrast extends RGBImageFilter implements PlugInFilter {

  public Image filter(Applet a, Image in) {
    return a.createImage(new FilteredImageSource(in.getSource(), this));
  }

  private int multclamp(int in, double factor) {
    in = (int) (in * factor);
    return in > 255 ? 255 : in;
  }

  double gain = 1.2;
  private int cont(int in) {
    return (in < 128) ? (int)(in/gain) : multclamp(in, gain);
  }

  public int filterRGB(int x, int y, int rgb) {
    int r = cont((rgb >> 16) & 0xff);
    int g = cont((rgb >> 8) & 0xff);
    int b = cont(rgb & 0xff);
    return (0xff000000 | r << 16 | g << 8 | b);
  }
}

listing 16
import java.applet.*;
import java.awt.*;
import java.awt.image.*;

abstract class Convolver implements ImageConsumer, PlugInFilter {
  int width, height;
  int imgpixels[], newimgpixels[];

  abstract void convolve();  // filter goes here...
  
  public Image filter(Applet a, Image in) {
    in.getSource().startProduction(this);
    waitForImage();
    newimgpixels = new int[width*height];

    try {
      convolve();
    } catch (Exception e) {
      System.out.println("Convolver failed: " + e);
      e.printStackTrace();
    }

    return a.createImage(
      new MemoryImageSource(width, height, newimgpixels, 0, width));
  }

  synchronized void waitForImage() {
    try { wait(); } catch (Exception e) { };
  }

  public void setProperties(java.util.Hashtable dummy) { }
  public void setColorModel(ColorModel dummy) { }
  public void setHints(int dummy) { }

  public synchronized void imageComplete(int dummy) {
    notifyAll();
  }

  public void setDimensions(int x, int y) {
    width = x;
    height = y;
    imgpixels = new int[x*y];
  }

  public void setPixels(int x1, int y1, int w, int h, 
    ColorModel model, byte pixels[], int off, int scansize) {
    int pix, x, y, x2, y2, sx, sy;

    x2 = x1+w;
    y2 = y1+h;
    sy = off;
    for(y=y1; y<y2; y++) {
      sx = sy;
      for(x=x1; x<x2; x++) {
        pix = model.getRGB(pixels[sx++]);
        if((pix & 0xff000000) == 0)
            pix = 0x00ffffff;
        imgpixels[y*width+x] = pix;
      }
      sy += scansize;
    }
  }

  public void setPixels(int x1, int y1, int w, int h, 
    ColorModel model, int pixels[], int off, int scansize) {
    int pix, x, y, x2, y2, sx, sy;

    x2 = x1+w;
    y2 = y1+h;
    sy = off;
    for(y=y1; y<y2; y++) {
      sx = sy;
      for(x=x1; x<x2; x++) {
        pix = model.getRGB(pixels[sx++]);
        if((pix & 0xff000000) == 0)
            pix = 0x00ffffff;
        imgpixels[y*width+x] = pix;
      }
      sy += scansize;
    }
  }
}

listing 17
public class Blur extends Convolver {
  public void convolve() {
    for(int y=1; y<height-1; y++) {
      for(int x=1; x<width-1; x++) {
        int rs = 0;
        int gs = 0;
        int bs = 0;

        for(int k=-1; k<=1; k++) {
          for(int j=-1; j<=1; j++) {
            int rgb = imgpixels[(y+k)*width+x+j];
            int r = (rgb >> 16) & 0xff;
            int g = (rgb >> 8) & 0xff;
            int b = rgb & 0xff;
            rs += r;
            gs += g;
            bs += b;
          }
        }

        rs /= 9;
        gs /= 9;
        bs /= 9;

       newimgpixels[y*width+x] = (0xff000000 |
                                 rs << 16 | gs << 8 | bs);
      }
    }
  }
}

listing 18
public class Sharpen extends Convolver {

  private final int clamp(int c) {
    return (c > 255 ? 255 : (c < 0 ? 0 : c));
  }

  public void convolve() {
    int r0=0, g0=0, b0=0;
    for(int y=1; y<height-1; y++) {
      for(int x=1; x<width-1; x++) {
        int rs = 0;
        int gs = 0;
        int bs = 0;

        for(int k=-1; k<=1; k++) {
          for(int j=-1; j<=1; j++) {
            int rgb = imgpixels[(y+k)*width+x+j];
            int r = (rgb >> 16) & 0xff;
            int g = (rgb >> 8) & 0xff;
            int b = rgb & 0xff;
            if (j == 0 && k == 0) {
              r0 = r;
              g0 = g;
              b0 = b;
            } else {
              rs += r;
              gs += g;
              bs += b;
            }
          }
        }

        rs >>= 3;
        gs >>= 3;
        bs >>= 3;
        newimgpixels[y*width+x] = (0xff000000 |
                                clamp(r0+r0-rs) << 16 |
                                clamp(g0+g0-gs) << 8 |
                                clamp(b0+b0-bs));
      }
    }
  }
}

listing 19
// Animation example.
import java.applet.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;

public class Animation extends Applet implements Runnable {
  Image cell[];
  final int MAXSEQ = 64;
  int sequence[];
  int nseq;
  int idx;
  int framerate;
  boolean stopFlag;
 
  private int intDef(String s, int def) {
    int n = def;
    if (s != null)
      try {
        n = Integer.parseInt(s);
      } catch (NumberFormatException e) { };
    return n;
  }

  public void init() {
    framerate = intDef(getParameter("framerate"), 5);
    int tilex = intDef(getParameter("cols"), 1);
    int tiley = intDef(getParameter("rows"), 1);
    cell = new Image[tilex*tiley];

    StringTokenizer st = new 
              StringTokenizer(getParameter("sequence"), ",");
    sequence = new int[MAXSEQ];
    nseq = 0;
    while(st.hasMoreTokens() && nseq < MAXSEQ) {
      sequence[nseq] = intDef(st.nextToken(), 0);
      nseq++;
    }

    try {
      Image img = getImage(getDocumentBase(), getParameter("img"));
      MediaTracker t = new MediaTracker(this);
      t.addImage(img, 0);
      t.waitForID(0);
      int iw = img.getWidth(null);
      int ih = img.getHeight(null);
      int tw = iw / tilex;
      int th = ih / tiley;
      CropImageFilter f;
      FilteredImageSource fis;
      for (int y=0; y<tiley; y++) {
        for (int x=0; x<tilex; x++) {
          f = new CropImageFilter(tw*x, th*y, tw, th);
          fis = new FilteredImageSource(img.getSource(), f);
          int i = y*tilex+x;
          cell[i] = createImage(fis);
          t.addImage(cell[i], i);
        }
      }
      t.waitForAll();
    } catch (InterruptedException e) { };
  }

  public void update(Graphics g) { }

  public void paint(Graphics g) {
      g.drawImage(cell[sequence[idx]], 0, 0, null);
  }

  Thread t;
  public void start() {
    t = new Thread(this);
    stopFlag = false;
    t.start();
  }

  public void stop() {
    stopFlag = true;
  }

  public void run() {
    idx = 0;
    while (true) {
      paint(getGraphics());
      idx = (idx + 1) % nseq;
      try { Thread.sleep(1000/framerate); } catch (Exception e) { };
      if(stopFlag)
        return;
    }
  }
}

 
 
/**************** 
 * Chapter  24  *
 ****************/

listing 1
// Use the new I/O system to read a text file. 
import java.io.*; 
import java.nio.*; 
import java.nio.channels.*; 
 
public class ExplicitChannelRead { 
  public static void main(String args[]) { 
    FileInputStream fIn; 
    FileChannel fChan; 
    long fSize; 
    ByteBuffer mBuf; 
 
    try { 
      // First, open an file for input. 
      fIn = new FileInputStream("test.txt"); 
 
      // Next, obtain a channel to that file. 
      fChan = fIn.getChannel(); 
 
      // Now, get the file's size. 
      fSize = fChan.size(); 
 
      // Allocate a buffer of the necessary size. 
      mBuf = ByteBuffer.allocate((int)fSize); 
 
      // Read the file into the buffer. 
      fChan.read(mBuf); 
       
      // Rewind the buffer so that it can be read. 
      mBuf.rewind(); 
 
      // Read bytes from the buffer. 
      for(int i=0; i < fSize; i++) 
        System.out.print((char)mBuf.get()); 
 
      System.out.println(); 
 
      fChan.close(); // close channel 
      fIn.close();   // close file 
    } catch (IOException exc) { 
      System.out.println(exc); 
      System.exit(1); 
    } 
  } 
}

listing 2
// Use a mnapped file to read a text file. 
import java.io.*; 
import java.nio.*; 
import java.nio.channels.*; 
 
public class MappedChannelRead { 
  public static void main(String args[]) { 
    FileInputStream fIn; 
    FileChannel fChan; 
    long fSize; 
    MappedByteBuffer mBuf; 
 
    try { 
      // First, open an file for input. 
      fIn = new FileInputStream("test.txt"); 
 
      // Next, obtain a channel to that file. 
      fChan = fIn.getChannel(); 
 
      // Get the size of the file. 
      fSize = fChan.size(); 
 
      // Now, map the file into a buffer. 
      mBuf = fChan.map(FileChannel.MapMode.READ_ONLY, 
                       0, fSize); 
 
      // Read bytes from the buffer. 
      for(int i=0; i < fSize; i++) 
        System.out.print((char)mBuf.get()); 
 
      fChan.close(); // close channel 
      fIn.close();   // close file 
    } catch (IOException exc) { 
      System.out.println(exc); 
      System.exit(1); 
    } 
  } 
}

listing 3
// Write to a file using the new I/O. 
import java.io.*; 
import java.nio.*; 
import java.nio.channels.*; 
 
public class ExplicitChannelWrite { 
  public static void main(String args[]) { 
    FileOutputStream fOut; 
    FileChannel fChan; 
    ByteBuffer mBuf; 
 
    try { 
      fOut = new FileOutputStream("test.txt"); 
 
      // Get a channel to the output file. 
      fChan = fOut.getChannel(); 
 
      // Create a buffer. 
      mBuf = ByteBuffer.allocateDirect(26); 
 
      // Write some bytes to the buffer. 
      for(int i=0; i<26; i++)  
        mBuf.put((byte)('A' + i)); 
 
      // Rewind the buffer so that it can written. 
      mBuf.rewind(); 
 
      // Write the buffer to the output file. 
      fChan.write(mBuf); 
 
      // close channel and file. 
      fChan.close(); 
      fOut.close(); 
    } catch (IOException exc) { 
      System.out.println(exc); 
      System.exit(1); 
    } 
  } 
}

listing 4
// Write to a mapped file. 
import java.io.*; 
import java.nio.*; 
import java.nio.channels.*; 
 
public class MappedChannelWrite { 
  public static void main(String args[]) { 
    RandomAccessFile fOut; 
    FileChannel fChan; 
    ByteBuffer mBuf; 
 
    try { 
      fOut = new RandomAccessFile("test.txt", "rw"); 
 
      // Next, obtain a channel to that file. 
      fChan = fOut.getChannel(); 
 
      // Then, map the file into a buffer. 
      mBuf = fChan.map(FileChannel.MapMode.READ_WRITE, 
                       0, 26); 
 
      // Write some bytes to the buffer. 
      for(int i=0; i<26; i++)  
        mBuf.put((byte)('A' + i)); 
 
      // close channel and file. 
      fChan.close(); 
      fOut.close(); 
    } catch (IOException exc) { 
      System.out.println(exc); 
      System.exit(1); 
    } 
  } 
}

listing 5
// Copy a file using NIO. 
import java.io.*; 
import java.nio.*; 
import java.nio.channels.*; 
 
public class NIOCopy { 
 
  public static void main(String args[]) { 
    FileInputStream fIn; 
    FileOutputStream fOut; 
    FileChannel fIChan, fOChan; 
    long fSize; 
    MappedByteBuffer mBuf; 
 
    try { 
      fIn = new FileInputStream(args[0]); 
      fOut = new FileOutputStream(args[1]); 
 
      // Get channels to the input and output files. 
      fIChan = fIn.getChannel(); 
      fOChan = fOut.getChannel(); 
 
      // Get the size of the file. 
      fSize = fIChan.size(); 
 
      // Map the input file to a buffer. 
      mBuf = fIChan.map(FileChannel.MapMode.READ_ONLY, 
                        0, fSize); 
 
      // Write the buffer to the output file. 
      fOChan.write(mBuf); // this copies the file 
 
      // Close the channels and files. 
      fIChan.close(); 
      fIn.close(); 
 
      fOChan.close(); 
      fOut.close(); 
    } catch (IOException exc) { 
      System.out.println(exc); 
      System.exit(1); 
    } catch (ArrayIndexOutOfBoundsException exc) {       
      System.out.println("Usage: Copy from to"); 
      System.exit(1); 
    } 
  } 
}

listing 6
// A simple pattern matching demo. 
import java.util.regex.*; 
 
class RegExpr { 
  public static void main(String args[]) { 
    Pattern pat; 
    Matcher mat; 
    boolean found; 
 
    pat = Pattern.compile("Java"); 
    mat = pat.matcher("Java"); 
 
    found = mat.matches(); // check for a match 
 
    System.out.println("Testing Java against Java."); 
    if(found) System.out.println("Matches"); 
    else System.out.println("No Match"); 
 
    System.out.println(); 
 
    System.out.println("Testing Java against Java 2."); 
    mat = pat.matcher("Java 2"); // create a new matcher 
 
    found = mat.matches(); // check for a match 
 
    if(found) System.out.println("Matches"); 
    else System.out.println("No Match"); 
  } 
}

listing 7
// Use find() to find a subsequence. 
import java.util.regex.*; 
 
class RegExpr2 { 
  public static void main(String args[]) { 
    Pattern pat = Pattern.compile("Java"); 
    Matcher mat = pat.matcher("Java 2"); 
 
    System.out.println("Looking for Java in Java 2."); 
 
    if(mat.find()) System.out.println("subsequence found"); 
    else System.out.println("No Match"); 
  } 
}

listing 8
// Use find() to find multiple subsequences. 
import java.util.regex.*; 
 
class RegExpr3 { 
  public static void main(String args[]) { 
    Pattern pat = Pattern.compile("test"); 
    Matcher mat = pat.matcher("test 1 2 3 test"); 
 
    while(mat.find()) { 
      System.out.println("test found at index " + 
                         mat.start()); 
    } 
  } 
}

listing 9
// Use a quantifier. 
import java.util.regex.*; 
 
class RegExpr4 { 
  public static void main(String args[]) { 
    Pattern pat = Pattern.compile("W+"); 
    Matcher mat = pat.matcher("W WW WWW"); 
 
    while(mat.find()) 
      System.out.println("Match: " + mat.group());  
  } 
}

listing 10
// Use wildcard and quantifier. 
import java.util.regex.*; 
 
class RegExpr5 { 
  public static void main(String args[]) { 
    Pattern pat = Pattern.compile("e.+d"); 
    Matcher mat = pat.matcher("extend cup end table"); 
 
    while(mat.find()) 
      System.out.println("Match: " + mat.group());  
  } 
}

listing 11
// Use the ? quantifier. 
import java.util.regex.*; 
 
class RegExpr6 { 
  public static void main(String args[]) { 
    // Use reluctant matching behavoir. 
    Pattern pat = Pattern.compile("e.+?d"); 
    Matcher mat = pat.matcher("extend cup end table"); 
 
    while(mat.find()) 
      System.out.println("Match: " + mat.group());  
  } 
}

listing 12
// Use a character class. 
import java.util.regex.*; 
 
class RegExpr7 { 
  public static void main(String args[]) { 
    // Match lowercase words. 
    Pattern pat = Pattern.compile("[a-z]+"); 
    Matcher mat = pat.matcher("this is a test."); 
 
    while(mat.find()) 
      System.out.println("Match: " + mat.group());  
  } 
}

listing 13
// Use replaceAll(). 
import java.util.regex.*; 
 
class RegExpr8 { 
  public static void main(String args[]) { 
    String str = "Jon Jonathan Frank Ken Todd"; 
 
    Pattern pat = Pattern.compile("Jon.*? "); 
    Matcher mat = pat.matcher(str); 
 
    System.out.println("Original sequence: " + str); 
 
    str = mat.replaceAll("Eric "); 
 
    System.out.println("Modified sequence: " + str); 
 
  } 
}

listing 14
// Use split(). 
import java.util.regex.*; 
 
class RegExpr9 { 
  public static void main(String args[]) { 
 
    // Match lowercase words. 
    Pattern pat = Pattern.compile("[ ,.!]"); 
 
    String strs[] = pat.split("one two,alpha9 12!done."); 
 
    for(int i=0; i < strs.length; i++) 
      System.out.println("Next token: " + strs[i]); 
 
  } 
}

listing 15
// Demonstrate reflection.
import java.lang.reflect.*;
public class ReflectionDemo1 {
  public static void main(String args[]) {
    try {
      Class c = Class.forName("java.awt.Dimension");
      System.out.println("Constructors:");
      Constructor constructors[] = c.getConstructors();
      for(int i = 0; i < constructors.length; i++) {
        System.out.println(" " + constructors[i]);
      }

      System.out.println("Fields:");
      Field fields[] = c.getFields();
      for(int i = 0; i < fields.length; i++) {
        System.out.println(" " + fields[i]);
      }

      System.out.println("Methods:");
      Method methods[] = c.getMethods();
      for(int i = 0; i < methods.length; i++) {
        System.out.println(" " + methods[i]);
      }
    }
    catch(Exception e) {
      System.out.println("Exception: " + e);
    }
  }
}

listing 16
// Show public methods.
import java.lang.reflect.*;
public class ReflectionDemo2 {
  public static void main(String args[]) {
    try {
      A a = new A();
      Class c = a.getClass();
      System.out.println("Public Methods:");
      Method methods[] = c.getDeclaredMethods();
      for(int i = 0; i < methods.length; i++) {
        int modifiers = methods[i].getModifiers();
        if(Modifier.isPublic(modifiers)) {
          System.out.println(" " + methods[i].getName());
        }
      }
    }
    catch(Exception e) {
      System.out.println("Exception: " + e);
    }
  }
}

class A {
  public void a1() {
  }
  public void a2() {
  }
  protected void a3() {
  }
  private void a4() {
  }
}

listing 17
import java.rmi.*;
public interface AddServerIntf extends Remote {
  double add(double d1, double d2) throws RemoteException;
}

listing 18
import java.rmi.*;
import java.rmi.server.*;
public class AddServerImpl extends UnicastRemoteObject
  implements AddServerIntf {

  public AddServerImpl() throws RemoteException {
  }
  public double add(double d1, double d2) throws RemoteException {
    return d1 + d2;
  }
}

listing 19
import java.net.*;
import java.rmi.*;
public class AddServer {
  public static void main(String args[]) {
    try {
      AddServerImpl addServerImpl = new AddServerImpl();
      Naming.rebind("AddServer", addServerImpl);
    }
    catch(Exception e) {
      System.out.println("Exception: " + e);
    }
  }
}

listing 20
import java.rmi.*;
public class AddClient {
  public static void main(String args[]) {
    try {
      String addServerURL = "rmi://" + args[0] + "/AddServer";
      AddServerIntf addServerIntf =
                    (AddServerIntf)Naming.lookup(addServerURL);
      System.out.println("The first number is: " + args[1]);
      double d1 = Double.valueOf(args[1]).doubleValue();
      System.out.println("The second number is: " + args[2]);

      double d2 = Double.valueOf(args[2]).doubleValue();
      System.out.println("The sum is: " + addServerIntf.add(d1, d2));
    }
    catch(Exception e) {
      System.out.println("Exception: " + e);
    }
  }
}

listing 21
// Demonstrate date formats.
import java.text.*;
import java.util.*;

public class DateFormatDemo {
  public static void main(String args[]) {
    Date date = new Date();
    DateFormat df;

    df = DateFormat.getDateInstance(DateFormat.SHORT, Locale.JAPAN);
    System.out.println("Japan: " + df.format(date));

    df = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.KOREA);
    System.out.println("Korea: " + df.format(date));

    df = DateFormat.getDateInstance(DateFormat.LONG, Locale.UK);
    System.out.println("United Kingdom: " + df.format(date));

    df = DateFormat.getDateInstance(DateFormat.FULL, Locale.US);
    System.out.println("United States: " + df.format(date));
  }
}

listing 22
// Demonstrate time formats.
import java.text.*;
import java.util.*;
public class TimeFormatDemo {
  public static void main(String args[]) {
    Date date = new Date();
    DateFormat df;

    df = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.JAPAN);
    System.out.println("Japan: " + df.format(date));

    df = DateFormat.getTimeInstance(DateFormat.LONG, Locale.UK);
    System.out.println("United Kingdom: " + df.format(date));

    df = DateFormat.getTimeInstance(DateFormat.FULL, Locale.CANADA);
    System.out.println("Canada: " + df.format(date));
  }
}

listing 23
// Demonstrate SimpleDateFormat.
import java.text.*;
import java.util.*;

public class SimpleDateFormatDemo {
  public static void main(String args[]) {
    Date date = new Date();
    SimpleDateFormat sdf;
    sdf = new SimpleDateFormat("hh:mm:ss");
    System.out.println(sdf.format(date));
    sdf = new SimpleDateFormat("dd MMM yyyy hh:mm:ss zzz");
    System.out.println(sdf.format(date));
    sdf = new SimpleDateFormat("E MMM dd yyyy");
    System.out.println(sdf.format(date));
  }
}

 
 
/**************** 
 * Chapter  25  *
 ****************/

listing 1
public class Box {
  private double depth, height, width;
  public double getDepth( ) {
    return depth;
  }
  public void setDepth(double d) {
    depth = d;
  }
  public double getHeight( ) {
    return height;
  }
  public void setHeight(double h) {
    height = h;
  }
  public double getWidth( ) {
    return width;
  }
  public void setWidth(double w) {
    width = w;
  }
}

listing 2
public class Line {
  private boolean dotted = false;
  public boolean isDotted( ) {
    return dotted;
  }
  public void setDotted(boolean dotted) {
    this.dotted = dotted;
  }
}

listing 3
public class PieChart {
  private double data[ ];
  public double getData(int index) {
    return data[index];
  }
  public void setData(int index, double value) {
    data[index] = value;
  }
  public double[ ] getData( ) {
    return data;
  }
  public void setData(double[ ] values) {
    data = new double[values.length];
    System.arraycopy(values, 0, data, 0, values.length);
  }
}

listing 4
// A simple Bean.
package sunw.demo.colors;
import java.awt.*;
import java.awt.event.*;
public class Colors extends Canvas {
  transient private Color color;
  private boolean rectangular;
  public Colors() {
    addMouseListener(new MouseAdapter() {
      public void mousePressed(MouseEvent me) {
        change();
      }
    });
    rectangular = false;
    setSize(200, 100);
    change();
  }
  public boolean getRectangular() {
    return rectangular;
  }
  public void setRectangular(boolean flag) {
    this.rectangular = flag;
    repaint();
  }
  public void change() {
    color = randomColor();
    repaint();
  }
  private Color randomColor() {
    int r = (int)(255*Math.random());
    int g = (int)(255*Math.random());
    int b = (int)(255*Math.random());
    return new Color(r, g, b);
  }
  public void paint(Graphics g) {
    Dimension d = getSize();
    int h = d.height;
    int w = d.width;
    g.setColor(color);
    if(rectangular) {
      g.fillRect(0, 0, w-1, h-1);
    }
    else {
      g.fillOval(0, 0, w-1, h-1);
    }
  }
}

listing 5
// A Bean information class.
package sunw.demo.colors;
import java.beans.*;
public class ColorsBeanInfo extends SimpleBeanInfo {
  public PropertyDescriptor[] getPropertyDescriptors() {
    try {
      PropertyDescriptor rectangular = new
         PropertyDescriptor("rectangular", Colors.class);
      PropertyDescriptor pd[] = {rectangular};
      return pd;
    }
    catch(Exception e) {
    }
    return null;
  }
}

listing 6
// Show properties and events.
package sunw.demo.colors;
import java.awt.*;
import java.beans.*;
public class IntrospectorDemo {
  public static void main(String args[]) {
    try {
      Class c = Class.forName("sunw.demo.colors.Colors");
      BeanInfo beanInfo = Introspector.getBeanInfo(c);
      BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor();

      System.out.println("Bean name = " + beanDescriptor.getName());

      System.out.println("Properties:");
      PropertyDescriptor propertyDescriptor[] = beanInfo.getPropertyDescriptors();
      for(int i = 0; i < propertyDescriptor.length; i++) {
        System.out.println("\t" + propertyDescriptor[i].getName());
      }

      System.out.println("Events:");
      EventSetDescriptor eventSetDescriptor[] = beanInfo.getEventSetDescriptors();
      for(int i = 0; i < eventSetDescriptor.length; i++) {
        System.out.println("\t" + eventSetDescriptor[i].getName());
      }
    }
    catch(Exception e) {
      System.out.println("Exception caught. " + e);
    }
  }
}

 
 
/**************** 
 * Chapter  26  *
 ****************/

listing 1
import java.io.*; 
import javax.servlet.*; 
 
public class HelloServlet extends GenericServlet { 
 
  public void service(ServletRequest request,  
    ServletResponse response)  
  throws ServletException, IOException { 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>Hello!"); 
    pw.close(); 
  } 
}

listing 2
<html> 
<body> 
<center> 
<form name="Form1" 
  method="post" 
  action="http://localhost:8080/examples/servlet/PostParametersServlet"> 
<table> 
<tr> 
  <td><B>Employee</td> 
  <td><input type=textbox name="e" size="25" value=""></td> 
</tr> 
<tr> 
  <td><B>Phone</td> 
  <td><input type=textbox name="p" size="25" value=""></td> 
</tr> 
</table> 
<input type=submit value="Submit"> 
</body> 
</html>

listing 3
import java.io.*; 
import java.util.*; 
import javax.servlet.*; 
 
public class PostParametersServlet  
extends GenericServlet { 
 
  public void service(ServletRequest request,  
    ServletResponse response)  
  throws ServletException, IOException { 
 
    // Get print writer. 
    PrintWriter pw = response.getWriter(); 
 
    // Get enumeration of parameter names. 
    Enumeration e = request.getParameterNames(); 
 
    // Display parameter names and values. 
    while(e.hasMoreElements()) { 
      String pname = (String)e.nextElement(); 
      pw.print(pname + " = "); 
      String pvalue = request.getParameter(pname); 
      pw.println(pvalue); 
    } 
    pw.close(); 
  } 
}

listing 4
<html> 
<body> 
<center> 
<form name="Form1"  
  action="http://localhost:8080/examples/servlet/ColorGetServlet"> 
<B>Color:</B> 
<select name="color" size="1"> 
<option value="Red">Red</option> 
<option value="Green">Green</option> 
<option value="Blue">Blue</option> 
</select> 
<br><br> 
<input type=submit value="Submit"> 
</form> 
</body> 
</html>

listing 5
import java.io.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class ColorGetServlet extends HttpServlet { 
 
  public void doGet(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    String color = request.getParameter("color"); 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>The selected color is:  "); 
    pw.println(color); 
    pw.close(); 
  } 
}

listing 6
<html> 
<body> 
<center> 
<form name="Form1"  
  method="post" 
  action="http://localhost:8080/examples/servlet/ColorPostServlet"> 
<B>Color:</B> 
<select name="color" size="1"> 
<option value="Red">Red</option> 
<option value="Green">Green</option> 
<option value="Blue">Blue</option> 
</select> 
<br><br> 
<input type=submit value="Submit"> 
</form> 
</body> 
</html>

listing 7
import java.io.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class ColorPostServlet extends HttpServlet { 
 
  public void doPost(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    String color = request.getParameter("color"); 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>The selected color is:  "); 
    pw.println(color); 
    pw.close(); 
  } 
}

listing 8
<html> 
<body> 
<center> 
<form name="Form1"  
  method="post" 
  action="http://localhost:8080/examples/servlet/AddCookieServlet"> 
<B>Enter a value for MyCookie:</B> 
<input type=textbox name="data" size=25 value=""> 
<input type=submit value="Submit"> 
</form> 
</body> 
</html>

listing 9
import java.io.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class AddCookieServlet extends HttpServlet { 
 
  public void doPost(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    // Get parameter from HTTP request. 
    String data = request.getParameter("data"); 
 
    // Create cookie. 
    Cookie cookie = new Cookie("MyCookie", data); 
 
    // Add cookie to HTTP response. 
    response.addCookie(cookie); 
 
    // Write output to browser. 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>MyCookie has been set to"); 
    pw.println(data); 
    pw.close(); 
  } 
}

listing 10
import java.io.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class GetCookiesServlet extends HttpServlet { 
 
  public void doGet(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    // Get cookies from header of HTTP request. 
    Cookie[] cookies = request.getCookies(); 
 
    // Display these cookies. 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>"); 
    for(int i = 0; i < cookies.length; i++) { 
      String name = cookies[i].getName(); 
      String value = cookies[i].getValue(); 
      pw.println("name = " + name +  
        "; value = " + value); 
    } 
    pw.close(); 
  } 
}

listing 11
import java.io.*; 
import java.util.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class DateServlet extends HttpServlet { 
 
  public void doGet(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    // Get the HttpSession object. 
    HttpSession hs = request.getSession(true); 
 
    // Get writer. 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.print("<B>"); 
 
    // Display date/time of last access. 
    Date date = (Date)hs.getAttribute("date"); 
    if(date != null) { 
      pw.print("Last access: " + date + "<br>"); 
    } 
 
    // Display current date/time. 
    date = new Date(); 
    hs.setAttribute("date", date); 
    pw.println("Current date: " + date); 
  } 
}
 
/**************** 
 * Chapter  27  *
 ****************/

listing 1
import java.io.*; 
import javax.servlet.*; 
 
public class HelloServlet extends GenericServlet { 
 
  public void service(ServletRequest request,  
    ServletResponse response)  
  throws ServletException, IOException { 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>Hello!"); 
    pw.close(); 
  } 
}

listing 2
<html> 
<body> 
<center> 
<form name="Form1" 
  method="post" 
  action="http://localhost:8080/examples/servlet/PostParametersServlet"> 
<table> 
<tr> 
  <td><B>Employee</td> 
  <td><input type=textbox name="e" size="25" value=""></td> 
</tr> 
<tr> 
  <td><B>Phone</td> 
  <td><input type=textbox name="p" size="25" value=""></td> 
</tr> 
</table> 
<input type=submit value="Submit"> 
</body> 
</html>

listing 3
import java.io.*; 
import java.util.*; 
import javax.servlet.*; 
 
public class PostParametersServlet  
extends GenericServlet { 
 
  public void service(ServletRequest request,  
    ServletResponse response)  
  throws ServletException, IOException { 
 
    // Get print writer. 
    PrintWriter pw = response.getWriter(); 
 
    // Get enumeration of parameter names. 
    Enumeration e = request.getParameterNames(); 
 
    // Display parameter names and values. 
    while(e.hasMoreElements()) { 
      String pname = (String)e.nextElement(); 
      pw.print(pname + " = "); 
      String pvalue = request.getParameter(pname); 
      pw.println(pvalue); 
    } 
    pw.close(); 
  } 
}

listing 4
<html> 
<body> 
<center> 
<form name="Form1"  
  action="http://localhost:8080/examples/servlet/ColorGetServlet"> 
<B>Color:</B> 
<select name="color" size="1"> 
<option value="Red">Red</option> 
<option value="Green">Green</option> 
<option value="Blue">Blue</option> 
</select> 
<br><br> 
<input type=submit value="Submit"> 
</form> 
</body> 
</html>

listing 5
import java.io.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class ColorGetServlet extends HttpServlet { 
 
  public void doGet(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    String color = request.getParameter("color"); 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>The selected color is:  "); 
    pw.println(color); 
    pw.close(); 
  } 
}

listing 6
<html> 
<body> 
<center> 
<form name="Form1"  
  method="post" 
  action="http://localhost:8080/examples/servlet/ColorPostServlet"> 
<B>Color:</B> 
<select name="color" size="1"> 
<option value="Red">Red</option> 
<option value="Green">Green</option> 
<option value="Blue">Blue</option> 
</select> 
<br><br> 
<input type=submit value="Submit"> 
</form> 
</body> 
</html>

listing 7
import java.io.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class ColorPostServlet extends HttpServlet { 
 
  public void doPost(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    String color = request.getParameter("color"); 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>The selected color is:  "); 
    pw.println(color); 
    pw.close(); 
  } 
}

listing 8
<html> 
<body> 
<center> 
<form name="Form1"  
  method="post" 
  action="http://localhost:8080/examples/servlet/AddCookieServlet"> 
<B>Enter a value for MyCookie:</B> 
<input type=textbox name="data" size=25 value=""> 
<input type=submit value="Submit"> 
</form> 
</body> 
</html>

listing 9
import java.io.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class AddCookieServlet extends HttpServlet { 
 
  public void doPost(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    // Get parameter from HTTP request. 
    String data = request.getParameter("data"); 
 
    // Create cookie. 
    Cookie cookie = new Cookie("MyCookie", data); 
 
    // Add cookie to HTTP response. 
    response.addCookie(cookie); 
 
    // Write output to browser. 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>MyCookie has been set to"); 
    pw.println(data); 
    pw.close(); 
  } 
}

listing 10
import java.io.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class GetCookiesServlet extends HttpServlet { 
 
  public void doGet(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    // Get cookies from header of HTTP request. 
    Cookie[] cookies = request.getCookies(); 
 
    // Display these cookies. 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.println("<B>"); 
    for(int i = 0; i < cookies.length; i++) { 
      String name = cookies[i].getName(); 
      String value = cookies[i].getValue(); 
      pw.println("name = " + name +  
        "; value = " + value); 
    } 
    pw.close(); 
  } 
}

listing 11
import java.io.*; 
import java.util.*; 
import javax.servlet.*; 
import javax.servlet.http.*; 
 
public class DateServlet extends HttpServlet { 
 
  public void doGet(HttpServletRequest request,  
    HttpServletResponse response)  
  throws ServletException, IOException { 
 
    // Get the HttpSession object. 
    HttpSession hs = request.getSession(true); 
 
    // Get writer. 
    response.setContentType("text/html"); 
    PrintWriter pw = response.getWriter(); 
    pw.print("<B>"); 
 
    // Display date/time of last access. 
    Date date = (Date)hs.getAttribute("date"); 
    if(date != null) { 
      pw.print("Last access: " + date + "<br>"); 
    } 
 
    // Display current date/time. 
    date = new Date(); 
    hs.setAttribute("date", date); 
    pw.println("Current date: " + date); 
  } 
}
 
/**************** 
 * Chapter  28  *
 ****************/
 
listing 1
// Reverse the signs of a coordinate - C++ version.
#include <iostream>
using namespace std;

class Coord {
public:
  int x;
  int y;
};

// Reverse the sign of the coordinates.
void reverseSign(Coord *ob) {
  ob->x = -ob->x;
  ob->y = -ob->y;
}

int main()
{
  Coord ob;
  
  ob.x = 10;
  ob.y = 20;

  cout << "Original values for ob: ";
  cout << ob.x << ", " << ob.y << "\n";

  reverseSign(&ob);

  cout << "Sign reversed values for ob: ";
  cout << ob.x << ", " << ob.y << "\n";

  return 0;
}

listing 2
// Reverse the signs of a coordinate - Java version.
class Coord {
  int x;
  int y;
};

class DropPointers {
  // Reverse the sign of the coordinates.
  static void reverseCoord(Coord ob) {
    ob.x = -ob.x;
    ob.y = -ob.y;
  }

  public static void main(String args[]) {
    Coord ob = new Coord();
  
    ob.x = 10;
    ob.y = 20;

    System.out.println("Original values for ob: " +
      ob.x + ", " + ob.y);

    reverseCoord(ob);

    System.out.println("Sign reversed values for ob: " +
      ob.x + ", " + ob.y);
  }
}

listing 3
// Copy an array in C++ using pointers.
#include <iostream>
using namespace std;

int main()
{
  int nums[] = {10, 12, 24, 45, 23, 19, 44,
                88, 99, 65, 76, 12, 89, 0};
  int copy[20];

  int *p1, *p2; // integer pointers

  // copy array
  p1 = nums; // p1 points to start of nums array
  p2 = copy;
  while(*p1) *p2++ = *p1++;
  *p2 = 0; // terminate copy with zero
  
  // Display contents of each array.
  cout << "Here is the original array:\n";
  p1 = nums;
  while(*p1) cout << *p1++ << " ";
  cout << endl;

  cout << "Here is the copy:\n";
  p1 = copy;
  while(*p1) cout << *p1++ << " ";
  cout << endl;

  return 0;
}

listing 4
while(*p1) *p2++ = *p1++;

listing 5
// Array copy without pointers using Java.
class CopyArray {
  public static void main(String args[]) {
    int nums[] = {10, 12, 24, 45, 23, 19, 44,
                  88, 99, 65, 76, 12, 89, 0};
    int copy[] = new int[14];

    int i;

    // copy array
    for(i=0; nums[i]!=0; i++)
      copy[i] = nums[i];
    nums[i] = 0; // terminate copy with zero
  
    // Display contents of each array.
    System.out.println("Here is the original array:");
    for(i=0; nums[i]!=0; i++) 
      System.out.print(nums[i] + " ");
    System.out.println();

    System.out.println("Here is the copy:");
    for(i=0; nums[i]!=0; i++) 
      System.out.print(copy[i] + " ");
    System.out.println();
  }
}

listing 6
// Swap coordinates -- C++ version.
#include <iostream>
using namespace std;

class Coord {
public:
  int x;
  int y;
};

// Swap contents of two Coord objects.
void swap(Coord &a, Coord &b) {
  Coord temp;

  // swap contents of objects
  temp = a;
  a = b;
  b = temp;
}

int main()
{
  Coord ob1, ob2;
  
  ob1.x = 10;
  ob1.y = 20;

  ob2.x = 88;
  ob2.y = 99;

  cout << "Original values:\n";
  cout << "ob1: " << ob1.x << ", " << ob1.y << "\n";
  cout << "ob2: " << ob2.x << ", " << ob2.y << "\n";
  cout << "\n";

  swap(ob1, ob2);

  cout << "Swapped values:\n";
  cout << "ob1: " << ob1.x << ", " << ob1.y << "\n";
  cout << "ob2: " << ob2.x << ", " << ob2.y << "\n";

  return 0;
}

listing 7
// Swap program incorrectly converted to Java.
class Coord {
  int x;
  int y;
};

class SwapDemo {
  static void swap(Coord a, Coord b) {
    Coord temp = new Coord();
 
    // this won't swap contents of a and b!
    temp = a;
    a = b;
    b = temp;
  }

  public static void main(String args[]) {
    Coord ob1 = new Coord();
    Coord ob2 = new Coord();
  
    ob1.x = 10;
    ob1.y = 20;

    ob2.x = 88;
    ob2.y = 99;

    System.out.println("Original values:");
    System.out.println("ob1: " +
           ob1.x + ", " + ob1.y);
    System.out.println("ob2: " +
           ob2.x + ", " + ob2.y + "\n");

    swap(ob1, ob2);

    System.out.println("Swapped values:");
    System.out.println("ob1: " +
           ob1.x + ", " + ob1.y);
    System.out.println("ob2: " +
           ob2.x + ", " + ob2.y + "\n");
  }
}

listing 8
// Corrected version of swap().
static void swap(Coord a, Coord b) {
  Coord temp = new Coord();
 
  // swap contents of objects
  temp.x = a.x;
  temp.y = a.y;
  a.x = b.x;
  a.y = b.y;
  b.x = temp.x;
  b.y = temp.y;
}

listing 9
// A C++-style abstract class and its implementation.
#include <iostream>
#include <cstdlib>
using namespace std;

// An abstract class that defines the form of an integer list.
class IntList {
public:
  virtual int getNext() = 0; // pure virtual functions
  virtual void putOnList(int i) = 0; 
};

// Create an implementation of an integer list.
class IntArray : public IntList {
  int storage[100];
  int putIndex, getIndex;
public:
  IntArray() {
    putIndex = 0;
    getIndex = 0;
  }

  // Return next integer in list.
  int getNext() {
    if(getIndex >= 100) {
      cout << "List Underflow";
      exit(1);
    }
    getIndex++;
    return storage[getIndex-1];
  }

  // Put an integer on the list.
  void putOnList(int i) {
    if(putIndex < 100) {
      storage[putIndex] = i;
      putIndex++;
    }
    else {
      cout << "List Overflow";
      exit(1);
    }
  }
};

int main()
{
  IntArray nums;
  int i;

  for(i=0; i<10; i++) nums.putOnList(i);

  for(i=0; i<10; i++)
    cout << nums.getNext() << endl;

  return 0;
}

listing 10
// Here, IntList is made into an interface which IntArray implements.

// Define interface for an integer list.
interface IntListIF {
  int getNext(); 
  void putOnList(int i); 
}

// Create an implementation of an integer list.
class IntArray implements IntListIF {
  private int storage[];
  private int putIndex, getIndex;

  IntArray() {
    storage = new int[100];
    putIndex = 0;
    getIndex = 0;
  }

  // Create an implementation of an integer list.
  public int getNext() {
    if(getIndex >= 100) {
      System.out.println("List Underflow");
      System.exit(1);
    }
    getIndex++;
    return storage[getIndex-1];
  }

  // Put an integer on the list.
  public void putOnList(int i) {
    if(putIndex < 100) {
      storage[putIndex] = i;
      putIndex++;
    }
    else {
      System.out.println("List Overflow");
      System.exit(1);
    }
  }
}

class ListDemo {
  public static void main(String args[]) {
    IntArray nums = new IntArray();
    int i;

    for(i=0; i<10; i++) nums.putOnList(i);

    for(i=0; i<10; i++)
      System.out.println(nums.getNext());
  }
}

listing 11
// An abstract C++ class.
class SomeClass {
  bool isOK;
public:
  virtual int f1() = 0; 
  virtual void f2(int i) = 0; 
  virtual double f3() = 0;
  virtual int f4(int a, char ch) = 0;
};

listing 12
interface SomeClass {
  int f1();
  void f2(int i);
  double f3();
  int f4(int a, char ch);
  boolean isOK();
}

listing 13
// C++ program that uses default arguments.
#include <iostream>
using namespace std;

/* Compute area of a rectangle.  For a square
   pass only one argument.
*/
double area(double l, double w=0) {
  if(w==0)  return l * l;
  else return l * w;
}

int main()
{
  cout << "Area of 2.2 by 3.4 rectangle: ";
  cout << area(2.2, 3.4) << endl;

  cout << "Area of 3.0 by 3.0 square: ";
  cout << area(3.0) << endl;

  return 0;
}

listing 14
// Java version of area program.
class Area {
  // Compute area of a rectangle.
  static double area(double l, double w) {
    if(w==0)  return l * l;
    else return l * w;
  }

  // Overload area( ) for a square.
  static double area(double l) {
    return l * l;
  }

  public static void main(String args[]) {
    System.out.println("Area of 2.2 by 3.4 rectangle: " +
                        area(2.2, 3.4));

    System.out.println("Area of 3.0 by 3.0 square: " +
                       area(3.0));
  }
}

listing 15
class Foundation {
  // ...
};

class Walls {
  // ...
};

class Rooms {
  // ...
};

class House : public Foundation, Walls, Rooms {
  // ...
};

listing 16
class Foundation {
  // ...
}

class Walls extends Foundation {
  // ...
}

class Rooms extends Walls {
  // ...
}

class House extends Rooms {
  // ...
}

listing 17
class Foundation {
  // ...
}

class Walls{
  // ...
}

class Rooms {
  // ...
}

/* Now, House includes Foundation, Walls, and Rooms,
   as object members.
*/
class House {
  Foundation f;
  Walls w;
  Rooms r;
  // ...
}

listing 18
// This C++ program can call f() indefinitely.
#include <iostream>
#include <cstdlib>
using namespace std;

const int MAX = 5;
int count = 0;

class X {
public:
  // constructor
  X() {
   if(count<MAX) {
     count++;
    }
    else  {
      cout << "Error -- can't construct";
      exit(1);
    }
  }

  // destructor
  ~X() {
    count--;
  }
};

void f()
{
  X ob; // allocate an object
  // destruct on way out
}

int main()
{
  int i;

  for(i=0; i < (MAX*2); i++) {
    f();
    cout << "Current count is: " << count << endl;
  }

  return 0;
}

listing 19
// This Java program will fail after 5 calls to f().

class X {
  static final int MAX = 5;
  static int count = 0;

  // constructor
  X() {
   if(count<MAX) {
     count++;
    }
    else  {
      System.out.println("Error -- can't construct");
      System.exit(1);
    }
  }

  // finalization
  protected void finalize() {
    count--;
  }

  static void f()
  {
    X ob = new X(); // allocate an object
    // destruct on way out
  }

  public static void main(String args[]) {
    int i;

    for(i=0; i < (MAX*2); i++) {
      f();
      System.out.println("Current count is: " + count);
    }
  }
}


 
 /**************** 
 * Chapter  29  *
 ****************/
 
listing 1
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.awt.*;
import java.awt.image.*;

public class DynamicBillboard
       extends java.applet.Applet
       implements Runnable {

  BillData[] billboards;
  int current_billboard;
  int next_billboard;

  String[] transition_classes;
  Thread thread = null;
  Image image = null;
  long delay = -1;
  boolean mouse_inside_applet;
  String link_target_frame;
  boolean stopFlag;

  public void init() {
    String s = getParameter("bgcolor");
    if(s != null) {
      Color color = new Color(Integer.parseInt(s.substring(1), 16));
      setBackground(color);
      getParent().setBackground(color);
      getParent().repaint();          
    }
    billboards = new
      BillData[Integer.parseInt(getParameter("billboards"))];
    current_billboard = next_billboard
                      = (int)(Math.random() *billboards.length);
    parseBillData();
  }

  void parseBillData() {
    String s = getParameter("bill" + next_billboard);
    int field_end = s.indexOf(",");
    Image new_image = getImage(getDocumentBase(),
                               s.substring(0, field_end));
    URL link;
    try {
      link = new URL(getDocumentBase(),
                     s.substring(field_end + 1));
    }
    catch (java.net.MalformedURLException e) {
      e.printStackTrace();
      link = getDocumentBase();
    }
    billboards[next_billboard] = new BillData(link, new_image);
    if(image == null) {
      image = new_image;
    }
    else {
      prepareImage(new_image, this);
      billboards[next_billboard].initPixels(getSize().width, 
                                            getSize().height);
    }
  }

  void finishInit() {
    if(delay != -1) {
      return;
    }
    delay = Long.parseLong(getParameter("delay"));

    link_target_frame = getParameter("target");
    if(link_target_frame == null) {
      link_target_frame = "_top";
    }

    String s = getParameter("transitions");
    int field_end = s.indexOf(",");

    int trans_count = Integer.parseInt(s.substring(0, field_end));
    transition_classes = new String[trans_count];
    for(--trans_count; trans_count > 0; --trans_count) {
      s = s.substring(field_end + 1);      
      field_end = s.indexOf(",");
      transition_classes[trans_count] = s.substring(0, field_end);
    }
    transition_classes[0] = s.substring(field_end + 1);
    billboards[next_billboard].initPixels(getSize().width, 
                                          getSize().height);
    mouse_inside_applet = false;
  }

  public void paint(Graphics g) {
    g.drawImage(image, 0, 0, this);
  }

  public void update(Graphics g) {
    paint(g);
  }

  public void start() {
    next_billboard = current_billboard;
    image = billboards[current_billboard].image;
    setCursor(new Cursor(Cursor.HAND_CURSOR));
    if(thread == null) {
      thread = new Thread(this);
      thread.start();
    }  
  }

  public void stop() {
    if(thread != null) {
      stopFlag = true;
    }
  }

  public void run() {
    while((checkImage(image, this) & ImageObserver.ALLBITS) == 0) {
      try { Thread.sleep(600); } catch (InterruptedException e) {}
    }
    finishInit();

    addMouseListener(new MyMouseAdapter());
    addMouseMotionListener(new MyMouseMotionAdapter());

    int last_transition_type = -1;
    BillTransition transition;
    long next_billboard_time;
    while(true) {
      if(stopFlag)
        return;
      next_billboard_time = System.currentTimeMillis() + delay;
      current_billboard = next_billboard;
      if(++next_billboard >= billboards.length) {
        next_billboard = 0;
      }
      if(billboards[next_billboard] == null) {
        parseBillData();
        try { Thread.sleep(120); } catch (InterruptedException e) {}
      }
      int transition_type = (int)(Math.random() * 
                                 (transition_classes.length - 1));
      if(transition_type >= last_transition_type) {
        ++transition_type;
      }
      last_transition_type = transition_type;

      try {
        String trans = transition_classes[last_transition_type];
        transition = (BillTransition)Class.forName(trans)
                                          .newInstance();
      }
      catch(Exception e) {
        e.printStackTrace();
        continue;
      }

      transition.init(this, billboards[current_billboard].image_pixels,
        billboards[next_billboard].image_pixels);

      if(System.currentTimeMillis() < next_billboard_time) {
        try {
          Thread.sleep(next_billboard_time - System.currentTimeMillis());
        } catch (InterruptedException e) { };
      }
      Graphics g = getGraphics();
      for(int c = 0; c < transition.cells.length; ++c) {
        image = transition.cells[c];
        g.drawImage(image, 0, 0, null);
        getToolkit().sync();
        try { Thread.sleep(transition.delay); }  
       catch(InterruptedException e) { };
      }
      image = billboards[next_billboard].image;
      g.drawImage(image, 0, 0, null);
      getToolkit().sync();
      g.dispose();
      if(mouse_inside_applet == true) {
        showStatus(billboards[next_billboard].link.toExternalForm());
      }
      transition = null;
      try { Thread.sleep(120); } catch (InterruptedException e) {}
    }
  }

  public class MyMouseAdapter extends MouseAdapter {
    public void mouseExited(MouseEvent me) {
      mouse_inside_applet = false;
      showStatus("");
    }
    public void mouseReleased(MouseEvent me) {
      stop();
      setCursor(new Cursor(Cursor.WAIT_CURSOR));  
      getAppletContext().showDocument(billboards[current_billboard].link,
                                      link_target_frame);
    }
  }

  public class MyMouseMotionAdapter extends MouseMotionAdapter {
    public void mouseMoved(MouseEvent me) {
      mouse_inside_applet = true;
      showStatus(billboards[current_billboard].link.toExternalForm());
    }
  }
}

listing 2
import java.net.*;
import java.awt.*;
import java.awt.image.*;

public class BillData {
  public URL link;
  public Image image;
  public int[] image_pixels;

  public BillData(URL link, Image image) {
    this.link = link;
    this.image = image;
  }

  public void initPixels(int image_width, int image_height) {
    image_pixels = new int[image_width * image_height];
    PixelGrabber pixel_grabber = new 
    PixelGrabber(image.getSource(), 0, 0,
          image_width, image_height, image_pixels, 0, image_width);
    try {
      pixel_grabber.grabPixels();
    }
    catch (InterruptedException e) {
      image_pixels = null;
    }
  }
}

listing 3
import java.util.*;
import java.awt.*;
import java.awt.image.*;

public abstract class BillTransition {  
  static Hashtable object_table = new Hashtable(20);

  public Image[] cells;
  public int delay;

  Component owner;
  int cell_w;
  int cell_h;
  int pixels_per_cell;
  int[] current_pixels;
  int[] next_pixels;
  int[] work_pixels;

  public abstract void
  init(Component owner, int[] current_pixels, int[] next_pixels);

  final protected void 
  init(Component owner, int[] current_pixels, int[] next_pixels, 
                        int number_of_cells, int delay) {
    this.delay = delay;
    this.next_pixels = next_pixels;
    this.current_pixels = current_pixels;
    this.owner = owner;

    cells = new Image[number_of_cells];
    cell_w = owner.getSize().width;
    cell_h = owner.getSize().height;
    pixels_per_cell = cell_w * cell_h;    
    work_pixels = new int[pixels_per_cell];
  }

  final protected void
  init(Component owner, int[] current_pixels, int[] next_pixels, 
                        int number_of_cells) {
    init(owner, current_pixels, next_pixels, number_of_cells, 120);
  }

  final void createCellFromWorkPixels(int cell) {
    cells[cell] = owner.createImage(
      new MemoryImageSource(cell_w, cell_h,
                            work_pixels, 0, cell_w));
    owner.prepareImage(cells[cell], null);
  }
}

listing 4
import java.awt.*;
import java.awt.image.*;

public class ColumnTransition extends BillTransition {
  final static int CELLS = 7;
  final static int WIDTH_INCREMENT = 3;
  final static int MAX_COLUMN_WIDTH = 24;

  int rightmost_columns_max_width;
  int rightmost_columns_x_start;
  int column_width = WIDTH_INCREMENT;

  public void init(Component owner, int[] current, int[] next) {
    init(owner, current, next, CELLS, 200);

    rightmost_columns_max_width = cell_w % MAX_COLUMN_WIDTH;
    rightmost_columns_x_start = cell_w - rightmost_columns_max_width;

    System.arraycopy(current_pixels, 0,
                     work_pixels, 0, pixels_per_cell);

    for(int c = 0; c < CELLS; ++c) {
      try { Thread.sleep(100); } catch (InterruptedException e) {}
      NextCell();
      try { Thread.sleep(100); } catch (InterruptedException e) {}
      createCellFromWorkPixels(c);
      column_width += WIDTH_INCREMENT;
    }
    work_pixels = null;
  }

  void NextCell() {
    int old_column_width = MAX_COLUMN_WIDTH - column_width;
    for(int p = pixels_per_cell - cell_w; p >= 0; p -= cell_w) {
      for (int x = 0; x < rightmost_columns_x_start; x += 
           MAX_COLUMN_WIDTH) {
        System.arraycopy(next_pixels, x + p, work_pixels,
              old_column_width + x + p, column_width);
      }
      if(old_column_width <= rightmost_columns_max_width) {
        System.arraycopy(next_pixels, rightmost_columns_x_start + p, 
                         work_pixels, rightmost_columns_x_start + 
                                      old_column_width + p - 1,
                                      rightmost_columns_max_width - 
                                      old_column_width + 1);
      }
    }
  }
}

listing 5
import java.awt.*;
import java.awt.image.*;

public class FadeTransition extends BillTransition {
  private static final int CELLS = 7;
  private static final int MULTIPLIER = 0x5D1E2F;

  private static short[][] createRandomArray(int number_pixels, 
                                             int cell_h) {
    int total_cells = CELLS + 1;
    int new_pixels_per_cell = number_pixels / total_cells;
    short[][] random = new short[total_cells][new_pixels_per_cell];
    int random_count[] = new int[total_cells];
    for(int s = 0; s < total_cells; ++s) {
      random_count[s] = 0;
    }

    int cell;
    int rounded_new_pixels_per_cell =
          new_pixels_per_cell * total_cells;

    int seed = (int)System.currentTimeMillis();

    int denominator = 10;
    while((new_pixels_per_cell % denominator > 0 || 
      cell_h % denominator == 0) && denominator > 1) {
      --denominator;
    }

    int new_randoms_per_cell = new_pixels_per_cell / denominator;
    int new_randoms = rounded_new_pixels_per_cell / denominator;

    for(int p = 0; p < new_randoms_per_cell; ++p) {
      seed *= MULTIPLIER;
      cell = (seed >>> 29);
      random[cell][random_count[cell]++] = (short)p;
    }
    seed += 0x5050;
    try { Thread.sleep(150); } catch (InterruptedException e) {}

    for(int p = new_randoms_per_cell; p < new_randoms; ++p) {
      seed *= MULTIPLIER;
      cell = (seed >>> 29);

      while(random_count[cell] >= new_randoms_per_cell) {
        if(++cell >= total_cells) {
          cell = 0;
        }
      }
      random[cell][random_count[cell]++] = (short)p;
    }

    for(int s = 0; s < CELLS; ++s) {

      for(int ps = new_randoms_per_cell; ps < new_pixels_per_cell;
            ps += new_randoms_per_cell) {

        int offset = ps * total_cells;

        for(int p = 0; p < new_randoms_per_cell; ++p) {
          random[s][ps + p] = (short)(random[s][p] + offset);
        }
      }
      try { Thread.sleep(50); } catch (InterruptedException e) {}
    }
    random[CELLS] = null;
    return random;
  }

  public void init(Component owner, int[] current, int[] next) {
    init(owner, current, next, CELLS);
    System.arraycopy(current_pixels, 0, work_pixels, 
                     0, pixels_per_cell);

    short random[][] = (short[][])object_table.get(
            getClass().getName() + pixels_per_cell);

    if(random == null) {
      random = createRandomArray(pixels_per_cell, cell_h);    
      object_table.put(getClass().getName() + pixels_per_cell,
                       random);
    }

    for(int c = 0; c < CELLS; ++c) {
      try { Thread.sleep(100); } catch (InterruptedException e) {}
      int limit = random[c].length;
      for(int p = 0; p < limit; ++p) {
        int pixel_index = random[c][p];
        work_pixels[pixel_index] = next_pixels[pixel_index];
      }
      try { Thread.sleep(50); } catch (InterruptedException e) {}
      createCellFromWorkPixels(c);
    }
    work_pixels = null;
  }
}

listing 6
import java.awt.*;
import java.awt.image.*;

public class SmashTransition extends BillTransition {
  final static int CELLS = 8;
  final static float FOLDS = 8.0f;
  static int[] fill_pixels;

  static void setupFillPixels(int width) {
    if(fill_pixels != null && fill_pixels.length <= width) {
      return;
    }
    fill_pixels = new int[width];
    for(int f = 0; f < width; ++f) {
      fill_pixels[f] = 0xFFFFFFFF;
    }
  }

  int drop_amount;
  int location;

  public void init(Component owner, int[] current, int[] next) {
    init(owner, current, next, CELLS, 160);
    setupFillPixels(cell_w);
    drop_amount =  (cell_h / CELLS) * cell_w;
    location = pixels_per_cell - ((cell_h / CELLS) / 2) * cell_w;
    for(int c = CELLS - 1; c >= 0; --c) {
      try { Thread.sleep(100); } catch (InterruptedException e) {}
      Smash(c + 1);
      try { Thread.sleep(150); } catch (InterruptedException e) {}
      createCellFromWorkPixels(c);
      location -= drop_amount;
    }
    work_pixels = null;
  }

  void Smash(int max_fold) {
    System.arraycopy(next_pixels, pixels_per_cell - location,
                     work_pixels, 0, location);
    int height = cell_h - location / cell_w;
    float fold_offset_adder = (float)max_fold * FOLDS / (float)height;
    float fold_offset = 0.0f;
    int fold_width = cell_w - max_fold;
    float src_y_adder = (float)cell_h / (float)height;
    float src_y_offset = cell_h - src_y_adder / 2;
    for(int p = pixels_per_cell - cell_w; p >= location; p -= 
        cell_w) {
      System.arraycopy(fill_pixels, 0, work_pixels, p, cell_w);
      System.arraycopy(current_pixels, (int)src_y_offset * cell_w,
                       work_pixels, p + (int)fold_offset, fold_width);
      src_y_offset -= src_y_adder;
      fold_offset += fold_offset_adder;
      if(fold_offset < 0.0 || fold_offset >= max_fold) {
        fold_offset_adder *= -1.0f;
      }
    }
  }
}

listing 7
import java.awt.*;
import java.awt.image.*;

public class TearTransition extends BillTransition {
  static final int CELLS = 7;
  static final float INITIAL_X_CROSS = 1.6f;
  static final float X_CROSS_DIVISOR = 3.5f;
  float x_cross;

  public void init(Component owner, int[] current, int[] next) {    
    init(owner, current, next, CELLS);      
    System.arraycopy(next_pixels, 0, work_pixels, 0, pixels_per_cell);
    System.arraycopy(current_pixels, 0, work_pixels, 0, cell_w);

    x_cross = INITIAL_X_CROSS;

    for(int c = CELLS - 1; c >= 0; --c) {
      try { Thread.sleep(100); } catch (InterruptedException e) {}
      Tear();
      try { Thread.sleep(150); } catch (InterruptedException e) {}
      createCellFromWorkPixels(c);
      x_cross /= X_CROSS_DIVISOR;
    }
    work_pixels = null;
  }

  final void Tear() {
    float x_increment;
    int p, height_adder;

    p = height_adder = cell_w;
    for (int y = 1; y < cell_h; ++y) {
      x_increment = x_cross * y;
      if(x_increment >= 0.50f) {
        float fx = 0.0f;
        x_increment += 1.0f;
        int x = 0;
        do {
          work_pixels[p++] = current_pixels[height_adder + x];
          x = (int)(fx += x_increment);
        } while(x < cell_w);
      }
      else {
        float overflow = 1.0f / x_increment;
        float dst_end = overflow / 2.0f  + 1.49999999f;
        int dst_start = 0, src_offset = 0, length = (int)dst_end;
        while(dst_start + src_offset + length < cell_w) {
          System.arraycopy(current_pixels, p + src_offset, 
                           work_pixels, p, length);
          ++src_offset;
          dst_end += overflow;
          p += length;
          dst_start += length;
          length = (int)dst_end - dst_start;
        }
        length = cell_w - src_offset - dst_start;
        System.arraycopy(current_pixels, p + src_offset, 
                         work_pixels, p, length);
      }
      p = height_adder += cell_w;
    }
  }
}

listing 8
import java.awt.*;
import java.awt.image.*;

public class UnrollTransition extends BillTransition {
  final static int CELLS = 9;
  static int fill_pixels[] = { 0xFFFFFFFF, 0xFF000000, 
                               0xFF000000, 0xFFFFFFFF };

  private static int[] createUnrollAmountArray(int cell_h) {
    float unroll_increment = 
      ((float)cell_h / (float)(CELLS + 1)) /
      ((float)(CELLS + 2) / 2.0f);

    int total = 0;
    int unroll_amount[] = new int[CELLS + 1];
    for(int u = 0; u <= CELLS; ++u) {
      unroll_amount[u] = (int)(unroll_increment * (CELLS - u + 1));
      total += unroll_amount[u];
    }
    if(total < 0) {
      unroll_amount[0] -= 1;
    }
    return unroll_amount;
  }

  int location;
  int[] unroll_amount;

  public void init(Component owner, int[] current, int[] next) {
    init(owner, current, next, CELLS, 220);
    location = pixels_per_cell;
    System.arraycopy(current_pixels, 0,
                     work_pixels, 0, pixels_per_cell);
    unroll_amount = (int[])object_table.get(getClass().getName() + 
                     cell_h);
    if(unroll_amount == null) {
      unroll_amount = createUnrollAmountArray(cell_h);
      object_table.put(getClass().getName() + cell_h, unroll_amount);
    }

    for(int c = 0; c < CELLS; ++c) {
      location -= unroll_amount[c] * cell_w;
      try { Thread.sleep(150); } catch (InterruptedException e) {}
      Unroll(c);
      try { Thread.sleep(100); } catch (InterruptedException e) {}
      createCellFromWorkPixels(c);
      System.arraycopy(next_pixels, location,
                       work_pixels, location, 
                       unroll_amount[c] * cell_w);
    }
    work_pixels = null;
  }

  void Unroll(int c) {
    int y_flip = cell_w;
    int offset[] = new int[unroll_amount[c]];
    for(int o = 0; o < unroll_amount[c]; ++o) {
      offset[o] = 4;
    }
    offset[0] = 2;

    if(unroll_amount[c] > 1) {
      offset[1] = 3;
    }
    if(unroll_amount[c] > 2) {
      offset[unroll_amount[c] - 1] = 2;
    }
    if(unroll_amount[c] > 3) {
      offset[unroll_amount[c] - 2] = 3;
    }

    int offset_index = 0;
    int end_location = location + unroll_amount[c] * cell_w;
    for(int p = location; p < end_location; p += cell_w) {

      System.arraycopy(next_pixels, 
                       p - y_flip + offset[offset_index], 
                       work_pixels,
                       p, cell_w - offset[offset_index]);

      System.arraycopy(fill_pixels, 0,
                       work_pixels,
                       p + cell_w - offset[offset_index], 
                       offset[offset_index]);

      ++offset_index;
      y_flip += cell_w + cell_w;
    }

    for(int x = location + cell_w - 1; x > location; --x) {
      work_pixels[x] |= 0xFFAAAAAA;
      work_pixels[x + unroll_amount[c]] &= 0xFF555555;
    }
  }
}


 
 /**************** 
 * Chapter  30  *
 ****************/
 
listing 1
<applet code="ImageMenu" width=140 height=180 hspace=0 vspace=0>
<param name="img" value="menu.jpg">
<param name="urlPrefix"
           value="http://www.osborne.com/">
<param name="urlList"
           value="pressroom/pressroom.shtml+aboutus/aboutus.shtml+downloads/downloads.shtml+errata/errata.shtml">
<param name="targetList"
           value="_self+_self+_self+_self+_self+_self">
<param name="urlSuffix" value="">
</applet>

listing 2
import java.awt.* ;
import java.awt.event.*;
import java.applet.*;
import java.util.*;
import java.net.*;

public class ImageMenu extends Applet {
  Dimension d;

  Image img, off;
  Graphics offg;
  int MAXITEMS = 64;
  String url[] = new String[MAXITEMS];
  String target[] = new String[MAXITEMS];
  String urlPrefix, urlSuffix;
  int selectedCell = -1;
  int oldCell = -1;
  int cellH;
  int cells;

  public void init() {
    d = getSize();
    urlPrefix = getParameter("urlPrefix");
    urlSuffix = getParameter("urlSuffix");
    StringTokenizer st;
    st = new StringTokenizer(getParameter("urlList"), "+");
    int i=0;
    while(st.hasMoreTokens() && i < MAXITEMS)
        url[i++] = st.nextToken();
    cells = i;
    cellH = d.height/cells;
    st = new StringTokenizer(getParameter("targetList"), "+");
    i=0;
    while(st.hasMoreTokens() && i < MAXITEMS)
      target[i++] = st.nextToken();
    addMouseListener(new MyMouseAdapter());
    addMouseMotionListener(new MyMouseMotionAdapter());
  }

  private void lateInit() {
    off = createImage(d.width, d.height);
    try {
      img = getImage(getDocumentBase(), getParameter("img"));
      MediaTracker t = new MediaTracker(this);
      t.addImage(img, 0);
      t.waitForID(0);
    } catch(Exception e) {
      showStatus("error: " + e);
    }
  }

  public void update(Graphics g) {}
  public void paint(Graphics g) {
    if(off == null)
      lateInit();

    offg = off.getGraphics();
    offg.drawImage(img, 0, 0, this);
    if (selectedCell >= 0) {
      offg.clipRect(0, selectedCell * cellH, d.width, cellH);
      offg.drawImage(img, -d.width, 0, this);
    }
    g.drawImage(off, 0, 0, this);
  }

  class MyMouseMotionAdapter extends MouseMotionAdapter {
    public void mouseDragged(MouseEvent me) {
      mouseMoved(me);
    }
    public void mouseMoved(MouseEvent me) {
      int y = me.getY();
      selectedCell = (int)(y/(double)d.height*cells);
      if (selectedCell != oldCell) {
        paint(getGraphics());
        showStatus(urlPrefix + url[selectedCell] + urlSuffix);
        oldCell = selectedCell;
      }
    }
  }

  class MyMouseAdapter extends MouseAdapter {
    public void mouseExited(MouseEvent me) {
      selectedCell = oldCell = -1;
      paint(getGraphics());
      showStatus("");
    }

    public void mouseReleased(MouseEvent me) {
      //mouseMoved(me);
      URL u = null;
      try {
        u = new URL(urlPrefix + url[selectedCell] + urlSuffix);
      } catch(Exception e) {
        showStatus("error: " + e);
      }
      if (me.isShiftDown())
        getAppletContext().showDocument(u, "_blank");
      else
        getAppletContext().showDocument(u, target[selectedCell]);
    }
  }
}

 
 
 /**************** 
 * Chapter   31 *
 ****************/
 
listing 1
<applet code=Lavatron.class width=560 height=128>
<param name="img" value="swsm.jpg">
</applet>

listing 2
import java.applet.*;
import java.awt.* ;
import java.awt.image.* ;

public class Lavatron extends Applet implements Runnable {
  int scrollX;
  int bulbsW, bulbsH;
  int bulbS = 8;
  Dimension d;
  Image offscreen, bulb, img;
  Graphics offgraphics;
  int pixels[];
  int pixscan;
  IntHash clut = new IntHash();
  boolean stopFlag;

  public void init() {
    d = getSize();
    int offw = (int) Math.ceil(d.width/bulbS) * bulbS;
    int offh = (int) Math.ceil(d.height/bulbS) * bulbS;
    offscreen = createImage(offw, offh);
    offgraphics = offscreen.getGraphics();
    bulbsW = offw/bulbS;
    bulbsH = offh/bulbS;

    bulb = createBulbs(bulbS, bulbsH*bulbS);
    try {
      img = getImage(getDocumentBase(), getParameter("img"));
      MediaTracker t = new MediaTracker(this);
      t.addImage(img, 0);
      t.waitForID(0);
      pixscan = img.getWidth(null);
      int h = img.getHeight(null);
      pixels = new int[pixscan * h];
      PixelGrabber pg = new PixelGrabber(img, 0, 0, pixscan, h,
                                         pixels, 0, pixscan);
      pg.grabPixels();
    } catch (InterruptedException e) { };
    scrollX = 0;
    // paint black bulbs on the offscreen image
    offgraphics.setColor(Color.black);
    offgraphics.fillRect(0, 0, d.width, d.height);
    for (int x=0; x<bulbsW; x++)
      offgraphics.drawImage(bulb, x*bulbS, 0, null);
  }

  Image createBulbs(int w, int h) {
    int pixels[] = new int[w*h];
    int bulbBits[] = {
      0,0,1,1,1,1,0,0,
      0,1,2,1,1,1,1,0,
      1,2,1,1,1,1,1,1,
      1,1,1,1,1,1,1,1,
      1,1,1,1,1,1,1,1,
      1,1,1,1,1,1,1,1,
      0,1,1,1,1,1,1,0,
      0,0,1,1,1,1,0,0
    };
    int bulbCLUT[] = { 0xff000000, 0x00c0c0c0, 0xffffffff };
    for (int i=0; i<w*h; i++)
      pixels[i] = bulbCLUT[bulbBits[i%bulbBits.length]];
    return createImage(new MemoryImageSource(w, h, pixels, 0, w));
  }

  public final Color color(int x, int y) {
    int p = pixels[y*pixscan+x];
    Color c;
    if ((c=(Color)clut.get(p)) == null)
      clut.put(p, c = new Color(p));
    return c;
  }

  public void update() {}

  public void paint(Graphics g) {
    offgraphics.copyArea(bulbS, 0, bulbsW*bulbS-bulbS, d.height,
                        -bulbS, 0);
    for (int y=0; y<bulbsH; y++) {
      offgraphics.setColor(color(scrollX, y));
      offgraphics.fillRect(d.width-bulbS, y*bulbS, bulbS, bulbS);
    }
    offgraphics.drawImage(bulb, d.width-bulbS, 0, null);
    g.drawImage(offscreen, 0, 0, null);
    scrollX = (scrollX + 1) % pixscan;
  }

  Thread t;
  public void run() {
    while (true) {
      paint(getGraphics());
      try{t.yield();} catch(Exception e) { };
      if(stopFlag)
        break;
    }
  }

  public void start() {
    t = new Thread(this);
    t.setPriority(Thread.MIN_PRIORITY);
    stopFlag = false;
    t.start();
  }

  public void stop() {
    stopFlag = true;
  }
}

listing 3
class IntHash {
  private int capacity;
  private int size;
  private float load = 0.7F;
  private int keys[];
  private Object vals[];

  public IntHash(int n) {
    capacity = n;
    size = 0;
    keys = new int[n];
    vals = new Object[n];
  }

  public IntHash() {
    this(101);

  }

  private void rehash() {
    int newcapacity = capacity * 2 + 1;
    Object newvals[] = new Object[newcapacity];
    int newkeys[] = new int[newcapacity];
    for (int i = 0; i < capacity; i++) {
      Object o = vals[i];
      if (o != null) {
        int k = keys[i];
        int newi = (k & 0x7fffffff) % newcapacity;
        while (newvals[newi] != null)
          newi = (newi + 1) % newcapacity;
        newkeys[newi] = k;
        newvals[newi] = o;
      }
    }
    capacity = newcapacity;
    keys = newkeys;
    vals = newvals;
  }

  public void put(int k, Object o) {
    int i = (k & 0x7fffffff) % capacity;
    while (vals[i] != null && k != keys[i]) // hash collision.
      i = (i + 1) % capacity;
    if (vals[i] == null)
      size++;
    keys[i] = k;
    vals[i] = o;
    if (size > (int)(capacity * load))
      rehash();
  }

  public final Object get(int k) {
    int i = (k & 0x7fffffff) % capacity;
    while (vals[i] != null && k != keys[i]) // hash miss
      i = (i + 1) % capacity;
    return vals[i];
  }

  public final boolean contains(int k) {
    return get(k)!=null;
  }

  public int size() {
    return size;
  }

  public int capacity() {
    return capacity;
  }
}


 //::~
