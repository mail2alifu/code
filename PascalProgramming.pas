PASCAL Programming Fundamentals
P. S. Grover
ISBN 81-7764-193-X
ALLIED PUBLISHERS LIMITED
(c) P. S. Grover, 1988. 8th Reprint, 2001.

CONTENTS

PREFACE
CHAPTER  1  INTRODUCTION
CHAPTER  2  PROBLEM SOLVING AND PASCAL
CHAPTER  3  ELEMENTARY CONCEPTS AND PRIMITIVE DATA TYPES
CHAPTER  4  EXPRESSIONS
CHAPTER  5  SIMPLE STATEMENTS AND PROGRAMS
CHAPTER  6  ENUMERATED AND SUBRANGE DATA TYPES
CHAPTER  7  PROGRAM EXECUTION CONTROL
CHAPTER  8  REPETITIVE COMPUTATIONS
CHAPTER  9  STRUCTURED DATA TYPE: ARRAYS
CHAPTER 10  SUBPROGRAMS: FUNCTIONS AND PROCEDURES
CHAPTER 11  RECORD DATA TYPES
CHAPTER 12  FILE TYPES
CHAPTER 13  SET OPERATIONS AND DATA TYPES
CHAPTER 14  POINTERS AND DYNAMIC DATA STRUCTURES
CHAPTER 15  STRUCTURED PROGRAM DESIGN CONCEPTS
APPENDIX   I: PASCAL OPERATORS AND THEIR PRECEDENCE
APPENDIX  II: STANDARD IDENTIFIERS AND PASCAL RESERVED WORDS
APPENDIX III: PASCAL SUPPLIED FUNCTIONS AND PROCEDURES
APPENDIX  IV: SYNTAX OF PASCAL
APPENDIX   V: SYNTAX DIAGRAMS
APPENDIX  VI: ASCII & EBCDIC CHARACTER SETS
BIBLIOGRAPHY
INDEX
{* ///::<+>::\\\ *}

PASCAL PROGRAMMING
P. RADHA GANESHAN
ISBN 81-224-1096-0
NEW AGE INTERNATIONAL(P) LIMITED, PUBLISHERS
Copywright(c) 1997, Reprint 1999

[CONTENTS]
PREFACE
ACKNOWLADGEMENT
CHAPTER  1  INTRODUCTION
CHAPTER  2  FUNDAMENTALS OF PASCAL
CHAPTER  3  INPUT OUTPUT STATEMENTS
CHAPTER  4  CONTROL STATEMENTS
CHAPTER  5  ARRAYS
CHAPTER  6  PROCEDURES AND FUNCTIONS
CHAPTER  7  RECORDS
CHAPTER  8  FILES
CHAPTER  9  USER DEFINED DATA TYPES, SETS AND UNITS
CHAPTER 10  POINTERS
CHAPTER 11  GRAPHICS
CHAPTER 12  AN INTRODUCTION TO OBJECT ORIENTED PROGRAMMING
APPENDIX A  RESERVED WORDS
APPENDIX B  PREDEFINED IDENTIFIERS
BIBLIOGRAPHY
INDEX

{* ::\\\~ *}
{* ///::~::\\\ *}
{* ::\\\~///:: *}

SCHAUM'S OUTLINE SERIES
THEORY AND PROBLEMS OF
PROGRAMMING with PASCAL
BYRON S. GOTTFRIED

INCLUDING 391 SOLVED PROBLEMS AND
35 COMPLETE PROGRAMMING EXAMPLES

SCHAUM'S OUTLINE SERIES IN COMPUTERS
McGRAW HILL BOOK COMPANY

CONTENT

Chapter  1    INTRODUCTORY CONCEPTS
Chapter  2    PASCAL FUNDAMENTALS
Chapter  3    SCALAR-TYPE DATA
Chapter  4    DATA INPUT AND OUTPUT
Chapter  5    CREATING AND RUNNING A PASCAL PROGRAMMING
Chapter  6    CONTROL STRUCTURES
Chapter  7    PROCEDURES AND FUNCTIONS
Chapter  8    USER-DEFINED SIMPLE-TYPE DATA
Chapter  9    ARRAYS
Chapter 10    RECORDS
Chapter 11    FILES
Chapter 12    SETS
Chapter 13    LISTS AND POINTERS
Appendix A    RESERVED WORDS
Appendix B    STANDARD IDENTIFIERS
Appendix C    STANDARD PROCEDURES
Appendix D    STANDARD FUNCTIONS
Appendix E    OPERATORS
Appendix F    DATA TYPES
Appendix G    CONTROL STRUCTURES
Appendix H    THE ASCII CHARACTER SET
ANSWER TO SELECTED PROBLEMS
INDEX

[CONTENT]

Chapter  1    INTRODUCTORY CONCEPTS
Chapter  2    PASCAL FUNDAMENTALS
Chapter  3    SCALAR-TYPE DATA
Chapter  4    DATA INPUT AND OUTPUT
Chapter  5    CREATING AND RUNNING A PASCAL PROGRAMMING
Chapter  6    CONTROL STRUCTURES
Chapter  7    PROCEDURES AND FUNCTIONS
Chapter  8    USER-DEFINED SIMPLE-TYPE DATA
Chapter  9    ARRAYS
Chapter 10    RECORDS
Chapter 11    FILES
Chapter 12    SETS
Chapter 13    LISTS AND POINTERS
Appendix A    RESERVED WORDS
Appendix B    STANDARD IDENTIFIERS
Appendix C    STANDARD PROCEDURES
Appendix D    STANDARD FUNCTIONS
Appendix E    OPERATORS
Appendix F    DATA TYPES
Appendix G    CONTROL STRUCTURES
Appendix H    THE ASCII CHARACTER SET
ANSWER TO SELECTED PROBLEMS
INDEX


{::\\\~}

Complete Programming Examples

  1. Area of a Circle - Examples 1.6 - 
  2. Roots of Quadratic Equations 
  3. Finding a Palindrom
  4. Averaging a list of Numbers
  5. Repeated Averaging of a List of Numbers
  6. 
  7. 
  8. Solution of an Algebraic Equation
  9. Calculating Depriciations
 10. Averageing a List of Nonnegetive Numbers
 11. Maximum of Three Inegers
 12. Search for a Minimum
 13. Calculating Factorials
 16. The Tower of Hanoi
 20. Names and Address
 21. Table Multiplication
 22. Adding Two Table of Salary
 23. A Piglatin Generator
 24. A Customer Billing System
 25. Inventory Control
 26. Creating a File of Customer Records
 28. Reading a File of Customer Records
 30. Copying a File
 31. Appending a File
 32. Displaying a File
 33. Displaying a Customer Billing System
 41. 
{\\\::~}

Problem Solving and Structured Programming in Pascal
Second Edition, December 1984
Elliot B. Koffman
ISBN 0-201-11736-3
ISBN 0-201-21450-4 School
June  1985

[CONTENTS]

Chapter  1  Introduction to Computer and Programming    1
Chapter  2  Problem Solving    45
Chapter  3  Control Statements    95
Chapter  4  Simple Data Types    159
Chapter  5  More Control Statements    217
Chapter  6  Arrays    263
Chapter  7  Records    325
Chapter  9  Recursion, Searching and Sorting    425
Chapter 10  Pointer Variables and Dynamic Data Structures    475
Appendix  A:  Reserved Words, Standard Identifiers, Operators, Functions and Procedures  Ap-1
Appendix  B:  Additions and Extensions to Pascal  A5-5
Appendix  C:  Pascal Syntax Diagrams  Ap19
Appendix  D:  Character Sets  Ap-29
Appendix  E:  Error Number Summary  Ap-31
Answer to Selected Exercises  Ans-1
Index  I-1


[CONTENTS]

Chapter  1  Introduction to Computer and Programming    1

            1.1  Electronic Computers Then and Now 2
            1.2  Components of a Computer 3
            1.3  Problem Solving and Programming 6
            1.4  Programming Languages 7
            1.5  Processing a High-level Language Program 9
            1.6  Introduction to Pascal 11
            1.7  General Form of a Pascal Program 22
            1.8  Using the Computer 26
            1.9  Formatting Program Output 29
            1.10 Introduction to Data Types 34
            1.11 Common Programming Errors 36
            1.12 Chapter Review 39

Chapter  2  Problem Solving    45

            2.1  Representing and Refining Algorithms 46
            2.2  Using Procedures for Subproblems 52
            2.3  Decision Steps in Algorithms 59
            2.4  Tracing a Program or Algorithm 67
            2.5  Problem Solving Strategies 69
            2.6  Repetition in Programs 72
            2.7  Generalizing a Solution 79
            2.8  Repeating a Program Body 83
            2.9  Debugging and Testing Programs 87
            2.10 Common Programming Errors 88
            2.11 Chapter Review 89

Chapter  3  Control Statements    95

            3.1  Syntax Diagrams 96
            3.2  The if Statement Revisited 97
            3.3  The while Statement 104
            3.4  Procedure Parameters 111
            3.5  Adding Data Flow Information to Structure Charts 128
            3.6  Nested Procedures and Scope of Identifiers 132
            3.7  Case Studies 136
            3.8  Debugging a Program System 150
            3.9  Common Programming Errors 151
            3.10 Chapter Review 152

Chapter  4  Simple Data Types    159

            4.1  Constant Declarations Types 160
            4.2  Numeric Data Types-REAL and INTEGER 161
            4.3  Functions in Arithmetic Expressions 169
            4.4  BOOLEAN Variables, Expressions, and Operators 175
            4.5  Character Variables and Functions 180
            4.6  Introduction to Programmer-defined Data Types 188
            4.7  Input or Output Revisited 193
            4.8  Case Study 201
            4.9  Common Programming Errors 206
            4.10 Chapter Review 207

Chapter  5  More Control Statements    217

            5.1  The case Statement  218
            5.2  Set Values in Decisions 221
            5.3  The General for Statement 223
            5.4  The repeat Statement 225
            5.5  Nested Loops 229
            5.6  User-defined Functions 234
            5.7  Case Studies 240
            5.8  Common Programming Errors 251
            5.9  Chapter Review 252

Chapter  6  Arrays    263

            6.1  Declaring and Referencing Arrays 264
            6.2  Arrays with Integer Subscripts 266
            6.3  Case Study 270
            6.4  Manipulating Entire Arrays 276
            6.5  Reading Part of an Array 282
            6.6  General Arrays 283
            6.7  Character Strings 288
            6.8  Multidimensional Arrays 295
            6.9  Case Study 302
            6.10 Common Programming Errors 313
            6.11 Chapter Review 313

Chapter  7  Records    325

            7.1  Declaring a Record 326
            7.2  Manipulating Individual Fields of a Record 328
            7.3  Manipulating an Entire Record 331
            7.4  Arrays of Records 334
            7.5  Case Study 335
            7.6  Searching an Array 342
            7.7  Sorting an Array 344
            7.8  General Data Structures 348
            7.9  Record Variants 352
            7.10 Manipulating Strings Stored in Records 357
            7.11 Common Programming Errors 363
            7.12 Chapter Review 364

Chapter  8  Sets and Files    371

            8.1  Sets Data Type and Set Operators 372
            8.2  RESET, REWRITE, and the File Position Pointer 379
            8.3  TEXT Files 381
            8.4  Case Studies 385
            8.5  User-defined File Types 396
            8.6  Case Study-File Merge 401
            8.7  Case Study-Data Base Inquiry 405
            8.8  File Buffer Variable 411
            8.9  Common Programming Errors 416
            8.10 Chapter Review 417

Chapter  9  Recursion, Searching and Sorting    425

            9.1  The Nature of Recursion 426
            9.2  Recursive Procedures 432
            9.3  Recursive Functions 439
            9.4  Binary Search of an Array 449
            9.5  Searching by Hashing 453
            9.6  Additional Sorting Algorithms 457
            9.7  Case Study-The Quicksort Algorithm 462
            9.8  Common Programming Errors 467
            9.9  Chapter Review 468

Chapter 10  Pointer Variables and Dynamic Data Structures    475

            10.1  The Variables NEW Statement and and ointer Variables 476
            10.2  Understanding Dynamic Allocation 480
            10.3  Introduction to Linked Lists 481
            10.4  Manipulating Linked Lists Using Pointer Variables 483
            10.5  Case Study-Maintaining a Linked List 487
            10.6  Stacks and Queues 500
            10.7  Multiple-linked Lists and Trees 506
            10.8  Case Study-Maintaining a Binary Search Tree 511
            10.9  Common Programming Errors 518
            10.10 Chapter Review 519

Appendix  A:  Reserved Words, Standard Identifiers, Operators, Functions and Procedures  Ap-1
Appendix  B:  Additions and Extensions to Pascal  A5-5
              B.1  Additional Features of ANSI/IEEE Pascal
              B.2  ISO Pascal
              B.3  USCD Pascal
              B.4  TURBO Pascal
Appendix  C:  Pascal Syntax Diagrams  Ap19
Appendix  D:  Character Sets  Ap-29
Appendix  E:  Error Number Summary  Ap-31
Answer to Selected Exercises  Ans-1
Index  I-1

[Contents]

CHAPTER  1  Introduction to Computers and Programming
1.1  Electronic Computers Then and Now 2
1.2  Components of a Computer 3
1.3  Problem Solving and Programming 6
1.4  Programming Languages 7
1.5  Processing a High-level Language Program
1.6  Introduction to Pascal 11
1.7  General Form of a Pascal Program 22
1.8  Using the Computer 26
1.9  Formatting Program Output 29
1.10 Introduction to Data Types 34
1.11 Common Programming Errors 36
1.12 Chapter Review 39

CHAPTER  2 Electronic Computers Then and Now 2
2.1  Representing and Refining Algorithms 46
2.2  Using Procedures for Subproblems 52
2.3  Decision Steps in Algorithms 59
2.4  Tracing a Program or Algorithm 67
2.5  Problem Solving Strategies 69
2.6  Repetition in Programs 72
2.7  Generalizing a Solution 79
2.8  Repeating a Program Body 83
2.9  Debugging and Testing Programs 87
2.10 Common Programming Errors 88
2.11 Chapter Review 89

CHAPTER  3  Control Statements 95
3.1  Syntax Diagrams 96
3.2  The if Statement Revisited 97
3.3  The while Statement 104
3.4  Procedure Parameters 111
3.5  Adding Data Flow Information to Structure Charts 128
3.6  Nested Procedures and Scope of Identifiers 132
3.7  Case Studies 136
3.8  Debugging a Program System 150
3.9  Common Programming Errors 151
3.10 Chapter Review 152

CHAPTER 4 Simple Data Types 159
4.1  Constant Declarations 160
4.2  Numeric Data Types-REAL and INTEGER 161
4.3  Functions in Arithmetic Expressions 169
4.4  BOOLEAN Variables, Expressions, and Operators 175
4.5  Character Variables and Functions 180
4.6  Introduction to Programmer-defined Data Types 188
4.7  Input/Output Revisited 193
4.8  Case Study 201
4.9  Common Programming Errors 206
4.10 Chapter Review 207

CHAPTER 5 More Control Statement 217
5.1  The case Statements 218
5.2  Set Values in Decisions 221
5.3  The General for Statement 223
5.4  The repeat Statement 225
5.5  Nested Loops 229
5.6  User-defined Functions 234
5.7  Case Studies 240
5.8  Common Programming Errors 251
5.9  Chapter Review 252

CHAPTER 6 Arrays 263
6.1  Declaring  and  Referencing Arrays 264
6.2  Arrays with Integer Subscripts 266
6.3  Case Study 270
6.4  Manipulating Entire Arrays 276
6.5  Reading Part of an Array 282
6.6  General Arrays 283
6.7  Character Strings 288
6.8  Multidimensional Arrays 295
6.9  Case Study 302
6.10 Common Programming Errors 313
6.11 Chapter Review 313

CHAPTER 7 Records 325
7.1  Declaring a Record 326
7.2  Manipulating Individual Fields of a Record 328
7.3  Manipulating an Entire Record 331
7.4  Arrays of Records 334
7.5  Case Study 335
7.6  Searching an Array 342
7.7  Sorting an Array 344
7.8  General Data Structures 348
7.9  Record Variants 352
7.10 Manipulating Strings Stored in Records 357
7.11 Common Programming Errors 363
7.12 Chapter Review 364

CHAPTER 8 Sets and Files 371
8.1  Set Data Type and Set Operators 372
8.2  RESET, REWRITE, and the File Position Pointer 379
8.3  TEXT Files 381
8.4  Case Studies 385
8.5  User-defined File Types 396
8.6  Case Study-File Merge 401
8.7  Case Study-Data Base Inquiry 405
8.8  File Buffer Variable 411
8.9  Common Programming Errors 416
8.10 Chapter Review 417

CHAPTER 9 Recursion, Searching, and Sorting 425
9.1  The Nature of Recursion  426
9.2  Recursive Procedures 432
9.3  Recursive Functions 439
9.4  Binary Search of an Array 449
9.5  Searching by Hashing 453
9.6  Additional Sorting Algorithms 457
9.7  Case Study-The Quicksort Algorithm 462
9.8  Common Programming Errors 467
9.9  Chapter Review 468

CHAPTER 10 Pointer Variables and Dynamic Data Structures 475
10.1  The NEW Statement and Pointer Variables 476
10.2  Understanding Dynamic Allocation 480
10.3  Introduction to Linked Lists 481
10.4  Manipulating Linked Lists Using Pointer Variables 483
10.5  Case Study-Maintaining a Linked List 487
10.6  Stacks and Queues 500
10.7  Multiple-linked Lists and Trees 506
10.8  Case Study-Maintaining a Binary Search Tree 511
10.9  Common Programming Errors 518
10.10 Chapter Review 519

Appendix A: Reserved Words, Identifiers, Operators, Functions, Standard and Procedures Ap-1
Appendix B: Additions and Extensions to Pascal Ap-5
B.1 Additional Features of ANSI/IEEE Pascal
B.2 ISO Pascal
B.3 UCSD Pascal
B.4 TURBO Pascal
Appendix C: Pascal Syntax Diagrams Ap-19
Appendix D: Character Sets Ap-29
Appendix E: Error Number Summary Ap-31
Answers to Selected Exercises Ans-1
Index I-1

 ===============================
 = HOW TO SOLVE IT BY COMPUTER =
 ===============================
How to Solve It by Computer by R. G. Dromey PDF
Name: How to Solve It by Computer: Prentice-Hall International Series in Computer Science
Authors: R. G. Dromey
Publish Date: July 1, 1982
Language: English
Genre: Software Development
Format: PDF
Size:
Pages: 442
Price: Paperback $30.25, 4 Used from $30.81, 6 New from $26.72
ISBN: 0134340019

[CONTENTS]

   PREFACE                                  xiii
   ACKNOWLEDGEMENTS                          xxi
1  INTRODUCTION TO COMPUTER PROBLEM-SOLVING    1
2  FUNDAMENTAL ALGORITHMS                     42
3  FACTORING METHODS                          85
4  ARRAY TECHNIQUES                          139
5  MERGING, SORTING AND SEARCHING            181
6  TEXT PROCESSING AND PATTERN SEARCHING     248
7  DYNAMIC DATA STRUCTURE ALGORITHMS         304
8  RECURSIVE ALGORITHMS                      367
   INDEX                                     435


[Table of Content]

   PREFACE      xiii
   ACKNOWLEDGEMENTS      xxi
1  INTRODUCTION TO COMPUTER PROBLEM-SOLVING    1
   1.1  Introduction    1
   1.2  The Problem-solving Aspect    3
   1.3  Top-down Design    7
   1.4  Implementation of Algorithms    14
   1.5  Program Verification    19
   1.6  The Efficiency of Algorithms    29
   1.7  The Analysis of Algorithms    33
   Bibliography    39
   
2  FUNDAMENTAL ALGORITHMS    42
   Introduction    42
   Algorithm 2.1  Exchanging the Values of Two Variables    43
   Algorithm 2.2  Counting    47
   Algorithm 2.3  Summation of a Set of Numbers    51
   Algorithm 2.4  Factorial Computation    56
   Algorithm 2.5  Sine Function Computation    60
   Algorithm 2.6  Generation of the Fibonacci Sequence    64
   Algorithm 2.7  Reversing the Digits of an Integer    69
   Algorithm 2.8  Base Conversion    74
   Algorithm 2.9  Character to Number Conversion  80
   Bibliography    84
   
3  FACTORING METHODS    85
   Introduction    85
   Algorithm 3.1  Finding the Squar Root of a Number    86
   Algorithm 3.2  The Smallest Divisor of an Integer    92
   Algorithm 3.3  The Greatest Common Divisor of Two Integers    97
   Algorithm 3.4  Generating Prime Numbers    105
   Algorithm 3.5  Computing the Prime Factors of an Integer    116
   Algorithm 3.6  Generation of Pseudo-random Numbers    124
   Algorithm 3.7  Raising a Number to a Large Power    124
   Algorithm 3.8  Computing the nth Fibonacci Number    132
   Bibliography    138
   
4  ARRAY TECHNIQUES    139
   Introduction    139
   Algorithm 4.1  Array Order Reversal    140
   Algorithm 4.2  Array Counting or Histogramming    144
   Algorithm 4.3  Finding the Maximum Number in a Set    147
   Algorithm 4.4  Removal of Duplicates from an Ordered Array    152
   Algorithm 4.5  Partitioning an Array    156
   Algorithm 4.6  Finding the kth Smallest Element    166
   Algorithm 4.7  Longest Monotone Subsequence    174
   Bibliography    180
   
5  MERGING, SORTING AND SEARCHING    181
   Introduction    181
   Algorithm 5.1  The Two-way Merge    182
   Algorithm 5.2  Sorting by Selection    192
   Algorithm 5.3  Sorting by Exchange    192
   Algorithm 5.4  Sorting by Insertion    204
   Algorithm 5.5  Sorting by Diminishing Increment    209
   Algorithm 5.6  Sorting by Partitioning    216
   Algorithm 5.7  Binary Search    227
   Algorithm 5.8  Hash Searching  237
   Bibliography    246
   
6  TEXT PROCESSING AND PATTERN SEARCHING    248
   Introduction    248
   Algorithm 6.1  Text Line Length Adjustment    249
   Algorithm 6.2  Left and Right Justification in Text    256
   Algorithm 6.3  Keyword Searching in Text    267
   Algorithm 6.4  Text Line Editing    274
   Algorithm 6.5  Linear Pattern Search    282
   Algorithm 6.6  Sublinear Pattern Search    293
   Bibliography    303
   
7  DYNAMIC DATA STRUCTURE ALGORITHMS  304
   Introduction    304
   Algorithm 7.1  Stack Operations    306
   Algorithm 7.2  Queue Addition and Deletion    314
   Algorithm 7.3  Linked List Search    325
   Algorithm 7.4  Linked List Insertion and Deletion    331
   Algorithm 7.5  Binary Tree Search    342
   Algorithm 7.6  Binary Tree Insertion and Deletion    349
   Bibliography    366

8  RECURSIVE ALGORITHMS   367
   Introduction    367
   Algorithm 8.1  Binary Tree Traversal    373
   Algorithm 8.2  Recursive Quick sort    383
   Algorithm 8.3  Towers of Hanoi Problem    391
   Algorithm 8.4  Sample Generation    414
   Algorithm 8.5  Combination Generation    414
   Algorithm 8.6  Permutation Generation    422
   Bibliography    433
   
INDEX    435

   =================================================================
   [ 50 ALGORITHMS ]
   =================================================================
   Algorithm 2.1  Exchanging the Values of Two Variables          43
   Algorithm 2.2  Counting                                        47
   Algorithm 2.3  Summation of a Set of Numbers                   51
   Algorithm 2.4  Factorial Computation                           56
   Algorithm 2.5  Sine Function Computation                       60
   Algorithm 2.6  Generation of the Fibonacci Sequence            64
   Algorithm 2.7  Reversing the Digits of an Integer              69
   Algorithm 2.8  Base Conversion                                 74
   Algorithm 2.9  Character to Number Conversion                  80
   Algorithm 3.1  Finding the Squar Root of a Number              86
   Algorithm 3.2  The Smallest Divisor of an Integer              92
   Algorithm 3.3  The Greatest Common Divisor of Two Integers     97
   Algorithm 3.4  Generating Prime Numbers                       105
   Algorithm 3.5  Computing the Prime Factors of an Integer      116
   Algorithm 3.6  Generation of Pseudo-random Numbers            124
   Algorithm 3.7  Raising a Number to a Large Power              124
   Algorithm 3.8  Computing the nth Fibonacci Number             132
   Algorithm 4.1  Array Order Reversal                           140
   Algorithm 4.2  Array Counting or Histogramming                144
   Algorithm 4.3  Finding the Maximum Number in a Set            147
   Algorithm 4.4  Removal of Duplicates from an Ordered Array    152
   Algorithm 4.5  Partitioning an Array                          156
   Algorithm 4.6  Finding the kth Smallest Element               166
   Algorithm 4.7  Longest Monotone Subsequence                   174
   Algorithm 5.1  The Two-way Merge                              182
   Algorithm 5.2  Sorting by Selection                           192
   Algorithm 5.3  Sorting by Exchange                            192
   Algorithm 5.4  Sorting by Insertion                           204
   Algorithm 5.5  Sorting by Diminishing Increment               209
   Algorithm 5.6  Sorting by Partitioning                        216
   Algorithm 5.7  Binary Search                                  227
   Algorithm 5.8  Hash Searching                                 237
   Algorithm 6.1  Text Line Length Adjustment                    249
   Algorithm 6.2  Left and Right Justification in Text           256
   Algorithm 6.3  Keyword Searching in Text                      267
   Algorithm 6.4  Text Line Editing                              274
   Algorithm 6.5  Linear Pattern Search                          282
   Algorithm 6.6  Sublinear Pattern Search                       293
   Algorithm 7.1  Stack Operations                               306
   Algorithm 7.2  Queue Addition and Deletion                    314
   Algorithm 7.3  Linked List Search                             325
   Algorithm 7.4  Linked List Insertion and Deletion             331
   Algorithm 7.5  Binary Tree Search                             342
   Algorithm 7.6  Binary Tree Insertion and Deletion             349
   Algorithm 8.1  Binary Tree Traversal                          373
   Algorithm 8.2  Recursive Quick sort                           383
   Algorithm 8.3  Towers of Hanoi Problem                        391
   Algorithm 8.4  Sample Generation                              414
   Algorithm 8.5  Combination Generation                         414
   Algorithm 8.6  Permutation Generation                         422
   =================================================================

{\\\::~}



ALGORITHMS
ROBERT SEDGEWICK
BROWN UNNERSITY
ISBN 0-201-06672-6
February, 1985
Copyright 1983 by Addison-Wesley Publishing Company, Inc.


[Contents]


    PART 1 MATHEMATICAL ALGORITHMS
    PART 2 SORTING
    PART 3 SEARCHING
    PART 4 STRING PROCESSING
    PART 5 GEOMETRIC ALGORITHMS
    PART 6 GRAPH ALGORITHMS
    PART 7 ADVANCED TOPICS



[Contents]

    Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 3
        Algorithms, Outline of Topics
        
1. Preview. . . . . . . . . . . . . . . . . . . . . . . . . . . 9
        Pascal, Euclid’s Algorithm, Recursion, Analysis of Algorithms
        Implementing Algorithms

MATHEMATICAL ALGORITHMS
***********************

2. Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . 21
        Polynomials, Matrices, Data Structures

3. Random Numbers . . . . . . . . . . . . . . . . . . . . . . . 33
        Applications, Linear Congruential Method, Additive
        Congruential Method, Testing Randomness, Implementation Notes

4. Polynomials . . . . . . . . . . . . . . . . . . . . . . . . . . 45
        Evaluation, Interpolation, Multiplication, Divide-and-conquer
        Recurrences, Matriz Multiplication

5. Gaussian Elimination . . . . . . . . . . . . . . . . . . . . . . 57
        A Simple Example, Outline of the Method, Variations and Extensions

6. Curve Fitting . . . . . . . . . . . . . . . . . . . . . . . . . 67
        Polynomaal Interpolation, Spline Interpolation, Method of Least Squares

7. Integration . . . . . . . . . . . . . . . . . . . . . . . . . . 79
        Symbolac Integration, Simple Quadrature Methods, Compound Methods,
        Adaptive Quadrature

SORTING
*******

8. Elementary Sorting Methods . . . . . . . . . . . . . . . . . . 91
        Rules of the Game, Selection Sort, Insertion Sort, Shellsort,
        Bubble Sort, Distribution Counting, Non-Random Files

9. Quicksort . . . . . . . . . . . . . . . . . . . . . . . . . . 103
        The Baszc Algorithm, Removing Recursion, Small Subfiles,
        Median-of- Three Partitioning

10. Radix Sorting . . . . . . . . . . . , . . . . . . . . . . . . 115
        Radiz Ezchange Sort, Straight Radix Sort, A Linear Sort

11. Priority Queues . . . . . . . . . . . . . . . . . . . . . . 127
        Elementary Implementations, Heap Data Structure, Algorithms
        on Heaps, Heapsort, Indirect Heaps, Advanced Implementations

12. Selection and Merging . . . . . . . . . . . . . . . . . . . . 143
        Selection, Mergang, Recursion Revisited

13. External Sorting . . . . . . . . . . . . . . . . . . . . . . 155
        Sort-Merge, Balanced Multiway Merging, Replacement Selectzon,
        Practical Considerations, Polyphase Merging, An Easier Way

SEARCHING
*********

14. Elementary Searching Methods . . . . . . . . . . . . . . . .171
        Sequential Searching, Sequential List Searchang, Binary Search,
        Binary Tree Search, Indirect Binary Search Trees

15. Balanced Trees . . . . . . . . . . . . . . . . . . . . . .187
        Top-Down 2-9-4 Trees, Red-Black Trees, Other Algorithms

16. Hashing . . . . . . . . . . . . . . . . . , . . . . . . .201
        Hash Functions, Separate Chaining, Open Addresszng, Analytic Results

17. Radix Searching . . . . . . . . . . . . . . . . . . . . . .213
        Digital Search Trees, Radix Search Trees, Multiway Radar Searching,
        Patricia

18. External Searching . . . . . . . . ,, . . . . . . . . . . . . . 225
        Indexed Sequential Access, B- nees, Extendible Hashing, Virtual Memory

STRING PROCESSING
*****************

19. String Searching . . . . . . . . . . . . . . . . . . . . . . 241
        A Short History, Brute-Force Algorithm, Knuth-Morris-Pratt Algorzthm,
        Bayer-Moore Algorithm, Rabin-Karp Algorithm, Multiple Searches

20. Pattern Matching . . . . . . . . . . . . . . . . . . . . . 257
        Describing Patterns, Pattern Matching Machznes, Representzng
        the Machine, Simulating the Machine

21. Parsing . . . . . . . . . . . . . . . . . . . . . . . . . . 269
        Conteti-Free Grammars, Top-Down Parsing, Bottom-Up Parsing,
        Compilers, Compiler-Compilers

22. File Compression . . . . . . . . . . . . . . . . . . . . . . 283
        Run-Length Encoding, Variable-Length Encoding

23. Cryptology . . . . . . . . . . . . . . . . . . . . . . . . . 295
        Rules of the Game, Simple Methods, Encrypt:!on/Decryption
        Machines, Public-Key Cryptosystems

GEOMETRIC ALGORITHMS
********************

24. Elementary Geometric Methods . . . . . . . . . . . . . . . . 307
        Poznts, Lines, and Polygons, Line Intersection, Simple
        Closed Path, Inclusaon in 4 Polygon, Perspective

25. Finding the Convex Hull . . . . . . . . . . . . . . . . . . . 321
        Rules of the Game, Package Wrapping, The Graham Scan,
        Hull Selection, Performance Issues

26. Range Searching . . . . . . . . . . . . . . . . . . . . . . . 335
        Elementary Methods, Grad Method, 2D Trees,
        Multidimensaonal Range Searching

27. Geometric Intersection . , . . . . . . . . . . . . . . . . . . 349
        Horizontal and Vertical Lines, General Line Intersection

28. Closest Point Problems . . . . . . . . . . . . . . . . . . . 361
        Closest Paar, Voronoi Diagrams

GRAPH ALGORITHMS
****************

29. Elementary Graph Algorithms . . . . . . . . . . . . . . . . . 373
        Glossary, Representation, Depth-First Search, Mazes, Perspectzve

30. Connectivity . . . . . . . . . . . . . . . . . . . . . . . 389
        Biconnectivity, Graph Traversal Algorzthms, Union-Find Algorithms

31. Weighted Graphs . . . . . . . . . . . . . . . . . . . . . 407
        Mmimum Spanning Tree, Shortest Path, Dense Graphs, Geometrzc Problems

32. Directed Graphs . . . . . . . . . . . . . . . . . . . . 421
        Depth-Farst Search, Transitwe Closure, Topological Sorting,
        Strongly Connected Components

33. Network Flow . . . . . . . . . . . . . . . . . . . . . 433
        The Network Flow Problem, Ford-Adkerson
        Method, Network Searching

34. Matching . . . . . . . . . . . . . . . . . . . . . . . . . . 443
        Bapartite Graphs, Stable Marriage Problem, Advanced Algorathms

ADVANCED TOPICS
***************

35. Algorithm Machines . . . . . . . . . . . . . . . . . . . . .457
        General Approaches, Perfect Shuffles, Systolic Arrays

36. The Fast Fourier Transform . . . . . . . . . . . . . . . . .471
        Evaluate, Multiply, Interpolate, Complez Roots of Unity, Evaluation
        at the Roots of Unity, Interpolatzon at the Roots of Unity, Implementation

37. Dynamic Programming . . . . . . . . . . . . . . . . . . . . 483
        Knapsack Problem, Matriz Chain Product, Optimal Binary Search Trees,
        Shortest Paths, Time and Space Requirements

38. Linear Programming . . . . . . . . . . . . . . . . . . . . 497
        Linear Programs, Geometric Interpretation, The Simplex Method,
        Implementation

39. Exhaustive Search . . . . . . . . . . . . . . . . . . . . . 513
        Exhaustive Search in Graphs, Backtrackzng,
        Permutation Generation, Approximation Algorithms

40. NP-complete Problems . . . . . . . . . . . . . . . . . . 527
        Deterministic and Nondeterministic Polynomial- Time Algorzthms,
        NP-Completeness, Cook’s Theorem, Some NP-Complete Problems
{::\\\~}




PROGRAM {Name of the program}
USES {Comma delimited names of libraries you use}
CONST {Global constant declaration block}
VAR {global variable declaration block}

FUNCTION {Function declarations, if any}
{ Local variables }
BEGIN
 .
 .
 .
END;

PROCEDURE { Procedure declarations, if any}
{ Local variables }
BEGIN
 .
 .
 .
END;

BEGIN { Main program block starts}
.
.
.
END. { The end of main program block }

{
{ File name: hello.pas }
program HelloWorld;
uses crt;

(* Here the main program block starts *)
begin
writeln('Hello, World!');
readkey;
end.

{
$ fpc hello.pas
Free Pascal Compiler version 2.6.0 [2011/12/23] for x86_64
Copyright (c) 1993-2011 by Florian Klaempfl and others
Target OS: Linux for x86-64
Compiling hello.pas
Linking hello
8 lines compiled, 0.1 sec
$ ./hello
Hello, World!
}
}


{-------------------------------------------------}

PROGRAM  hello;
BEGIN
WRITELN('Hello world!')
END.

Output: Hello world!

View ROM for sub details!


PROGRAM  sample;
CONST x=2;
VAR   y:INTEGER;
BEGIN y:=x*x;
      WRITELN(y)
END.

Output: 4


PROGRAM  w_INTEGER;
CONST a=400;
VAR   b,s:INTEGER;
BEGIN b:=3;
      s:=a+b; s:=s DIV 2;
      WRITELN(s)
END.

Output: 201


PROGRAM  w_INT64;
CONST a=400000;
VAR   b,s:INT64;
BEGIN b:=3;
      s:=a+b; s:=s DIV 2;
      WRITELN(s)
END.

Output: 200001


PROGRAM  w_DOUBLE;
CONST a=4.0;
VAR   b:REAL; s:DOUBLE;
BEGIN b:=3.5;
      s:=a+b; s:=s/2.0;
{try also     s:=s/2;}
      WRITELN(s)
END.

Output: 0.375000000e1


PROGRAM  INTEGERtypes;
CONST c=100000; d=200; 
VAR   a:INT64;  b:INTEGER;
BEGIN WRITE(c); WRITE(' ');
WRITELN(d);
a:=c; WRITE(a); WRITE(' ');
a:=d; WRITELN(a);
b:=d; WRITELN(b);
{a:=c;} {b:=a; WRITELN(b);}
a:=b+c; WRITELN(a);
END.
see compiler options!!!
Output: 100000 200
        100000 200
        200
        100200


PROGRAM  INT_DOUBLE;
CONST i=-2;    r=4.75;
VAR   a:INT64; b:DOUBLE;
BEGIN b:=1; WRITELN(b);
      b:=r+i; WRITELN(b);
      a:=TRUNC(r); WRITELN(a);
      a:=ROUND(r); WRITELN(a)
END.

Output: 0.100000000e1
        0.275000000e1
        4
        5


PROGRAM  calc_SQR;
VAR   a:INTEGER; b:DOUBLE;
BEGIN a:=2; a:=SQR(a);
      WRITELN(a);
      b:=2.0; b:=SQR(b);
      WRITELN(b)
END.

Output: 4
        0.400000000e1


PROGRAM  calc;
VAR  a,b,c:INTEGER;
BEGIN a:=3; b:=a+2;
b:=SQR(b);b:=b-2;
c:=b mod a;
writeln(c);
END.

Output: 2


PROGRAM  fallibility;
CONST e=1e-2;
VAR   a,s:REAL; 
      i,n:INT64;
BEGIN a:=1/e; n:=TRUNC(a);
      WRITELN(n);
      s:=0;
      FOR i:=1 TO n DO s:=s+e;
      a:=1-s;
      WRITELN(a)
END.

Output: 100
        -0.666133814e-15


PROGRAM  w_BOOLEAN;
CONST t=TRUE; f=FALSE;
VAR   b:BOOLEAN;
BEGIN b:=f; WRITELN(b);
      WRITELN(t)
END.

Output: FALSE
        TRUE


PROGRAM logic;
CONST a=FALSE; b=FALSE;
VAR   c,d,e,f:BOOLEAN;
BEGIN c:=a AND b;
      WRITELN(c);
      d:=NOT a; e:=NOT b;
      f:=e OR d; f:=NOT f;
      WRITE(f); WRITE(' xor ');
      f:=c XOR f; WRITELN(f)
END.

Output: FALSE
        FALSE xor FALSE


PROGRAM char_func;
CONST e='1';
VAR   i:INTEGER;
      c:CHAR;
BEGIN
i:=ORD(e); WRITELN(i);
c:=CHR(49);WRITELN(c);
c:=SUCC(e);WRITELN(c);
c:=PRED(e);WRITELN(c);
END.

Output: 49
        1
        2
        0


PROGRAM  TypConst;
CONST n=4;
      t:INTEGER=5;
VAR   w:INTEGER;
BEGIN w:=t-n; t:=w+1;
WRITELN(t);
END.

Output: 2


PROGRAM  VarPos1;
VAR d:DOUBLE;
    b:BOOLEAN;
    i:INTEGER;
    l:INT64;
    c:CHAR;
BEGIN i:=0
END.


PROGRAM VarPos2;
{more rational}
VAR d:DOUBLE;
    l:INT64;
    b:BOOLEAN; c:CHAR;
    i:INTEGER;
BEGIN i:=0
END.


PROGRAM  Array1;
CONST a=2005;    b='3';
VAR   c:INTEGER; d:CHAR;
e:ARRAY [1999..a] OF CHAR;
f:ARRAY ['0'..b] 
        OF INTEGER;
BEGIN c:=a-2; e[c]:=SUCC(b);
WRITELN(e[2003]);
d:=PRED(b); f[d]:=3*a;
WRITELN(f['2'])
END.

Output: 4
        6015


PROGRAM  Array2;
CONST c=1;
VAR   i:INT64;
f:ARRAY [c..5] OF DOUBLE;
BEGIN i:=c+2;
f[i]:=20.2; WRITELN(f[3])
END.

Output: 0.202000000e2


PROGRAM  Array3;
CONST t=TRUE;
VAR b:BOOLEAN;
m:ARRAY [BOOLEAN]
        OF INTEGER;
BEGIN
m[FALSE]:=0; m[TRUE]:=1;
b:=TRUE; WRITELN(m[FALSE]);
WRITE(m[b]); WRITE('  ');
WRITELN(m[t]);
END.

Output: 0
        1  1


PROGRAM digits;
CONST n=5;
      k:INTEGER=13524;
VAR   i:INTEGER;
c:ARRAY [1..n] OF INTEGER;
BEGIN  i:=n;
REPEAT c[i]:=k MOD 10;
       k:=k DIV 10;
       i:=i-1
UNTIL k=0;
FOR i:=1 TO n DO
BEGIN  WRITE(c[i]);WRITE(' ')
END
END.

Output: 1 3 5 2 4


PROGRAM  IfInt;
VAR   x,s:INTEGER;
BEGIN x:=2;
if x<0 then s:=-1
       else s:=1;
writeln(s)
END.

Output: 1


PROGRAM  IfBool;
VAR i:INT64;
    b:BOOLEAN;
    c:CHAR;
BEGIN 
i:=1; b:=i=0;
if b then c:='0'
     else c:='1';
writeln(c)
END.

Output: 1


PROGRAM  Sign;
CONST x=2;
VAR   s:INTEGER;
BEGIN
IF x<0 THEN s:=-1
       ELSE s:=1;
IF x=0 THEN s:=0;
writeln(s)
END.

Output: 1


PROGRAM StepMinEdin;
CONST n:INTEGER=3;
VAR   r,e:INTEGER;
BEGIN r:=n MOD 2;
IF r=0 THEN e:=1
       ELSE e:=-1;
WRITELN(e);
END.

Output: -1


PROGRAM number;
CONST c:CHAR='3';
VAR   i:INTEGER;
      l,r,w:BOOLEAN;
BEGIN l:=c>='0'; r:=c<='9';
      w:=l AND r;
IF w 
  THEN WRITELN('number')
  ELSE WRITELN('not number');
END.

Output: number


PROGRAM example;
CONST a:INTEGER=2;
      b:INTEGER=15;
VAR   c:INTEGER;
BEGIN c:=0;
      WHILE a<b DO
            BEGIN a:=a+5;
                  c:=c+1
            END;
      WRITELN(c)
END.

Output:  3


PROGRAM search;
VAR i:INTEGER;
t:ARRAY [1..11] OF CHAR;
BEGIN FOR i:=1 TO 10 DO
          READ(t[i]);
WRITELN('.');
t[11]:='A'; i:=1;
WHILE t[i]<>'A' DO i:=i+1; 
IF i<11 THEN WRITELN(i)
        ELSE WRITELN('no');
END.


PROGRAM SQRT;
VAR x,y,s:INTEGER;
BEGIN
READLN(x); y:=0;
REPEAT
      y:=y+1; 
      s:=SQR(y);
UNTIL s>=x;
WRITELN(y)
END.


PROGRAM text;
VAR i:INTEGER;
t:ARRAY [1..10] OF CHAR;
BEGIN  i:=0;
REPEAT i:=i+1;
       READ(t[i])
UNTIL  t[i]='.'
END.


PROGRAM  cycle_FOR1;
VAR  i:INTEGER;
BEGIN
FOR i:=1 TO 9
    DO WRITELN(i)
END.

Output: 1
        2
...
        9


PROGRAM  cycle_FOR2;
VAR  i:INTEGER;
BEGIN
FOR i:=9 DOWNTO 1
    DO WRITELN(i)
END.

Output: 9
        8
...
        1


PROGRAM  cycle_FOR3;
VAR  c:CHAR;
BEGIN
FOR c:='A' TO 'Z'
    DO WRITE(c)
END.

Output: ABCD..Z


PROGRAM  cycle_FOR4;
VAR  c:CHAR;
BEGIN
FOR c:='Z' DOWNTO 'A'
    DO WRITE(c)
END.

Output: ZYX..A


PROGRAM  cycle_FOR5;
VAR  b:BOOLEAN;
BEGIN
FOR b:=FALSE TO TRUE
    DO WRITELN(b)
END.

Output: FALSE
        TRUE


PROGRAM  cycle_FOR6;
VAR  b:BOOLEAN;
BEGIN
FOR b:=TRUE DOWNTO FALSE
    DO WRITELN(b)
END.

Output: TRUE
        FALSE


PROGRAM  cycle_FOR7;
VAR  i:INT64;
BEGIN
FOR i:=100001 TO 100009
    DO WRITELN(i)
END.

Output: 100000
        100001
...
        100009


PROGRAM  cycle_FOR8;
VAR  i:INT64;
BEGIN
FOR i:=100009 DOWNTO 100001
    DO WRITELN(i)
END.

Output: 100009
        100008
...
        100001


PROGRAM  factor_WHILE;
VAR   i,n,f:INTEGER;
BEGIN n:=3;
      f:=1; i:=1;
WHILE i<=n DO
BEGIN f:=f*i;
      i:=i+1
END;
writeln(f)
END.

Output: 6


PROGRAM  factor_REPEAT;
VAR  i,n,f:INTEGER;
BEGIN  n:=3;
       f:=1; i:=1;
REPEAT f:=f*i;
       i:=i+1
UNTIL  i>n;
writeln(f)
END.

Output: 6


PROGRAM  factor_FOR;
VAR   i,n,f:INTEGER;
BEGIN n:=3;
      f:=1;
FOR i:=1 TO n DO f:=f*i;
writeln(f)
END.

Output: 6


PROGRAM  factor_INT;
VAR   i,n,f:INTEGER;
      l:INT64;
BEGIN n:=7; f:=1;
FOR i:=1 TO n DO f:=f*i;
writeln(f);
n:=20; l:=1;
FOR i:=1 TO n DO l:=l*i;
writeln(l)
END.

Output: 5040
        2432902008176640000


PROGRAM Gauss;
CONST n=100;
VAR   i,s:INTEGER;
BEGIN s:=0;
FOR i:=1 TO n DO s:=s+i;
WRITELN(s);
END.

Output: 5050


PROGRAM bool;
VAR  b,n:BOOLEAN;
BEGIN
FOR b:=FALSE TO TRUE DO
   BEGIN WRITE('b=');
         WRITE(b);
         n:=not b;
         WRITE(' not(b)=');
         WRITELN(n)
   END;
END.

Output: b=FALSE  not(b)=TRUE
        b=TRUE  not(b)=FALSE


PROGRAM summa;
CONST n=5;
VAR   i,s:INTEGER;
m:ARRAY [1..n] OF INTEGER;
BEGIN
FOR i:=1 TO n DO
    readln(m[i]); s:=0;
FOR i:=1 TO n DO s:=s+m[i];
WRITELN(s);
END.


PROGRAM OtrElem;
CONST n=5;
VAR i:INTEGER; a,b:BOOLEAN;
m:ARRAY [1..n] OF INTEGER;
BEGIN FOR i:=1 TO n DO
       readln(m[i]);  i:=0; 
REPEAT i:=i+1; a:=m[i]<0; 
b:=i=n; b:=a OR b UNTIL b;
IF a THEN WRITELN(m[i])
     ELSE WRITELN('no -')
END.


PROGRAM  Hex;
VAR i:INTEGER; s:CHAR;
h:ARRAY [0..15] OF CHAR;
BEGIN s:='0';
FOR i:=0 TO 9 DO
 BEGIN h[i]:=s; s:=SUCC(s);
 END;  s:='A';
FOR i:=10 TO 15 DO
 BEGIN h[i]:=s; s:=SUCC(s);
 END;  WRITELN(h[13]);
END.

Output:  D


PROGRAM text;
CONST n=10; e='.';
VAR   i,j:INTEGER;
t:ARRAY [1..n] OF CHAR;
BEGIN i:=0;
REPEAT i:=i+1;READ(t[i]);
UNTIL t[i]=e;          
FOR j:=1 TO i DO
    WRITE(t[j]);
END.


PROGRAM OutText;
BEGIN
WRITELN('Text example')
END.

Output:  Text example


PROGRAM OutVar;
VAR 
m:ARRAY [1..3] OF CHAR;
i:INTEGER;
BEGIN m[3]:='Q'; i:=3;
WRITELN(m[i])
END.

Output:  Q


PROGRAM OutputExample;
VAR   c:CHAR;
BEGIN c:='3';
WRITE('Example');
WRITELN(' of output');
WRITE('c=');
WRITELN(c)
END.

Output:  Example of output
         c=3


PROGRAM read_int;
VAR a,b:INTEGER;
BEGIN READLN(a);
      READLN(b);
      WRITE(a); WRITE(' ');
      WRITELN(b)
END.


PROGRAM read_char;
VAR a,b:CHAR;
BEGIN READ(a);
      READ(b);
      WRITE('=>');
      WRITE(a); WRITELN(b)
END.


PROGRAM oform;
VAR   a:INTEGER;
BEGIN WRITE('A=');
      READLN(a);
      WRITE('A=');
      WRITELN(a)
END.


{::\\\~}

///::~


Learn Pascal in Three Days
Third Edition
Sam A. Abolrous
ISBN 1-55622-805-8
Wordware Publishing, Inc.


[Contents]

Preface                                                                     ix
Acknowledgments                                                              x
About the Author                                                            xi
Chapter  1: Hello Pascal                                                     1
Chapter  2: Language Elements                                               19
Chapter  3: Decisions                                                       39
Chapter  4: Loops                                                           61
Chapter  5: Data Architecture                                               77
Chapter  6: Text Processing                                                101
Chapter  7: Program Architecture                                           121
Chapter  8: Sets and Records                                               137
Chapter  9: Files and Applications                                         155
Chapter 10: Using Variant Records                                          183
Chapter 11: Pointers and Linked Lists                                      217
Appendix A: The ASCII Character Set                                        257
Appendix B: Reserved Words and Standard Identifiers                        261
Appendix C: Answers to Drills                                              265
Index                                                                      317


[Contents]

Preface                                                                     ix
Acknowledgments                                                              x
About the Author                                                            xi

Chapter 1: Hello Pascal                                                     1

           1-1 Your First Pascal Program                                    1
               Comments                                                     1
               Program Heading                                              2
               Syntax and Conventions                                       2
           1-2 Displaying Text: WRITELN, WRITE                              3
           1-3 Crunching Numbers                                            4
               Integers and Real Numbers                                    5
               Evaluation of Arithmetic Expressions                         7
           1-4 Using Variables                                              9
               Variable Declaration                                         9
               The Assignment Statement                                    10
           1-5 Named Constants                                             12
           1-6 Type Conversion: ROUND, TRUNC                               13
           1-7 Reading from the Keyboard: READLN, READ                     14
           1-8 Formatting Output                                           15
           Summary                                                         17
           Exercises                                                       18
           Answers                                                         18

Chapter 2: Language Elements                                               19

           2-1 Standard Data Types and Functions                           19
           2-2 Numeric Data Types                                          19
               Numeric Types in Turbo Pascal                               20
           2-3 Standard Arithmetic Functions                               21
               Example: The Power Function                                 23
               Example: Grocery Store                                      23
               Turbo Pascal Additional Functions                           25
           2-4 The Character Type: CHAR                                    26
               Standard Functions for Characters                           27
               Strings in Standard Pascal                                  29
           2-5 The STRING Type                                             30
               Declaration of a String                                     30
               The Length of a String                                      31
           2-6 The BOOLEAN Type                                            32
               Simple Boolean Expressions                                  32
               Compound Boolean Expressions                                34
               Turbo Pascal Operators                                      35
               Precedence of Operators                                     35
           Summary                                                         36
           Exercises                                                       38
           Answers                                                         38

Chapter 3: Decisions                                                       39

           3-1 Making Decisions                                            39
           3-2 The Simple Decision: IF-THEN                                40
               Example: Pascal Credit Card                                 40
               Using Blocks                                                42
           3-3 The IF-THEN-ELSE Construct                                  43
           3-4 The ELSE-IF Ladders                                         45
               Example: A Character Tester                                 46
           3-5 Nested Conditions                                           47
               Example: Scores and Grades                                  47
               Tips on the IF-ELSE Puzzles                                 50
           3-6 The Multiple Choice: CASE                                   51
               Example: A Vending Machine                                  51
               Example: Number of Days in a Month                          52
           3-7 Unconditional Branching: GOTO                               54
               Repetition Loops                                            55
           3-8 Turbo Pascal Features: EXIT, CASE-ELSE                      56
           Summary                                                         57
           Exercises                                                       59
           Answers                                                         60

Chapter 4: Loops                                                           61

           4-1 Looping                                                     61
           4-2 The FOR Loop                                                62
               Example: Powers of Two                                      64
               Example: The Average                                        65
           4-3 Stepping Up and Stepping Down                               66
               Example: The Factorial                                      67
           4-4 Nested Loops                                                68
           4-5 The WHILE Loop                                              69
           4-6 The REPEAT Loop                                             72
           Summary                                                         74
           Exercises                                                       75
           Answers                                                         76

Chapter 5: Data Architecture                                               77

           5-1 Ordinal Data Types                                          77
               Enumerations                                                77
               Subranges                                                   79
           5-2 The TYPE Section                                            81
               Renaming Types                                              81
               Naming User-Defined Types                                   82
           5-3 Arrays as Data Structures                                   83
           5-4 One-Dimensional Arrays                                      85
               Example: Scores of One Student                              85
               Displaying Tabulated Results                                87
               Declaration of Arrays in the TYPE Section                   90
               Example: Sorting an Array                                   90
           5-5 Two-Dimensional Arrays                                      93
               Example: Scores of Students                                 94
               Array Initialization                                        96
           Summary                                                         97
           Exercises                                                       98
           Answers                                                         99

Chapter 6: Text Processing                                                 101

           6-1 Manipulating Text Data                                      101
           6-2 Tips on OUTPUT Statements                                   101
           6-3 Tips on INPUT Statements                                    102
               Using READLN for Numeric Input                              102
               Using READ for Numeric Input                                104
               Using READ for Character Input                              105
               Using READLN for Character Input                            107
               Input of Mixed Types                                        108
               Example: Scrambling Letters                                 109
           6-4 Reading a Line of Text: EOLN                                111
               Example: Character Counter                                  111
           6-5 Reading a File of Text: EOF                                 112
               Example: Frequency Counter                                  112
           6-6 String Manipulation                                         113
               Tips on String Input/Output                                 113
               Example: Sorting Names                                      114
           6-7 String Functions and Procedures                             116
               LENGTH                                                      116
               CONCAT                                                      117
               COPY                                                        117
               POS                                                         117
               DELETE                                                      117
               INSERT                                                      118
           Summary                                                         119
           Exercises                                                       119
           Answers                                                         120

Chapter 7: Program Architecture                                            121

           7-1 Programs and Subprograms                                    121
           7-2 Procedures                                                  121
               Procedure Definition                                        122
               Passing Values to Procedures                                123
               Passing Back Values from Procedures                         126
           7-3 Global and Local Variables                                  127
               Example: Sorting Procedure                                  127
           7-4 Functions                                                   130
           7-5 Tips on the Scope of Variables                              131
           7-6 Recursion                                                   133
           Summary                                                         134
           Exercises                                                       134
           Answers                                                         135

Chapter 8: Sets and Records                                                137

           8-1 Sets                                                        137
           8-2 Set Declaration and Assignment                              138
               Rules and Restrictions                                      139
           8-3 Set Operators and Operations                                140
               Union                                                       140
               Intersection                                                140
               Difference                                                  140
               Tips on Using Set Operators                                 140
               Relational Operators                                        141
               Example: Text Analyzer                                      142
           8-4 Records                                                     144
               Record Declaration                                          144
               Accessing Fields                                            145
               The WITH Statement                                          146
           8-5 Nesting Records                                             149
           Summary                                                         151
           Exercises                                                       152
           Answers                                                         153

Chapter 9: Files and Applications                                          155

           9-1 Data Files                                                  155
           9-2 TEXT Files                                                  156
           9-3 Reading a TEXT File                                         156
               File Variables                                              156
               File Parameters                                             157
               Opening a File for Input: RESET                             157
               Closing the File                                            158
               File Input Procedures: READ, READLN                         158
               The EOF and EOLN Functions                                  159
               Example: Disk-File Text Analyzer                            159
           9-4 Displaying a TEXT File                                      162
               Reading a TEXT File as a Set of Strings                     163
               Reading Multiple Strings                                    164
           9-5 Creating a TEXT File: REWRITE                               165
               File Output Procedures: WRITE, WRITELN                      165
               Example: Employee File                                      166
               Example: Payroll                                            168
           9-6 Non-TEXT Files                                              172
               Example: Payroll System                                     173
               Appending a File                                            176
           9-7 Using the File Buffer Variable                              178
           Summary                                                         179
           Exercises                                                       180
           Answers                                                         181

Chapter 10: Using Variant Records                                          183

            10-1 Variant Records                                           183
            10-2 Example: Enhanced Payroll System                          185
            10-3 Deleting Records from the File                            192
            10-4 Updating Records                                          201
            10-5 Enhance the Program Modularity                            204
                 Suggestions                                               214
            Summary                                                        214
            Exercises                                                      215
            Answers                                                        215

Chapter 11: Pointers and Linked Lists                                      217

            11-1 Dynamic Memory Allocation                                 217
            11-2 Pointers                                                  217
                 Pointer Operations                                        220
                 Pointers to Records                                       222
                 Passing Pointers as Parameters                            224
            11-3 Basics of Linked Lists                                    225
                 List Declaration                                          225
                 Building a List                                           225
                 Reading a List                                            227
                 Example: A Linked List Demo                               229
                 Storing Lists in Files                                    232
                 Reading Lists from Files                                  233
                 Example: A List of Records                                234
            11-4 Searching Lists                                           235
            11-5 Deleting Nodes from Lists                                 243
            Summary                                                        253
            Exercises                                                      254
            Answers                                                        255
                The Next Step                                              256

Appendix A: The ASCII Character Set                                        257
Appendix B: Reserved Words and Standard Identifiers                        261
Appendix C: Answers to Drills                                              265

Index                                                                      317

///::~



Pascal Language Comments
========================
(* This is a comment *)
{ This is a comment }

{ ----------------------------- Example 1-1 ------------------------------ }
PROGRAM FirstProgram(OUTPUT);
BEGIN
WRITELN('Hi there')
END.

{ ------------------------------ Example 1-2 ------------------------------ }
program firstprogram(output);
begin
writeln('Hi there')
end.

{ ------------------------------ Example 1-3 ------------------------------ }
PROGRAM FIRSTPROGRAM(OUTPUT);
BEGIN
WRITELN('Hi there')
END.

{ ------------------------------ Example 1-4 ------------------------------ }
PROGRAM LinesOfText(OUTPUT);
BEGIN
WRITELN('Hi there.');
WRITELN('How are you today?');
WRITELN('Are you ready for Pascal?')
END.

{ ------------------------------ Example 1-5 ------------------------------ }
PROGRAM TwoLines(OUTPUT);
BEGIN
WRITE('Hi there. ');
WRITELN('How are you today?');
WRITELN('Are you ready for Pascal?')
END.

{ ------------------------------ Example 1-6 ------------------------------- }
PROGRAM CrunchNumbers(OUTPUT);
BEGIN
WRITELN('I can easily crunch numbers.');
WRITELN('Here is multiplication of 50x4:',50*4);
WRITELN('..and here is division of 2400/8:',2400/8)
END.

OUTPUT

I can easily crunch numbers.
Here is multiplication of 50x4:200
..and here is division of 2400/8: 3.0000000000E+02

{ ------------------------------ Example 1-7 ------------------------------ }
PROGRAM Variables(OUTPUT);
{ Variable Declarations }
VAR
a, b :INTEGER;
   x :REAL;
{ Program Block }
BEGIN
WRITELN('Contents of a=',a);
WRITELN('Contents of b=',b);
WRITELN('Contents of x=',x)
END.

OUTPUT

Contents of a=0
Contents of b=631
Contents of x= 2.7216107254E-26

{ ------------------------------ Example 1-8 ------------------------------ }
PROGRAM Arithmetic(OUTPUT);
{ Variable Declarations }
VAR
a, b :INTEGER;
{ Program Block }
BEGIN
a := 25;
b := 2;
WRITELN('a=',a);
WRITELN('b=',b);
WRITELN('a+b=',a+b);
WRITELN('a-b=',a-b);
WRITELN('a*b=',a*b);
WRITELN('a/b=',a/b);
WRITELN('a div b=',a DIV b);    { used with integers only }
WRITELN('a mod b=',a MOD b)     { used with integers only }
END.

OUTPUT

a=25
b=2
a+b=27
a-b=23
a*b=50
a/b= 1.2500000000E+01 ----> Real division
a div b=12            ----> Integer division
a mod b=1             ----> Remainder of integer division

{ ------------------------------- Example 1-9 ----------------------------- }
PROGRAM Constants(OUTPUT);
{ Constant Declarations }
CONST
Pi = 3.14159;
{ Variable Declarations }
VAR
Radius, Perimeter :REAL;
{ Program Block }
BEGIN
Radius := 4.9;
Perimeter := 2 * Pi * Radius;
WRITELN('Perimeter=', Perimeter)
END.

OUTPUT

Perimeter= 3.0787582000E+01

{ ------------------------------ Example 1-10 ----------------------------- }
PROGRAM Functions1(OUTPUT);
{ Constant Declarations }
CONST
Pi = 3.14159;
{ Variable Declarations }
VAR
Perimeter, Radius
 :REAL;
RoundedPerimeter, TruncatedPerimeter :INTEGER;
{ Program Block }
BEGIN
Radius := 4.9;
Perimeter := 2*Pi*Radius;
RoundedPerimeter := ROUND(Perimeter);
TruncatedPerimeter := TRUNC(Perimeter);
WRITELN('Perimeter=', Perimeter);
WRITELN('Perimeter (rounded)=', RoundedPerimeter);
WRITELN('Perimeter (truncated)=', TruncatedPerimeter)
END.

OUTPUT

Perimeter= 3.0772000000E+01      ----> The actual result
Perimeter (rounded)=31           ----> Rounded result
Perimeter (truncated)=30         ----> Truncated result

{ ------------------------------ Example 1-11 ----------------------------- }
PROGRAM KeyboardInput(OUTPUT);
{ Constant Declarations }
CONST
Pi = 3.14159;
{ Variable Declarations }
VAR
Perimeter, Radius
 :REAL;
RoundedPerimeter, TruncatedPerimeter :INTEGER;
{ Program Block }
BEGIN
WRITE('Please enter the radius:');
READLN(Radius);
Perimeter := 2*Pi*Radius;
RoundedPerimeter := ROUND(Perimeter);
TruncatedPerimeter := TRUNC(Perimeter);
WRITELN('Perimeter=', Perimeter);
WRITELN('Perimeter (rounded)=', RoundedPerimeter);
WRITELN('Perimeter (truncated)=', TruncatedPerimeter)
END.

OUTPUT

Please enter the radius:4.9       ----> Type the number and press <Enter>
Perimeter= 3.0787582000E+01
Perimeter (rounded)=31
Perimeter (truncated)=30

{ ------------------------------ Example 1-12 ----------------------------- }
PROGRAM Format(OUTPUT);
{ Variable Declarations }
VAR
a
 :INTEGER;
b
 :REAL;
{ Program Block }
BEGIN
b := 1.2e+02;
a := 320;
WRITELN('I am a text string starting from position 1.');
WRITELN('I am now shifted to the right end of the field.':50);
WRITELN('I am an unformatted integer:', a);
WRITELN('I am an integer written in a field 6 characters wide:', a:6);
WRITELN('I am a money amount written in 8 positions:$',b:8:2);
WRITELN('I am a money amount shifted to the left:$',b:0:2)
END.

OUTPUT

I am a text string starting from position 1.
I am now shifted to the right end of the field.
I am an unformatted integer:320
I am an integer written in a field 6 characters wide: 320
I am a money amount written in 8 positions:$ 120.00
I am a money amount shifted to the left:$120.00

or,

320
   320
$ 120.00
$120.00

{ ----------------------------- Example 2-1 ------------------------------- }
{ Arithmetic Standard Functions }
PROGRAM FunctionDemo(OUTPUT);
CONST
Pi = 3.14159;
 { No need for this part in Turbo Pascal }
BEGIN
WRITELN('SQR(3)=',SQR(3));
WRITELN('SQR(2.5)=',SQR(2.5):0:2);
 { Notice the format }
WRITELN('SQRT(9)=',SQRT(9):0:2);
WRITELN('ABS(-28.55)=',ABS(-28.55):0:2);
WRITELN('LN(EXP(1))=',LN(EXP(1)):0:2);
WRITELN('ARCTAN(1)=',ARCTAN(1)* 180/Pi:0:0,' degrees')
{ Notice the conversion and the format }
END.

{ ------------------------------ Example 2-2 ------------------------------}
{ Arithmetic Standard Functions }
PROGRAM PowerOperator(INPUT,OUTPUT);
VAR
a, b :REAL;
BEGIN
WRITE('Enter the base and the exponent separated by a space:');
READLN(a,b);
WRITELN('The value of ',a:0:2,' raised to the power ',b:0:2,' is ',
EXP(LN(a)*b):0:2)
END.

OUTPUT

Enter the base and the exponent separated by a space:2 10
The value of 2.00 raised to the power 10.00 is 1024.00

{ ------------------------------ Example 2-3 ------------------------------ }
{ Grocery Store }
PROGRAM Grocery(INPUT,OUTPUT);
VAR
Change, TotalPrice,
Dollars, Quarters, Dimes, Nickels, Cents :INTEGER;
BEGIN
WRITE('Enter the total-price in cents: ');
READLN(TotalPrice);
Change := 100 – TotalPrice;
{ Quarters }
Quarters := Change DIV 25;
Change := Change MOD 25;
{ Dimes }
Dimes := Change DIV 10;
Change := Change MOD 10;
{ Nickels }
Nickels := Change DIV 5;
Change := Change MOD 5;
{ Cents }
Cents := Change;
WRITELN('The change is:');
WRITELN(Quarters,' Quarters');
WRITELN(Dimes,' Dimes');
WRITELN(Nickels, ' Nickels');
WRITELN(Cents, ' Cents')
END.

(* OUTPUT *)
{
Enter the total-price in cents: 22      ----> Type 22 and press Enter
The change is:
3 Quarters
0 Dimes
0 Nickels
3 Cents
}

{ ------------------------------ Example 2-4 ------------------------------ }
{ Displaying the Ordinal Number of a Character }
PROGRAM OrdinalNumber(INPUT,OUTPUT);
VAR
SingleChar :CHAR;
BEGIN
WRITE('Give me a character, please: ');
READLN(SingleChar);
WRITELN('The ordinal number of this character is ', ORD(SingleChar));
READLN
 { The program will pause until you press Enter }
END.

(* OUTPUT *)
{
Give me a character, please: A      ----> Type A and press Enter
The ordinal this character is 65    ----> The program output
}

{ ------------------------------ Example 2-5 ------------------------------ }
{ Displaying the Character, Knowing its Ordinal Number }
PROGRAM CharDisplay(INPUT,OUTPUT);
VAR
OrdinalNum :BYTE;
BEGIN
WRITE('Give me a number between 0 and 255: ');
READLN(OrdinalNum);
WRITELN('This corresponds to the character "', CHR(OrdinalNum),'"');
WRITELN('Press ENTER to continue ...');
READLN { The program will pause until you press Enter }
END.

(* OUTPUT *)
{
Give me a number between 0 and 255: 66 ----> Enter the number 66
This corresponds to the character "B" ----> The program output
Press ENTER to continue ...
}

{ ------------------------------ Example 2-6 ------------------------------ }
{ The Predecessor and the Successor to a Character }
PROGRAM CharPredAndSucc(INPUT,OUTPUT);
VAR
Letter: CHAR;
BEGIN
WRITE('Please Enter a character: ');
READLN(Letter);
WRITELN('The Predecessor to this character is "',PRED(Letter),'"');
WRITELN('The Successor to this character is "',SUCC(Letter),'"');
WRITELN('Press ENTER to continue ...');
READLN
END.

(* OUTPUT *)
{
Please Enter a character:K                ----> Enter the character K
The Predecessor to this character is "J"  ----> The program response
The Successor to this character is "L"
Press ENTER to continue ...
}

{ ------------------------------ Example 2-7 ------------------------------ }
{ Packed Array Of Characters }
PROGRAM PackedArray(OUTPUT);
VAR
Message :PACKED ARRAY[1..21] OF CHAR;
BEGIN
Message := 'Press any key ...
 ';
WRITELN(Message)
END.

(* OUTPUT *)
{
Press any key ...
}

{ ------------------------------ Example 2-8 ------------------------------ }
{ String Type in Turbo Pascal }
PROGRAM StringDemo(INPUT,OUTPUT);
VAR
Name :STRING[20];
BEGIN
WRITE('Please enter a name of 20 characters or less:');
READLN(Name);
WRITELN('The name you entered is ',Name, '. Is that right?')
END.
(* OUTPUT *)
{
Please enter a name of 20 characters or less:Peter Rigby
The name you entered is Peter Rigby. Is that right?
}

{ ------------------------------ Example 2-9 ------------------------------ }
{ Dynamic Length of a String }
PROGRAM StringLen(INPUT,OUTPUT);
VAR
Name :STRING[20];
BEGIN
WRITELN('The dynamic length of the string is now ',LENGTH(Name),
' characters');
WRITE('Please enter a name of 20 characters or less:');
READLN(Name);
WRITELN('The dynamic length of the string is now ',LENGTH(Name),
' characters')
END.

(* OUTPUT *)
{
The dynamic length of the string is now 0 characters
Please enter a name of 20 characters or less:Dale Sanders
The dynamic length of the string is now 12 characters
}

{ ------------------------------ Example 2-10 ----------------------------- }
{ Boolean Variables }
PROGRAM Compare1(INPUT,OUTPUT);
VAR
A, B
 :INTEGER;
Result :BOOLEAN;
BEGIN
WRITE('Please enter two integers: ');
READLN(A, B);
Result := (A = B);
{ or,
Result := A = B;
The parentheses are not necessary. }
WRITELN('The comparison is ', Result)
END.

(* OUTPUT *)
{
Please enter two integers: 5 5
The comparison is TRUE
Please enter two integers: 50 55
The comparison is FALSE
}

{ ------------------------------ Example 2-11 ----------------------------- }
{ Comparing real values }
PROGRAM Compare2(INPUT,OUTPUT);
CONST
  Difference = 0.0001;
VAR
  x, y :REAL;
Result :BOOLEAN;
BEGIN
  WRITE('Please enter two real numbers: ');
  READLN(x, y);
  Result := ABS(x – y) < Difference;
  WRITELN('The difference is ', ABS(x-y):2:6);
  WRITELN('The comparison is ', Result)
END.

(* OUTPUT *)
{
   Please enter two real numbers: 4.5 4.50001
   The difference is 0.000010
   The comparison is TRUE
}

{ ------------------------------ Example 3-1 ------------------------------ }
PROGRAM SimpleDecision(INPUT, OUTPUT);
CONST
  Limit = 1000;
VAR
  Amount :REAL;
BEGIN
  WRITE('Please enter the amount:');
  READLN(Amount);
  
  IF Amount <= Limit THEN
    WRITELN('Your charge is accepted.'); { End of the IF statement }
    
  WRITELN('Press ENTER to continue..');
  READLN
END.

(* OUTPUT TRY 1 *)
{
   Please enter the amount:200
   Your charge is accepted.
   Press ENTER to continue..
}

(* OUTPUT TRY 2 *)
{
   Please enter the amount:2000
   Press ENTER to continue..
}

{ ------------------------------ Example 3-2 ------------------------------ }
PROGRAM TwoConditions(INPUT, OUTPUT);
CONST
  Limit = 1000;
VAR
  Amount :REAL;
BEGIN
  WRITE('Please enter the amount:');
  READLN(Amount);
  
  IF Amount <= Limit THEN
    WRITELN('Your charge is accepted.');
    
  IF Amount > Limit THEN
    WRITELN('The amount exceeds your credit limit.');
    
  WRITELN('Thank you for using Pascal credit card.');
  WRITELN('Press ENTER to continue..');
  READLN
END.

(* OUTPUT TRY 1 *)
{
Please enter the amount:150
Your charge is accepted.
Thank you for using Pascal credit card.
Press ENTER to continue..
}

(* OUTPUT TRY 2 *)
{
Please enter the amount:1500
The amount exceeds your credit limit.
Thank you for using Pascal credit card.
Press ENTER to continue..
}

{ ------------------------------ Example 3-3 ------------------------------ }
PROGRAM UsingBlocks(INPUT,OUTPUT);
CONST
  Limit = 1000;
VAR
  Amount :REAL;
BEGIN
  WRITE('Please enter the amount:');
  READLN(Amount);
  
  IF Amount <= Limit THEN
    BEGIN
      WRITELN('Your charge is accepted.');
      WRITELN('Your price plus tax is $',1.05*Amount:0:2) { The semicolon is optional }
    END;
    
  IF Amount > Limit THEN
    BEGIN
      WRITELN('The amount exceeds your credit limit.') ;
      WRITELN('The maximum limit is $',Limit) { The semicolon is optional }
    END;

  WRITELN('Thank you for using Pascal credit card.');
  WRITELN('Press ENTER to continue..');
  READLN { The semicolon is optional }
END.

(* OUTPUT TRY 1 *)
{
   Please enter the amount:120
   Your charge is accepted.
   Your price plus tax is $126.00
   Thank you for using Pascal credit card.
   
Press ENTER to continue..
}

(* OUTPUT TRY 2 *)
{
   Please enter the amount:2000
   The amount exceeds your credit limit.
   The maximum limit is $1000
   Thank you for using Pascal credit card.
   
Press ENTER to continue..
}

{ ------------------------------ Example 3-4 ------------------------------ }
PROGRAM CreditCard(INPUT,OUTPUT);
CONST
  Limit = 1000;
VAR
  Amount :REAL;
BEGIN
  WRITE('Please enter the amount:');
  READLN(Amount);
{ Beginning of the IF construct }
{ ----------------------------- }
  IF Amount <= Limit THEN
    BEGIN
      WRITELN('Your charge is accepted.');
      WRITELN('Your price plus tax is $',1.05*Amount:0:2)
    END
  ELSE
    BEGIN
      WRITELN('The amount exceeds your credit limit.');
      WRITELN('The maximum limit is $',Limit)
    END;
{ End of the IF construct }
{ ----------------------- }
  WRITELN('Thank you for using Pascal credit card.');
  WRITELN('Press ENTER to continue..');
  READLN
END.

(* OUTPUT *)
{
   Please enter the amount:1000
   Your charge is accepted.
   Your price plus tax is $1050.00
   Thank you for using Pascal credit card.
   
Press ENTER to continue..
}

(* OUTPUT *)
{
   Please enter the amount:1001
   The amount exceeds your credit limit.
   The maximum limit is $1000
   Thank you for using Pascal credit card.
   
Press ENTER to continue..
}

{ ------------------------------ Example 3-5 ------------------------------ }
PROGRAM CharsTester(INPUT,OUTPUT);
VAR
  InputChar :CHAR;
BEGIN
  WRITE('Please enter an alphabetic character:');
  READLN(InputChar);
  
{ Beginning of the IF construct }
{ ----------------------------- }
  IF (ORD(InputChar) > 64) AND (ORD(InputChar) < 91) THEN
    WRITELN('This is an upper-case letter.')
  ELSE 
    IF (ORD(InputChar) > 96) AND (ORD(InputChar) < 123) THEN
      WRITELN('This is a lower-case letter.')
    ELSE 
      IF (ORD(InputChar) > 47) AND (ORD(InputChar) < 58) THEN
        WRITELN('Hey, this is a number!')
      ELSE
        WRITELN('Sorry, this is not a letter.');
{ End of the IF construct }
{ ----------------------- }

  WRITELN('Press ENTER to continue..');
  READLN
END.

(* OUTPUT TRY 1 *)
{
   Please enter an alphabetic character:a      ----> Enter a
   This is a lower-case letter.
   
Press ENTER to continue..
}

(* OUTPUT TRY 2 *)
{
   Please enter an alphabetic character:B      ----> Enter B
   This is an upper-case letter.
   
Press ENTER to continue..
}

(* OUTPUT TRY 3 *)
{
   Please enter an alphabetic character:5      ----> Enter 5
   Hey, this is a number!
   
Press ENTER to continue..
}

(* OUTPUT TRY 4 *)
{
   Please enter an alphabetic character:@      ----> Enter @
   Sorry, this is not a letter.
   
Press ENTER to continue..
}


{ ------------------------------ Example 3-6 ------------------------------ }
PROGRAM ScoresAndGrades1(INPUT,OUTPUT);
VAR
  Score :INTEGER;
BEGIN
  WRITE('Please enter the score:');
  READLN(Score);
  WRITELN;
  
{ Beginning of the IF construct }
{ ----------------------------- }
  IF Score > 59 THEN
    IF Score > 69 THEN
      IF Score > 79 THEN
        IF Score > 89 THEN
          WRITELN('Excellent. Your grade is ''A''')
        ELSE
          WRITELN('Very good. Your grade is ''B''')
      ELSE
        WRITELN('Good. Your grade is ''C''')
    ELSE
      WRITELN('Passed. Your grade is ''D''')
  ELSE
    WRITELN('Better luck next time. Your grade is ''F''');
{ End of the IF construct }
{ ----------------------- }
  WRITELN('Press ENTER to continue..');
  READLN
END.

(* OUTPUT TRY 1 *)
{
   Please enter the score:92      ----> Enter 92
   Excellent. Your grade is 'A'   ----> The program response
   
Press ENTER to continue..
}

(* OUTPUT TRY 2 *)
{
   Please enter the score:70
   Good. Your grade is 'C'
   
Press ENTER to continue..
}

(* OUTPUT TRY 3 *)
{
   Please enter the score:60
   Passed. Your grade is 'D'
   
Press ENTER to continue..
}

(* OUTPUT TRY 4 *)
{
   Please enter the score:59
   Better luck next time. Your grade is 'F'
   
Press ENTER to continue..
}

{ ------------------------------ Example 3-7 ------------------------------ }
PROGRAM ScoresAndGrades2(INPUT,OUTPUT);
VAR
Score
 :INTEGER;
A, B, C, D, F :BOOLEAN;
BEGIN
WRITE('Please enter the score:');
READLN(Score);
A := (Score >= 90) AND (Score <= 100);
B := (Score >= 80) AND (Score < 90);
C := (Score >= 70) AND (Score < 80);
D := (Score >= 60) AND (Score < 70);
F := (Score < 60) AND (Score >= 0);
WRITELN;
{ Beginning of the IF construct }
{ ----------------------------- }
IF A THEN
WRITELN('Excellent. Your grade is ''A''')
ELSE IF B THEN
WRITELN('Very good. Your grade is ''B''')
ELSE IF C THEN
WRITELN('Good. Your grade is ''C''')
ELSE IF D THEN
WRITELN('Passed. Your grade is ''D''')
ELSE IF F THEN
WRITELN('Better luck next time. Your grade is ''F''')
ELSE
WRITELN('This number is out of range.');
{ End of the IF construct }
{ ----------------------- }
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------ Example 3-8 ------------------------------ }
PROGRAM CaseOfWeights(INPUT,OUTPUT);
CONST
  Quarter = 25;
  Dime = 10;
  Nickel = 5;
VAR
  CoinWeight, Amount :INTEGER;
BEGIN
  WRITE('Please enter the weight:');
  READLN(CoinWeight);
  
  CASE CoinWeight OF
    35 : Amount := Quarter;
     7 : Amount := Dime;
    15 : Amount := Nickel;
  END; { End of the CASE construct }

  WRITELN('The amount is ', Amount, ' cents.');
  READLN
END.

(* OUTPUT *)
{
Please enter the weight:35      ----> Enter 35
The amount is 25 cents.         ----> The program response
}

{ ------------------------------ Example 3-9 ----------------------------- }
PROGRAM DaysOfMonth1(INPUT,OUTPUT);
VAR
  Days, Month, Year :INTEGER;
BEGIN
  WRITE('Please enter the number of the month:');
  READLN(Month);
  
  CASE Month OF
    1,3,5,7,8,10,12 : Days := 31;
           4,6,9,11 : Days := 30;
                   2: BEGIN
                        WRITE('Enter the year:');
                        READLN(Year);
                        
                        IF YEAR MOD 4 = 0 THEN Days :=29
                        ELSE
                          Days :=28
                      END;
  END;  { End of the CASE construct }
  
  WRITELN('There are ',Days,' days in this month.');
  READLN
END.

(* OUTPUT TRY 1 *)
{
   Please enter the number of the month:2
   Enter the year:1987
   There are 28 days in this month.
}

(* OUTPUT TRY 2 *)
{
   Please enter the number of the month:2
   Enter the year:1984
   There are 29 days in this month.
}

(* OUTPUT TRY 3 *)
{
   Please enter the number of the month:12
   There are 31 days that in the this month.
}

PROGRAM GoToDemo(INPUT,OUTPUT);
LABEL
1000;
VAR
InputChar :CHAR;
BEGIN
WRITE('Please enter a letter (or 0 to quit):');
READLN(InputChar);
IF InputChar = '0' THEN
GOTO 1000;
{ Other statements may go here... }
1000:
END.


{ ------------------------------ Example 3-10 ----------------------------- }
PROGRAM CharsTester2(INPUT,OUTPUT);
LABEL
1000, 2000; { label declaration }
VAR
InputChar :CHAR;
BEGIN
1000:
WRITE('Please enter a letter (or 0 to quit): ');
READLN(InputChar);
{ Beginning of the IF construct }
{ ----------------------------- }
IF InputChar = '0' THEN { a condition to exit }
GOTO 2000
ELSE IF (ORD(InputChar) > 64) AND (ORD(InputChar) < 91) THEN
WRITELN('This is an upper-case letter.')
ELSE IF (ORD(InputChar) > 96) AND (ORD(InputChar) < 123) THEN
WRITELN('This is a lower-case letter.')
ELSE IF (ORD(InputChar) > 47) AND (ORD(InputChar) < 58) THEN
WRITELN('Hey, this is a number!')
ELSE
WRITELN('Sorry, this is not a letter.');
{ End of the IF construct }
{ ----------------------- }
GOTO 1000; { restart the program }
2000: { exit the program }
END.

(* OUTPUT *)
{
   Please enter a letter (or 0 to quit):W      ----> Enter W
   This is an upper-case letter.
   Please enter a letter (or 0 to quit):e      ----> Enter e
   This is a lower-case letter.
   Please enter a letter (or 0 to quit):0      ----> Enter 0
}

{ ------------------------------ Example 3-11 ----------------------------- }
PROGRAM DaysOfMonth2(INPUT,OUTPUT);
LABEL
Start;
VAR
  Days, Month, Year :INTEGER;
BEGIN
  Start:
    WRITE('Please enter the number of the month: ');
    READLN(Month);
    
    CASE Month OF
      1,3,5,7,8,10,12 : Days := 31;
             4,6,9,11 : Days := 30;
                    2 : BEGIN
                          WRITE('Enter the year:');
                          READLN(Year);
                          IF YEAR MOD 4 = 0 THEN
                            Days :=29
                          ELSE
                            Days :=28
                        END;
    ELSE { ELSE of CASE }
      EXIT      { all other cases }
    END; { END of CASE }
    
    WRITELN('There are ',Days,' days in this month.');
    GOTO Start
END.

(* OUTPUT *)
{
   Please enter the number of the month:1
   There are 31 days in this month.
   Please enter the number of the month:4
   There are 30 days in this month.
   Please enter the number of the month:13      ----> Exit the program
}

{ ------------------------------ Example 4-1 ------------------------------ }
PROGRAM GoToLoop(OUTPUT);
LABEL
1000;
 { label declaration }
VAR
Kounter :INTEGER;
BEGIN
Kounter := 0;
1000:
Kounter := Kounter + 1;
IF Kounter <= 5 THEN
BEGIN
WRITELN('Sorry, say again..');
GOTO 1000
 { restart }
END;
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

(* OUTPUT *)
{
Sorry, say again..
Sorry, say again..
Sorry, say again..
Sorry, say again..
Sorry, say again..
Press ENTER to continue..
}

{ ------------------------------ Example 4-2 ------------------------------ }
PROGRAM ForLoop(OUTPUT);
VAR
Kounter :INTEGER;
BEGIN
FOR Kounter := 1 TO 5 DO
WRITELN('Sorry, say again..');
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------ Example 4-3 ------------------------------ }
PROGRAM ForLoop(INPUT, OUTPUT);
VAR
  Base, Power, Start, Final :INTEGER;
BEGIN
  Base := 2;
  WRITE('Enter starting exponent:');
  READLN(Start);
  WRITE('Enter ending exponent:');
  READLN(Final);
  WRITELN;
  WRITELN('Number      Power of two');
  
  FOR Power := Start TO Final DO
    BEGIN
      WRITE(Power:3);
      WRITELN(EXP(LN(Base)*Power):20:0)
    END;
    
  WRITELN;
  WRITELN('Press ENTER to continue..');
  READLN
END.

(* OUTPUT *)
{
  Enter starting exponent:1
  Enter ending exponent:20
  
  Number  Power of two
  1                2
  2                4
  3                8
  4               16
  5               32
  6               64
  7              128
  8              256
  9              512
 10             1024
 11             2048
 12             4096
 13             8192
 14            16384
 15            32768
 16            65536
 17           131072
 18           262144
 19           524288
 20          1048576
 
Press ENTER to continue..
}

{ ------------------------------ Example 4-4 ------------------------------ }
PROGRAM AverageProg1(INPUT,OUTPUT);
VAR
  Average, Sum, Number :REAL;
  N, Kounter :INTEGER;
BEGIN
  Sum := 0;
WRITE('Enter Number of Elements:');
READLN(N);
FOR kounter := 1 TO N DO
BEGIN
WRITE('Enter Element #',kounter,': ');
READLN(Number);
Sum := Sum + Number
 { The semicolon is optional }
END;
Average := Sum / N;
WRITELN;
WRITELN('Sum of Numbers = ', Sum:0:2);
WRITELN('Average of Numbers = ', Average:0:2);
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

(* OUTPUT *)
{
   Enter Number of Elements: 5
   Enter Element #1: 1
   Enter Element #2: 2
   Enter Element #3: 3
   Enter Element #4: 4
   Enter Element #5: 5

   Sum of Numbers = 15.00
   Average of Numbers = 3.00

Press ENTER to continue..
}

{ ----------------------------- Example 4-5 ------------------------------- }
PROGRAM FactorialProg1(INPUT,OUTPUT);
VAR
Factorial
 :REAL;
Kounter, Number :INTEGER;
BEGIN
WRITE('Give me a number, and I will tell you the factorial: ');
READLN(Number);
Factorial := 1;
FOR kounter := Number DOWNTO 1 DO
Factorial := Factorial * Kounter;
WRITELN('The factorial of ', Number,' is ', Factorial:0:0);
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

(* OUTPUT *)
{
   Give me a number, and I will tell you the factorial: 8
   The factorial of 8 is 40320
   
Press ENTER to continue..
}

{------------------------------- Example 4-6 -------------------------------}
PROGRAM NestedLoops(OUTPUT);

VAR
  Row, Column :INTEGER;
  
BEGIN
  FOR Row := 1 TO 3 DO           { Start of the outer loop }
    BEGIN
      FOR Column := 1 to 5 DO    { Start of the inner loop }
        WRITE(Column, ' ');      { End of the inner loop }
      WRITELN                    { This statement belongs to the outer loop }
    END                          { The end of the outer loop }
END.

{ ------------------------------ Example 4-7 ------------------------------ }
PROGRAM AverageProg2(INPUT,OUTPUT);
VAR
Average, Sum, Number :REAL;
Kounter, N
 :INTEGER;
BEGIN
Sum := 0;
Kounter := 1;
WRITE('Enter Number of Elements:');
READLN(N);
WHILE Kounter <= N DO
BEGIN
WRITE('Enter Element #',Kounter,': ');
READLN(Number);
Sum := Sum + Number;
Kounter := Kounter + 1
END;
Average := Sum / N;
WRITELN;
WRITELN('Sum of Numbers = ', Sum:0:2);
WRITELN('Average of Numbers = ', Average:0:2);
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

(* OUTPUT *)
{
   Enter Number of Elements: 3
   Enter Element #1: 1
   Enter Element #2: 2
   Enter Element #3: 3
   
   Sum of Numbers = 6.00
   Average of Numbers = 2.00
   
Press ENTER to continue..
}

{ ------------------------------ Example 4-8 ------------------------------ }
PROGRAM AverageProg3(INPUT,OUTPUT);
VAR
Average, Sum, Number :REAL;
Kounter :INTEGER;
BEGIN
Sum := 0;
Average := 0;
Number := 0;
Kounter := 0;
WHILE Number<>-1 DO
BEGIN
Kounter := Kounter + 1;
Sum := Sum + Number;
WRITE('Enter element #',Kounter,' (or –1 to end): ');
READLN(Number)
END;
IF Kounter > 1 THEN
Average := Sum / (Kounter - 1);
WRITELN;
WRITELN('Sum of Numbers = ', Sum:0:2);
WRITELN('Average of Numbers = ', Average:0:2);
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

(* OUTPUT TRY 1 *)
{
   Enter element #1 (or -1 to end): 1
   Enter element #2 (or -1 to end): 2
   Enter element #3 (or -1 to end): 3
   Enter element #4 (or -1 to end): -1
   
   Sum of Numbers = 6.00
   Average of Numbers = 2.00
   
Press ENTER to continue..
}

(* OUTPUT TRY 2 *)
{
   Enter element #1 (or -1 to end): -1
   
   Sum of Numbers = 0.00
   Average of Numbers = 0.00
   
Press ENTER to continue..
}

{ ------------------------------- Example 4-9 ----------------------------- }
PROGRAM FactorialProg2(INPUT,OUTPUT);
VAR
Factorial
 :REAL;
Kounter, Number :INTEGER;
BEGIN
WRITE('Give me a number (or 0 to exit): ');
READLN(Number);
WHILE Number<>0 DO
 { Start of the WHILE loop }
BEGIN
Factorial := 1;
Kounter := 1;
REPEAT
 { Start of the REPEAT loop }
Factorial := Factorial * Kounter;
Kounter := Kounter + 1;
UNTIL Kounter = Number + 1; { End of the REPEAT loop }
WRITELN('The factorial of ', Number,' is ', Factorial:0:0);
WRITE('Give me a number (or 0 to exit): ');
READLN(Number)
END;
 { End of the WHILE loop }
WRITELN('I am out of here!')
END.

(* OUTPUT *)
{
   Give me a number (or 0 to exit): 3
   The factorial of 3 is 6
   Give me a number (or 0 to exit): 5
   The factorial of 5 is 120
   Give me a number (or 0 to exit): 0
   I am out of here!
}

{ ------------------------------ Example 5-1 ------------------------------ }
PROGRAM Enumeration1(OUTPUT);
VAR
  Month :(Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec);
BEGIN
  WRITELN;
  FOR Month := Jan TO Dec DO
    WRITE(ORD(Month),' ')
END.

(* OUTPUT *)
{
   0 1 2 3 4 5 6 7 8 9 10 11
}

{ ------------------------------ Example 5-2 ------------------------------ }
PROGRAM Subrange1(INPUT,OUTPUT);
VAR
  MonthNumber :1..12;
BEGIN
  WRITE('Please enter the number of the month: ');
  READLN(MonthNumber);
  CASE MonthNumber OF
    12, 1, 2 :WRITELN('This is wintertime.');
     3, 4, 5 :WRITELN('This is springtime.');
     6, 7, 8 :WRITELN('This is summertime.');
   9, 10, 11 :WRITELN('This is autumn.')
  END { END of CASE Construct }
END.

RUN 1:
Please enter the number of the month:2
This is wintertime.
RUN 2:
Please enter the number of the month: 14
Runtime error 201 at 0000:00BE.

{ ------------------------------ Example 5-3 ------------------------------ }
PROGRAM Scores1(INPUT,OUTPUT);
CONST
NumberOfClasses = 6;
VAR
Score :ARRAY[1..NumberOfClasses] OF REAL;
Average, SumOfScores :REAL;
Index
 :INTEGER;
BEGIN
{ Read the scores array }
{ --------------------- }
FOR Index := 1 TO NumberOfClasses DO
BEGIN
WRITE('Enter score for class #', Index,': ');
READLN(Score[Index])
END;
{ Calculate the sum }
{ ----------------- }
SumOfScores := 0;
FOR Index := 1 TO NumberOfClasses DO
SumOfScores := SumOfScores + Score[Index];
{ Calculate the average }
{ --------------------- }
Average := SumOfScores / NumberOfClasses;
{ Display Results }
{ --------------- }
WRITELN;
WRITELN('Sum of scores = ', SumOfScores:0:2);
WRITELN('Average of scores = ', Average:0:2);
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

(* OUTPUT *)
{
   Enter score for class #1: 90
   Enter score for class #2: 80
   Enter score for class #3: 85
   Enter score for class #4: 75
   Enter score for class #5: 89
   Enter score for class #6: 91
   
   Sum of scores = 510.00
   Average of scores = 85.00
   
Press ENTER to continue..
}

{ ------------------------------ Example 5-4 ------------------------------ }
PROGRAM Scores2(INPUT,OUTPUT);
CONST
  NumberOfClasses = 6;
  Tab = '         '; { 9 spaces }
VAR
  Score :ARRAY[1..NumberOfClasses] OF REAL;
  Average, SumOfScores :REAL;
  Index :INTEGER;
BEGIN
{ Read the scores array }
{ --------------------- }
  FOR Index := 1 TO NumberOfClasses DO
    BEGIN
      WRITE('Enter score for class #', Index,': ');
      READLN(Score[Index])
    END;
  
{ Calculate the sum }
{ ----------------- }
  SumOfScores := 0;
  
  FOR Index := 1 TO NumberOfClasses DO
    SumOfScores := SumOfScores + Score[Index];

{ Calculate the average }
{ --------------------- }
  Average := SumOfScores / NumberOfClasses;
  
{ Display Results }
{ --------------- }
  WRITELN;
  WRITELN(Tab,'CLASS #');
  WRITE('      '); { 6 spaces }
  
  FOR Index := 1 TO NumberOfClasses DO
    WRITE(Index:7);
    
  WRITELN;
  WRITE(Tab);
  
  FOR Index := 1 TO NumberOfClasses DO
    WRITE('-------');
    
  WRITELN;
  WRITE('SCORES ');
    
  FOR Index := 1 TO NumberOfClasses DO
    WRITE(Score[Index]:7:2);
    
  WRITELN;
  WRITE(Tab);
    
  FOR Index := 1 TO NumberOfClasses DO
    WRITE('-------');
    
  WRITELN;
  WRITELN(Tab,'Sum of scores = ', SumOfScores:0:2);
  WRITELN(Tab,'Average of scores = ', Average:0:2);
  WRITELN;
  WRITELN('Press ENTER to continue..');
  READLN
END.

(* OUTPUT *)
{
   Enter score for class #1: 90.5
   Enter score for class #2: 80.5
   Enter score for class #3: 86.2
   Enter score for class #4: 90.3
   Enter score for class #5: 74.8
   Enter score for class #6: 98.5
   
   CLASS #  1     2     3    4     5     6
   ------------------------------------------
   SCORES 90.50 80.50 86.20 90.30 74.80 98.50
   ------------------------------------------
       Sum of scores = 520.80
   Average of scores =  86.80

Press ENTER to continue..
}

{ ------------------------------ Example 5-5 ------------------------------ }
PROGRAM Sorting(INPUT,OUTPUT);
CONST
  ArraySize = 6;
TYPE
  Range = 1..ArraySize;
  NumbersArray = ARRAY[Range] OF INTEGER;
VAR
  Numbers :NumbersArray;
  I, J, Pot :INTEGER;
BEGIN
{ Read the array }
{ -------------- }
  FOR I := 1 TO ArraySize DO
    BEGIN
      WRITE('Enter element #', I,': ');
      READLN(Numbers[I])
    END;
{ Sort the array }
{ -------------- }
  FOR I := 1 TO ArraySize-1 DO              { outer loop }
    BEGIN                                   { optional block }
      FOR J := I+1 TO ArraySize DO          { inner loop }
        BEGIN
          IF Numbers[I] > Numbers[J] THEN
            BEGIN                           { swap contents }
              Pot := Numbers[J];
              Numbers[J] := Numbers[I];
              Numbers[I] := Pot
            END
          END     { end of inner loop }
        END;      { end of outer loop }
{ Display Results }
{ --------------- }
  WRITELN;
  WRITELN('The sorted array is:');
FOR I := 1 TO ArraySize DO
WRITELN(Numbers[I]);
WRITELN('Press ENTER to continue..');
READLN
END.
}

(* OUTPUT *)
{
   Enter element #1: 6
   Enter element #2: 33
   Enter element #3: 4
   Enter element #4: 2
   Enter element #5: 55
   Enter element #6: 9

   The sorted array is:
   2
   4
   6
   9
   33
   55
   
Press ENTER to continue...
}

{ ------------------------------ Example 5-6 ------------------------------ }
PROGRAM Scores3(INPUT,OUTPUT);
{ using two-dimensional array }
CONST
  NumberOfClasses = 3; { Change this number for more classes }
  NumberOfStudents = 4; { Change this number for more students }
  Tab = ' '; { 7 spaces }
  Dash = '-';
  NumberOfDashes = 23;
TYPE
  ScoreArray = ARRAY[1..NumberOfStudents, 1..NumberOfClasses] OF REAL;
  AverageArray = ARRAY[1..NumberOfStudents] OF REAL;
VAR
  Score:ScoreArray;
  Average :AverageArray;
  SumOfScores :REAL;
  StudentCount, ScoreCount, DashCount :INTEGER;
BEGIN
{ Read the scores array }
{ --------------------- }
  FOR StudentCount := 1 TO NumberOfStudents DO
    BEGIN
      WRITELN;
      WRITELN('Scores of student #', StudentCount,': ');
      
      FOR ScoreCount := 1 TO NumberOfClasses DO
        BEGIN
          WRITE('Enter score for class #', ScoreCount,': ');
          READLN(Score[StudentCount, ScoreCount])
        END;
      END;
      
{ Calculate the average for each student }
{ -------------------------------------- }
  FOR StudentCount := 1 TO NumberOfStudents DO
    BEGIN
      SumOfScores := 0; { Initialize for each student }
      
      FOR ScoreCount := 1 TO NumberOfClasses DO
        SumOfScores := SumOfScores + Score[StudentCount, ScoreCount];
        
      Average[StudentCount] := SumOfScores/NumberOfClasses
    END;
    
{ Display results }
{ --------------- }
  WRITELN;
  WRITELN(Tab, 'Student #', Tab, 'Average');
  WRITE(Tab);
  
  FOR DashCount := 1 TO NumberOfDashes DO
    WRITE(Dash);
    
  WRITELN;
  
  FOR StudentCount := 1 TO NumberOfStudents DO
    WRITELN(Tab, StudentCount:3, Tab, Average[StudentCount]:12:2);
    
  WRITE(Tab);
  
  FOR DashCount := 1 TO NumberOfDashes DO
    WRITE(Dash);
    
  WRITELN;
  WRITELN('Press ENTER to continue..');
  READLN
END.

(* OUTPUT *)
{

Scores of student #1:

Enter score for class #1: 90
Enter score for class #2: 89
Enter score for class #3: 93

Scores of student #2:

Enter score for class #1: 80
Enter score for class #2: 70
Enter score for class #3: 60

Scores of student #3:

Enter score for class #1: 77
Enter score for class #2: 78
Enter score for class #3: 90

Scores of student #4:

Enter score for class #1: 91
Enter score for class #2: 94
Enter score for class #3: 95

Student #     Average
-----------------------
    1         90.67
    2         70.00
    3         81.67
    4         93.33
-----------------------

Press ENTER to continue..
}

{ ------------------------------ Example 6-1 ------------------------------ }
PROGRAM Display1(INPUT,OUTPUT);
CONST
LF = CHR(10);
CR = CHR(13);
VAR
X, Y, Z :INTEGER;
BEGIN
WRITE('Enter three integers: ');
READLN(X, Y, Z);
WRITELN('X=', X, CR, LF, 'Y=', Y, CR, LF, 'Z=', Z)
END.

Sample run:
Enter three integers: 11 22 33
X=11
Y=22
Z=33

{ ------------------------------ Example 6-2 ------------------------------ }
PROGRAM ReadLnNumbers(INPUT,OUTPUT);
CONST
CR = CHR(13);
LF = CHR(10);
VAR
A, C , D, E :INTEGER;
B :REAL;
BEGIN
WRITE('Enter A, B, C: ');
{ If you enter more than three values, only the first three will be read }
READLN(A, B, C);
{ Now a subsequent READLN will start to read values after the End-Of-Line
mark, ignoring any leftovers from the previous read }
WRITE('Enter D, E: ');
READLN(D, E);
WRITELN('A=',A,', B=',B:0:2,', C=', C, CR, LF,
'D=', D,', E= ',E)
END.
Sample run:
Enter A, B, C: 1 2 3 4 5 6
Enter D, E: 7 8
A=1, B=2.00, C=3
D=7, E= 8
----> Enter these values
----> Enter these values
----> The program response

{ ------------------------------ Example 6-3 ------------------------------ }
PROGRAM CharRead1(INPUT,OUTPUT);
CONST
LF = CHR(10);
CR = CHR(13);
VAR
C1, C2, C3, C4 :CHAR;
BEGIN
WRITE('Enter four characters: ');
READ(C1, C2, C3, C4);
WRITELN('Your inputs have been assigned to the variables as follows:', CR,
LF,
'C1= ', C1, CR, LF,
'C2= ', C2, CR, LF,
'C3= ', C3, CR, LF,
'C4= ', C4);
WRITELN('The corresponding ASCII codes are:', CR, LF,
ORD(C1),' ', ORD(C2),' ', ORD(C3),' ',ORD(C4))
END.
The following are sample runs of the program.
RUN 1:
Enter four characters: A BCD
Your inputs have been assigned to the variables as follows:
C1= A
C2=
 { blank space }
C3= B
C4= C
The corresponding ASCII codes are:
65 32 66 67
The second variable was here assigned the ASCII code 32, which is the code for the
blank space.
RUN 2:
Enter four characters: ABCDEFG
Your inputs are assigned to the variables as follows:
C1= A
C2= B
C3= C
C4= D
The corresponding ASCII codes are:
65 66 67 68
RUN 3:
C1= A
C2= B
C3=
C4=
{ CR }
{ LF }
The corresponding ASCII codes are:
65 66 13 10

{ ------------------------------ Example 6-4 ------------------------------ }
PROGRAM CharReadln3(INPUT,OUTPUT);
CONST
LF = CHR(10);
CR = CHR(13);
VAR
C1, C2, C3, C4 :CHAR;
BEGIN
WRITE('Enter two characters: ');
READLN(C1, C2);
WRITE('Enter two characters: ');
READLN(C3, C4);
WRITELN('Your inputs have been assigned to the variables as follows:', CR,
LF,
'C1= ', C1, CR, LF,
'C2= ', C2, CR, LF,
'C3= ', C3, CR, LF,
'C4= ', C4);
WRITELN('The corresponding ASCII codes are:', CR, LF,
ORD(C1),' ', ORD(C2),' ', ORD(C3),' ',ORD(C4))
END.
Sample run:
Enter two characters: abcd
 <Enter>
Enter two characters: efgh
 <Enter>
Your inputs have been assigned to the variables as follows:
C1= a
C2= b
C3= e
C4= f
The corresponding ASCII codes are:
97 98 101 102

{ ------------------------------ Example 6-5 ------------------------------ }
PROGRAM CharNumRead(INPUT,OUTPUT);
CONST
LF = CHR(10);
CR = CHR(13);
VAR
A, B
 :CHAR;
X, Y
 :INTEGER;
BEGIN
WRITE('Enter two characters: ');
READLN(A, B);
WRITE('Enter two integers: ');
READLN(X, Y);
WRITELN('Your inputs have been assigned to the variables as follows:', CR,
LF,
'A= ', A, CR, LF,
'B= ', B, CR, LF,
'X= ', X, CR, LF,
'Y= ', Y)
RUN 1:
Enter two characters: ABCD
Enter two integers: 3 4
Your inputs have been assigned to the variables as follows:
A= A
B= B
X= 3
Y= 4
RUN 2:
Enter two characters: A
 <Enter>
B
 <Enter>
Enter two integers: 5 6
Your inputs have been assigned to the variables as follows:
A= A
B=
 { B is assigned a CR }
X= 5
Y= 6

{ ------------------------------ Example 6-6 ------------------------------ }
PROGRAM Scrambling(INPUT,OUTPUT);
TYPE
ScrambleArray = Array[1..4] OF CHAR;
VAR
A
 :ScrambleArray;
I1, I2, I3, I4 :INTEGER;
BEGIN
WRITE('Enter four letters: ');
READ(A[1], A[2], A[3], A[4]);
FOR I1 := 1 TO 4 DO
BEGIN
FOR I2 := 1 TO 4 DO
BEGIN
IF I2 <> I1 THEN
FOR I3 := 1 TO 4 DO
BEGIN
IF I3 <> I1 THEN
IF I3 <> I2 THEN
BEGIN
I4 := 10 – (I1 + I2 + I3);
WRITELN(A[I1],' ',A[I2],' ',
A[I3],' ',A[I4]);
END
 { End of IF }
END
 { End of I3 loop }
END
 { End of I2 loop }
{ End of I1 loop }
Sample run:
Enter four letters: ABCD
A B C D
A B D C
A C B D
A C D B
A D B C
A D C B
B A C D
B A D C
B C A D
B C D A
B D A C
B D C A
C A B D
C A D B
C B A D
C B D A
C D A B
C D B A
D A B C
D A C B
D B A C
D B C A
D C A B
D C B A

{ ------------------------------ Example 6-7 ----------------------------- }
PROGRAM CharCounter1(INPUT,OUTPUT);
VAR
Ch
 :CHAR;
Counter :INTEGER;
BEGIN
Counter := 0;
WHILE NOT EOLN DO
BEGIN
READ(Ch);
Counter := Counter + 1
END;
WRITELN;
WRITELN('Number of characters= ', Counter)
END.

{ ------------------------------ Example 6-8 ------------------------------ }
PROGRAM FreqCounter1(INPUT,OUTPUT);
VAR
Ch, SpecificChar
 :CHAR;
Counter, FreqCounter
 :INTEGER;
BEGIN
Counter := 0;
FreqCounter := 0;
WRITE('Enter the required letter: ');
READLN(SpecificChar);
WRITELN('Start typing. Press Ctrl-Z to finish.');
WHILE NOT EOF DO
BEGIN
WHILE NOT EOLN DO
BEGIN
READ(Ch);
IF (Ch >= 'A') AND (Ch <= 'Z') OR
(Ch >= 'a') AND (Ch <= 'z') THEN
Counter := Counter + 1;
IF Ch = SpecificChar THEN
Freqcounter := FreqCounter + 1;
END;
READLN
END;
WRITELN('Total number of letters= ', Counter);
WRITELN('The letter ''', SpecificChar, ''' was repeated ',
FreqCounter, ' time(s)');
WRITELN('Frequency of repetition= ', freqCounter/Counter*100:2:2,'%')
END.

Sample run:
Enter the required letter: a
Start typing. Press Ctrl-Z to finish.
This is a test to count the repetition frequency
of the letter "a" in a keyboard file
^Z
Total number of letters= 67
The letter 'a' was repeated 4 time(s)
Frequency of repetition= 5.97%

{ ------------------------------ Example 6-9 ------------------------------ }
PROGRAM String1(INPUT,OUTPUT);
CONST
LF = CHR(10);
VAR
Name :STRING[30];
I
 :INTEGER;
BEGIN
WRITE('Please enter a name: ');
READLN(Name);
FOR I := 1 TO LENGTH(Name) DO
WRITE(Name[I],LF)
END.
Sample run:
Please enter a name: PASCAL
P
A
S
C
A
L

{ ------------------------------ Example 6-10 ----------------------------- }
PROGRAM SortStrings(INPUT,OUTPUT);
CONST
Tab = '
 ';
NumOfElements = 4;
TYPE
StringArray = ARRAY[1..NumOfElements] OF STRING[30];
VAR
Name
 :StringArray;
I, J
 :INTEGER;
Temp
 :STRING[30];
BEGIN
{ Read the array elements }
{ ----------------------- }
FOR I := 1 TO NumOfElements DO
BEGIN
WRITE('Please enter name #', I, ': ');
READLN(Name[I])
END;
{ Sort names }
{ ---------- }
FOR I := 1 TO NumOfElements-1 DO
FOR J := I+1 TO NumOfElements DO
IF Name[I] > Name[J] THEN
BEGIN
Temp := Name[I];
Name[I] := Name[J];
Name[J] := Temp
END;
{ End of inner and outer loops }
{ Display sorted names }
{ -------------------- }
WRITELN('Serial #
 Name');
WRITELN('-----------------------------');
FOR I := 1 TO NumOfElements DO
WRITELN(I:2, Tab, Name[I])
END.
Sample run:
Please
 enter
 name
 #1:
 Rigby, Peter
Please
 enter
 name
 #2:
 Berlin, Amy
Please
 enter
 name
 #3:
 Sanders, Dale
Please
 enter
 name
 #4:
 Brady, Clark
Serial #
 Name
-----------------------------
1
 Berlin, Amy
2
 Brady, Clark
3
 Rigby, Peter
4
 Sanders, Dale

 { ------------------------------ Example 6-11 ------------------------------ }
PROGRAM StringFunctions1(INPUT,OUTPUT);
VAR
Name
 :STRING[30];
First, Middle, Last :STRING[10];
BEGIN
WRITE('Please enter your first name: ');
READLN(First);
First := CONCAT(First, ' ');
WRITE('Please enter your middle name: ');
READLN(Middle);
Middle := COPY(Middle, 1, 1);
Middle := CONCAT(Middle, '. ');
WRITE('Please enter your last name: ');
READLN(Last);
Name := CONCAT(First, Middle, Last);
WRITELN;
WRITELN('Your complete name is: ',Name)
END.
Sample run:
Please enter your first name: Sally
Please enter your middle name: Ann
Please enter your last name: Abolrous
Your complete name is: Sally A. Abolrous

{ ------------------------------ Example 7-1 ------------------------------ }
PROGRAM Procedures1(OUTPUT);
{ ------------ Beginning of Procedure ------------ }
PROCEDURE DrawLine;
CONST
Dash = '-';
LineLength = 20;
VAR
Counter :INTEGER;
BEGIN
FOR Counter := 1 TO LineLength DO
WRITE(Dash);
WRITELN
END;
{ --------------- End of Procedure --------------- }
{ ----------------- Main program ----------------- }
BEGIN
WRITELN;
DrawLine;
WRITELN('** THIS IS A TEST **');
Drawline
END.

The output is:
--------------------
** THIS IS A TEST **
--------------------

{ ------------------------------ Example 7-2 ------------------------------ }
PROGRAM Procedures2(OUTPUT);
VAR
Len
 :INTEGER;
TestSentence
 :STRING;
{ ------------ Beginning of Procedure ------------ }
PROCEDURE DrawLine(LineLength :INTEGER);
CONST
Dash = '-';
VAR
Counter :INTEGER;
BEGIN
FOR Counter := 1 TO LineLength DO
WRITE(Dash);
WRITELN
END;
{ --------------- End of Procedure --------------- }
{ ----------------- Main program ----------------- }
BEGIN
WRITE('Please enter a sentence: ');
READLN(TestSentence);
Len := LENGTH(TestSentence);
WRITELN;
DrawLine(Len);
WRITELN(TestSentence);
Drawline(Len)
END.
Sample run:
Please enter a sentence: Learn Pascal in Three Days
--------------------------
Learn Pascal in Three Days
--------------------------

{ ------------------------------ Example 7-3 -------------------------------}
PROGRAM VarParms(INPUT,OUTPUT);
VAR
a, b, c :REAL;
{ ------------ Procedure Definition -------------- }
PROCEDURE PowerOperator(X, Y :REAL; VAR Z:REAL);
BEGIN
Z := EXP(LN(X)*Y)
END;
{ ----------------- Main Program ----------------- }
BEGIN
WRITE('Enter the base and the exponent separated by a space:');
READLN(a,b);
PowerOperator(a, b, c);
WRITELN('The value of ',a:0:2,' raised to the power of ',b:0:2,' is ',c:0:2)
END.
Sample run:
Enter the base and the exponent separated by a space:2 5
The value of 2.00 raised to the power of 5.00 is 32.00
{ ------------------------------ Example 7-4 ------------------------------ }
PROGRAM Sorting(INPUT,OUTPUT);
CONST
ArraySize = 6;
TYPE
Range
 = 1..ArraySize;
NumbersArray = ARRAY[Range] OF INTEGER;
VAR
Numbers :NumbersArray;
{ ----------------- Read procedure --------------- }
PROCEDURE ReadNumbers(L: INTEGER; VAR R :NumbersArray);
VAR
I :INTEGER;
BEGIN
FOR I := 1 TO L DO
BEGIN
WRITE('Enter element #', I,': ');
READLN(R[I])
END
END;
{ ----------------- Sort procedure --------------- }
PROCEDURE SortNumbers(M: INTEGER; VAR S :NumbersArray);
VAR
I, J, Pot :INTEGER;
BEGIN
FOR I := 1 TO M-1 DO
FOR J := I+1 TO M DO
IF S[I] > S[J] THEN
BEGIN
 { Swap contents }
Pot := S[J];
S[J] := S[I];
S[I] := Pot
END
END;
{ ---------------- Print procedure --------------- }
PROCEDURE PrintNumbers(N: INTEGER; T :NumbersArray);
VAR
I :INTEGER;
BEGIN
WRITELN;
WRITE('The sorted array is: ');
FOR I := 1 TO N DO
WRITE(T[I],' ');
WRITELN;
END;
{ --------------- Main Program ------------------- }
BEGIN
ReadNumbers(ArraySize, Numbers);
SortNumbers(ArraySize, Numbers);
PrintNumbers(ArraySize, Numbers);
WRITELN('Press ENTER to continue..');
READLN
END.
Sample run:
Enter element #1: 44
Enter element #2: 22
Enter element #3: 8
Enter element #4: 1
Enter element #5: 667
Enter element #6: 3
The sorted array is: 1 3
 8
 22
 44
 667
Press ENTER to continue..

{ ------------------------------ Example 7-5 ------------------------------ }
PROGRAM Functions1(INPUT, OUTPUT);
VAR
A, B, C :REAL;
{ ------------ Beginning of Function ------------- }
FUNCTION Avg(X, Y, Z :REAL) :REAL;
BEGIN
AVG := (X + Y + Z) / 3
END;
{ --------------- End of Function ---------------- }
{ ----------------- Main program ----------------- }
BEGIN
WRITE('Enter three numbers: ');
READLN(A, B, C);
WRITELN('The average is= ', Avg(A, B, C):0:2)
END.
Sample run:
Enter three numbers: 2 3 8
The average is= 4.33

{ -------------------------------- Example 7-6 ---------------------------- }
PROGRAM Parent;
{ --------------- PROCEDURE KID1 --------------- }
PROCEDURE Kid1(...);
...
BEGIN
...
END; { --------- END OF PROCEDURE KID1 --------- }
{ ---------------- PROCEDURE KID2 -------------- }
PROCEDURE Kid2(...);
...
BEGIN
...
END; { --------- END OF PROCEDURE KID2 --------- }
{ ------------------------------ MAIN PROGRAM ---------------------------- }
BEGIN
...
END.

PROGRAM Parent;
{ Forward declaration of Kid2 }
PROCEDURE Kid2(...); FORWARD;
{ Definition of Kid1 }
PROCEDURE Kid1(...);
...
{ Definition of Kid2 }
PROCEDURE Kid2(...);
...
{ Main program }
...

{ -------------------------------- Example 7-7 ---------------------------- }
PROGRAM Parent;
{ ------------------- PROCEDURE KID -------------------- }
PROCEDURE Kid(...);
...
{ ------------ PROCEDURE GRANDKID ----------- }
PROCEDURE GrandKid(...);
BEGIN
...
END; { ----- END OF PROCEDURE GRANDKID ----- }
BEGIN
...
END; { ------------- END OF PROCEDURE KID -------------- }
{ ----------------------------- MAIN PROGRAM ---------------------------- }
BEGIN
...
END.

{ ------------------------------ Example 7-8 ------------------------------ }
PROGRAM FunctionRecursion(INPUT, OUTPUT);
VAR
A :INTEGER;
{ ------------- Function Definition -------------- }
FUNCTION Factorial(X :INTEGER) :REAL;
BEGIN
IF X <= 1 THEN
Factorial := 1
ELSE
Factorial := X * Factorial(X-1);
END;
{ --------------- End of Function ---------------- }
{ ----------------- Main program ----------------- }
BEGIN
WRITE('Enter a number: ');
READLN(A);
WRITELN('The Factorial of ', A,' = ', Factorial(A):0:0)
END.
Sample run:
Enter a number: 6
The Factorial of 6 = 720

{ ------------------------------ Example 8-1 ------------------------------ }
PROGRAM TextAnalyzer(INPUT,OUTPUT);
TYPE
LowerCase = SET OF 'a'..'z';
UpperCase = SET OF 'A'..'Z';
Digits
 = SET OF '0'..'9';
Characters = SET OF CHAR;
VAR
Capital
 :UpperCase;
Small
 :LowerCase;
Numerals
 :Digits;
Alphabet, Punctuation, Others :Characters;
A, C, S, N, P, O, Counter
 :INTEGER;
Ch
 :CHAR;
BEGIN
Counter := 0; { counter of all characters }
A := 0;
 { counter of alphabetic characters }
C := 0;
 { counter of capital letters }
S := 0;
 { counter of small letters }
N := 0;
 { counter of numeric characters }
P := 0;
 { counter of punctuation characters }
O := 0;
 { counter of other characters }
Small := ['a'..'z'];
Capital := ['A'..'Z'];
Alphabet := Small + Capital;
Numerals := ['0'..'9'];
Punctuation := [',',';','-','''','.','!','?',')','(','"',':','_'];
WRITELN('Start typing your text file. To terminate press Ctrl-Z:');
WHILE NOT EOF DO
BEGIN
WHILE NOT EOLN DO
BEGIN
READ(Ch);
Counter := Counter + 1;
IF Ch IN Alphabet THEN
BEGIN
A := A + 1;
IF Ch IN Small THEN
S := S + 1
ELSE IF Ch IN Capital THEN
C := C + 1
END
ELSE IF Ch IN Numerals THEN
N := N + 1
ELSE IF Ch IN Punctuation THEN
P := P + 1
ELSE
O := O + 1
END;
READLN
END;
WRITELN('Total number of characters
 = ', Counter);
WRITELN('Number of alphabetic characters
 = ', A);
WRITELN(' .Number of lowercase letters: ', S);
WRITELN(' .Number of uppercase letters: ', C);
WRITELN('Number of numeric characters
 = ', N);
WRITELN('Number of punctuation characters = ', P);
WRITELN('Number of other characters
 = ', O)
END.
Sample run:
Start typing your text file. To terminate press Ctrl-Z:
The standard set operators are:
1. Union (+).
2. Intersection (*).
3. Difference (-).
^Z
 ----> Press Ctrl+Z to end the text
Total number of characters
 = 85
Number of alphabetic characters
 = 53
.Number of lowercase letters: 49
.Number of uppercase letters: 4
Number of numeric characters
 = 3
Number of punctuation characters
 = 14
Number of other characters
 = 15

 {------------------------------- Example 8-2 -------------------------------}
PROGRAM RecordExample1(OUTPUT);
TYPE
EmployeeRecord = RECORD
Name
 :STRING[25];
Address
 :STRING[40];
Phone
 :STRING[12];
Rate
 :REAL;
MaritalStatus
 :CHAR;
END;
VAR
EmployeeRec :EmployeeRecord;
BEGIN
{ Assign values to the fielded variables }
EmployeeRec.Name := 'Diane J. Bedford';
EmployeeRec.Address := '20 Carmen Avenue, New Orleans, LA 70112';
EmployeeRec.Phone := '504-666-5043';
EmployeeRec.Rate := 28.5;
EmployeeRec.MaritalStatus := 'S';
{ Display record information }
WRITELN('Employee Name:
 ', EmployeeRec.Name);
WRITELN('Address:
 ', EmployeeRec.Address);
WRITELN('Telephone #:
 ', EmployeeRec.Phone);
WRITELN('Hourly Rate:
 $', EmployeeRec.Rate:0:2);
WRITELN('Marital Status: ', EmployeeRec.MaritalStatus)
END.
The output is:
Employee Name:
 Diane J. Bedford
Address:
 20 Carmen Avenue, New Orleans, LA 70112
Telephone #:
 504-666-5043
Hourly Rate:
 $28.50
Marital Status:
 S

 {------------------------------- Example 8-3 -------------------------------}
PROGRAM RecordExample2(OUTPUT);
TYPE
EmployeeRecord = RECORD
Name
 :STRING[25];
Address
 :STRING[40];
Phone
 :STRING[12];
Rate
 :REAL;
MaritalStatus
 :CHAR;
END;
VAR
EmployeeRec
 :EmployeeRecord;
{ ------------ Procedure DrawLine -------------- }
PROCEDURE DrawLine(LineLength, TabLength :INTEGER);
CONST
Dash = '-';
VAR
Counter :INTEGER;
BEGIN
FOR Counter := 1 TO TabLength DO
WRITE(' ');
FOR Counter := 1 TO LineLength DO
WRITE(Dash);
WRITELN
END;
{ ------------- Procedure GetData -------------- }
PROCEDURE GetData(VAR Employee :EmployeeRecord);
{Name,Address,Phone,Rate,MaritalStatus);}
{ Assign values to fields }
BEGIN
WITH Employee DO
BEGIN
Name := 'Diane J. Bedford';
Address := '20 Carmen Avenue, New Orleans, LA 70112';
Phone := '504-666-5043';
Rate := 28.5;
MaritalStatus := 'S'
END
END;
{ ----------- Procedure DisplayInfo ------------ }
PROCEDURE DisplayInfo(Employee :EmployeeRecord);
{ Display record information }
CONST
Header ='Record of ';
VAR
Len, Tab, Counter :INTEGER;
HeaderText, Status :STRING;
BEGIN
WITH Employee DO
BEGIN
HeaderText := CONCAT(Header,Name);
Len := LENGTH(HeaderText);
Tab := (80- Len) DIV 2;
DrawLine(Len, Tab);
FOR Counter := 1 TO Tab DO
WRITE(' ');
WRITELN(HeaderText);
DrawLine(Len, Tab);
WRITELN('Address:
 ', Address);
WRITELN('Telephone #:
 ', Phone);
WRITELN('Hourly Rate:
 $', Rate:0:2);
IF MaritalStatus = 'M' THEN
Status := 'Married'
ELSE
Status := 'Single';
WRITELN('Marital Status: ', Status)
END
END;
{ --------------- Main Program ----------------- }
BEGIN
GetData(EmployeeRec);
DisplayInfo(EmployeeRec)
END.
The output is:
---------------------------
Record of Diane J. Bedford
---------------------------
Address:
 20 Carmen Avenue, New Orleans, LA 70112
Telephone #:
 504-666-5043
Hourly Rate:
 $28.50
Marital Status:
 Single
{ ------------------------------ Example 8-4 ------------------------------ }
PROGRAM NestedRecord(OUTPUT);
TYPE
AddressRecord
 = RECORD
Street
 :STRING[18];
City
 :STRING[15];
State
 :STRING[2];
Zip
 :String[5];
END;
EmployeeRecord = RECORD
Name
 :STRING[25];
AddressRec
 :AddressRecord;
Phone
 :STRING[12];
Rate
 :REAL;
MaritalStatus
 :CHAR;
END;
VAR
EmployeeRec
 :EmployeeRecord;
BEGIN
EmployeeRec.Name := 'Jean L. Krauss';
EmployeeRec.AddressRec.Street := '15 Darell Street';
EmployeeRec.AddressRec.City := 'Bloomingdale';
EmployeeRec.AddressRec.State := 'IL';
EmployeeRec.AddressRec.Zip := '60108';
EmployeeRec.Phone := '312-987-5432';
EmployeeRec.Rate := 27.5;
EmployeeRec.MaritalStatus := 'M';
WRITELN('Employee Name:
 ', EmployeeRec.Name);
WRITELN('Address:
 ', EmployeeRec.AddressRec.Street);
WRITELN('
 ', EmployeeRec.AddressRec.City);
WRITE('
 ', EmployeeRec.AddressRec.State);
WRITELN(' ', EmployeeRec.AddressRec.Zip);
WRITELN('Telephone #:
 ', EmployeeRec.Phone);
WRITELN('Hourly Rate:
 $', EmployeeRec.Rate:0:2);
WRITELN('Marital Status: ', EmployeeRec.MaritalStatus)
END.
The output is:
Employee Name:
 Jean L. Krauss
Address:
 15 Darell Street
Bloomingdale
IL 60108
Telephone #:
 312-987-5432
Hourly Rate:
 $27.50
Marital Status:
 M

 { ------------------------------ Example 9-1 ------------------------------ }
PROGRAM TextAnalyzer2(OUTPUT,DiskFile);
{ Reading from a disk text file one character at a time }
TYPE
LowerCase = SET OF 'a'..'z';
UpperCase = SET OF 'A'..'Z';
Digits
 = SET OF '0'..'9';
Characters = SET OF CHAR;
VAR
DiskFile
 :TEXT;
 { declare a text file variable }
Capital
 :UpperCase;
Small
 :LowerCase;
Numerals
 :Digits;
Alphabet, Punctuation, Others :Characters;
A, C, S, N, P, O, Counter
 :INTEGER;
Ch
 :CHAR;
BEGIN
{ Link the file variable to the file 'CONFIG.SYS' in the current directory }
ASSIGN(DiskFile, 'CONFIG.SYS');
{ Open the file for input }
RESET(DiskFile);
{ The program logic }
Counter := 0; { counter of all characters }
A := 0;
 { counter of alphabetic characters }
C := 0;
 { counter of capital letters }
S := 0;
 { counter of small letters }
N := 0;
 { counter of numeric characters }
P := 0;
 { counter of punctuation characters }
O := 0;
 { counter of other characters }
Small := ['a'..'z'];
Capital := ['A'..'Z'];
Alphabet := Small + Capital;
Numerals := ['0'..'9'];
Punctuation := [',',';','-','''','.','!','?',')','(','"',':','_'];
{ Check for the end of the disk file }
WHILE NOT EOF(DiskFile) DO
BEGIN
{ Check for the end of line in the disk file }
WHILE NOT EOLN(DiskFile) DO
BEGIN
{ Read one character from the disk file }
READ(DiskFile,Ch);
Counter := Counter + 1;
IF Ch IN Alphabet THEN
BEGIN
A := A + 1;
IF Ch IN Small THEN
S := S + 1
ELSE IF Ch IN Capital THEN
C := C + 1
END
ELSE IF Ch IN Numerals THEN
N := N + 1
ELSE IF Ch IN Punctuation THEN
P := P + 1
ELSE
O := O + 1
END;
{ Advance the pointer to the next line }
READLN(DiskFile)
END;
{ End of the file is reached }
{ Close the file }
CLOSE(DiskFile);
{ Display the report }
WRITELN;
WRITELN('Total number of characters
 = ',
 Counter);
WRITELN('Number of alphabetic characters
 = ',
 A);
WRITELN(' .Number of lowercase letters: ', S);
WRITELN(' .Number of uppercase letters: ', C);
WRITELN('Number of numeric characters
 = ',
 N);
WRITELN('Number of punctuation characters = ',
 P);
WRITELN('Number of other characters
 = ',
 O);
WRITELN('Press ENTER to continue..');
READLN
END.
Listing of the file CONFIG.SYS:
DEVICE=C:\SCSI\ASPI2DOS.SYS /D /Z /P140
DEVICE=C:\SCSI\ASPICD.SYS /D:ASPICD0
device=C:\WINDOWS\himem.sys
[common]
DEVICE=C:\CDROM\AOATAPI.SYS /D:IDECD000
The program output is:
Total number of characters
 = 149
Number of alphabetic characters
 = 107
.Number of lowercase letters: 20
.Number of uppercase letters: 87
Number of numeric characters
 = 8
Number of punctuation characters
 = 10
Number of other characters
 = 24
Press ENTER to continue..

{ ------------------------------ Example 9-2 ------------------------------ }
PROGRAM ReadTextFile(INPUT,OUTPUT,DiskFile);
{ Reading a text file stored on the disk }
CONST
{ You may replace the following constant by any existing file name }
FileName = 'C:\CONFIG.SYS';
VAR
DiskFile :TEXT;
Ch
 :CHAR;
BEGIN
ASSIGN(DiskFile, FileName);
RESET(DiskFile);
WHILE NOT EOF(DiskFile) DO
BEGIN
WHILE NOT EOLN(DiskFile) DO
BEGIN
{ Read and display one character from the text file }
READ(DiskFile,Ch);
WRITE(Ch)
END;
{ Advance the pointer to the next line }
READLN(DiskFile);
{ Advance one line on the screen }
WRITELN
END;
CLOSE(DiskFile);
WRITELN('Press ENTER to continue..');
READLN
END.
The output may look something like this:
DEVICE=C:\SCSI\ASPI2DOS.SYS /D /Z /P140
DEVICE=C:\SCSI\ASPICD.SYS /D:ASPICD0
device=C:\WINDOWS\himem.sys
[common]
DEVICE=C:\CDROM\AOATAPI.SYS /D:IDECD000
Press ENTER to continue..

{ ------------------------------ Example 9-3 ------------------------------ }
PROGRAM DisplayTextFile(OUTPUT,MyFile);
{ Reading a text file stored on the disk one line at a time }
VAR
MyFile
 :TEXT;
OneLine, FileName :STRING[80];
BEGIN
WRITE('Please enter the file name to be displayed: ');
READLN(FileName);
WRITELN;
WRITELN('The contents of the file ',FileName,' are: ');
ASSIGN(MyFile, FileName);
RESET(MyFile);
{ Check for the end of the text file }
WHILE NOT EOF(MyFile) DO
BEGIN
{ Read and display the text file one line at a time }
READLN(MyFile,OneLine);
WRITELN(OneLine);
END;
CLOSE(MyFile);
WRITELN('Press ENTER to continue..');
READLN
END.
Please enter the file name to be displayed: CNFIG.SYS
The contents of the file CNFIG.SYS are:
Runtime error 002 at 0000:00F2.

{ ------------------------------ Example 9-4 ------------------------------ }
PROGRAM ReadMultipleStrings1(OUTPUT,F);
VAR
F
 :TEXT;
Str1,Str2,Str3 :STRING[5];
BEGIN
ASSIGN(F,'test.txt');
RESET(F);
READLN(F,Str1,Str2,Str3);
WRITELN('Str1= ', Str1);
WRITELN('Str2= ', Str2);
WRITELN('Str3= ', Str3);
CLOSE(F);
WRITELN('Press ENTER to continue..');
READLN
END.
The output is:
Str1= This
Str2= is a
Str3= test

{ ------------------------------- Example 9-5 ----------------------------- }
PROGRAM CreateFile(F);
CONST
TestSentence = 'Hello Pascal';
VAR
F :TEXT;
BEGIN
ASSIGN(F, 'HELLO.TXT'); { Turbo only }
REWRITE(F);
 { open the file for output }
WRITELN(F, TestSentence);
CLOSE(F)
END.

{ ------------------------------- Example 9-6 ----------------------------- }
PROGRAM CreateEmpFile(INPUT,OUTPUT,F);
TYPE
AddressRecord
 = RECORD
Street
 :STRING[18];
City
 :STRING[15];
State
 :STRING[2];
Zip
 :String[5];
END;
EmployeeRecord = RECORD
ID
 :INTEGER;
Name
 :STRING[20];
AddressRec
 :AddressRecord;
Phone
 :STRING[12];
Rate
 :REAL;
MaritalStatus
 :CHAR;
END;
VAR
F
 :TEXT;
 { The file variable }
EmployeeRec :EmployeeRecord;
BEGIN
ASSIGN(F, 'EMPFILE.TXT');
REWRITE(F);
WITH EmployeeRec DO
WITH AddressRec DO
BEGIN
WRITE('Please enter Employee ID: '); READLN(ID);
WRITE('Employee Name: ');
 READLN(Name);
WRITE('Address: Street: ');
 READLN(Street);
WRITE('
 City: ');
 READLN(City);
WRITE('
 State: ');
 READLN(State);
WRITE('
 Zip code: ');
 READLN(Zip);
WRITE('Phone Number: ');
 READLN(Phone);
WRITE('Hourly Rate: ');
 READLN(Rate);
WRITE('Marital Status (S/M): ');
 READLN(MaritalStatus);
{ Store the information to the file }
WRITELN(F, ID);
WRITELN(F, Name);
WRITELN(F, Street);
WRITELN(F, City);
WRITELN(F, State);
WRITELN(F, Zip);
WRITELN(F, Phone);
WRITELN(F, Rate:0:2);
WRITELN(F, MaritalStatus)
END;
CLOSE(F)
END.

Sample run:
Please enter Employee ID: 122
Employee Name: Tammy M. Ockman
Address: Street: 322 Temple Dr.
City: New Orleans
State: LA
Zip code: 70112
Phone Number: 504-285-3434
Hourly Rate: 22.45
Marital Status (S/M): S
The following is a display of the file contents:
122
Tammy M. Ockman
322 Temple Dr.
New Orleans
LA
70112
504-285-3434
22.45
S

{ ------------------------------- Example 9-7 ----------------------------- }
PROGRAM PayRoll(INPUT,OUTPUT,MasterFile,PayFile);
{ This program reads the file EMPFILE.TXT, calculates the wages, and
stores the information to the file PAYFILE.TXT }
TYPE
AddressRecord
 = RECORD
Street
 :STRING[18];
City
 :STRING[15];
State
 :STRING[2];
Zip
 :STRING[5];
END;
EmployeeRecord = RECORD
ID
 :INTEGER;
Name
 :STRING[20];
AddressRec
 :AddressRecord;
Phone
 :STRING[12];
Rate
 :REAL;
MaritalStatus
 :CHAR;
END;
PayRecord = RECORD
ID
 :INTEGER;
Name :STRING[20];
Wages :REAL;
END;
VAR
MasterFile, PayFile :TEXT;
EmployeeRec
 :EmployeeRecord;
PayRec
 :PayRecord;
HoursWorked, Wages :REAL;
{ --------------- Procedure GetInfo ------------------ }
{ This procedure reads the employee file EMPFILE.TXT
and displays the ID, Name, and Hourly Rate.
 }
PROCEDURE GetInfo(VAR F:TEXT);
BEGIN
WITH EmployeeRec DO
WITH AddressRec DO
BEGIN
READLN(F,ID);
 WRITELN('ID: ',ID);
READLN(F,Name);
 WRITELN('Name: ',Name);
READLN(F,Street);
READLN(F,City);
READLN(F,State);
READLN(F,Zip);
READLN(F,Phone);
READLN(F,Rate);
 WRITELN('Hourly rate: $', Rate:0:2);
READLN(F,MaritalStatus);
END;
END;

{ --------------- Procedure CalcWages ---------------- }
{ This procedure is used to calculate wages.
The result is returned to the main program }
PROCEDURE CalcWages(HoursWorked:REAL; VAR Wages:REAL);
BEGIN
WITH EmployeeRec DO
Wages := Hoursworked * Rate;
Wages := ROUND(100 * Wages) / 100
 { rounding cents }
END;
{ -------------- Procedure FilePayRoll --------------- }
{ This procedure is used to write one record to
the output file PAYFILE.TXT
 }
PROCEDURE FilePayRoll(VAR P :TEXT; Wages :REAL);
BEGIN
WITH EmployeeRec DO
BEGIN
PayRec.ID := ID;
PayRec.Name := Name;
Payrec.Wages := Wages
END;
WITH PayRec DO
WRITELN(P, ID:3, Name:20, Wages:10:2)
END;
{ --------------- Main Program ------------------ }
BEGIN
ASSIGN(MasterFile, 'EMPFILE.TXT');
 RESET(MasterFile);
ASSIGN(Payfile, 'PAYFILE.TXT');
 REWRITE(PayFile);
WHILE NOT EOF(MasterFile) DO
BEGIN
GetInfo(MasterFile);
WRITE('Please enter hours worked for this pay period: ');
READLN(HoursWorked);
CalcWages(HoursWorked, Wages);
FilePayRoll(PayFile, Wages)
END;
CLOSE(MasterFile);
CLOSE(PayFile)
END.
Sample run:
Assume that the file EMPFILE.TXT contains three records. The program will use
these records as follows:
ID: 122
 ----> Information from file
Name: Tammy M. Ockman
 ----> Information from file
Hourly rate: $22.45
 ----> Information from file
Please enter hours worked for this pay period: 160
 ----> Entered by user
ID: 123
Name: Tara S. Strahan
Hourly rate: $15.24
Please enter hours worked for this pay period: 160
ID: 125
Name: John G. Trainer
Hourly rate: $28.55
Please enter hours worked for this pay period: 140.5
The program creates the file PAYFILE.TXT containing the following records:
122
 Tammy M. Ockman
 3592.00
123
 Tara S. Strahan
 2438.40
125
 John G. Trainer
 4011.28

 { ------------------------------ Example 9-8 ------------------------------ }
PROGRAM EmpPayInfo(INPUT,OUTPUT,F);
{ This program is used to create a user-defined file EMPFILE.BIN
whose components are records. }
TYPE
EmployeeRecord = RECORD
ID
 :INTEGER;
Name
 :STRING[20];
Rate
 :REAL;
END;
EmpFileRec = FILE OF EmployeeRecord;
VAR
F
 :EmpFileRec;
 { The file variable }
EmployeeRec :EmployeeRecord;
{ ----------- Procedure WriteRecord ---------- }
PROCEDURE WriteRecord;
BEGIN
{ Store one record in the file }
WRITE(F, EmployeeRec)
END;
{ ----------- Procedure GetData ---------- }
PROCEDURE getdata;
VAR
Counter :INTEGER;
BEGIN
Counter := 0;
WITH EmployeeRec DO
BEGIN
WRITE('Please enter Employee ID (or 0 to end):'); READLN(ID);
WHILE ID <> 0 DO
BEGIN
Counter := Counter + 1;
WRITE('Employee Name: '); READLN(Name);
WRITE('Hourly Rate: ');
 READLN(Rate);
WriteRecord;
WRITE('Please enter Employee ID (or 0 to end):'); READLN(ID)
END
END;
WRITELN(Counter, ' Employee records have been filed.')
END;
{ ---------------- Main Program -------------- }
{ Main Program }
BEGIN
ASSIGN(F, 'EMPFILE.BIN');
 REWRITE(F);
GetData;
CLOSE(F);
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------ Example 9-9 ------------------------------ }
PROGRAM PayRoll2(INPUT,OUTPUT,MasterFile,PayFile);
{ This program reads the file EMPFILE.BIN one record at a time,
then calculates wages and stores the output in the text file
PAYFILE.TXT }
TYPE
EmployeeRecord = RECORD
ID
 :INTEGER;
Name :STRING[20];
Rate :REAL;
END;
PayRecord = RECORD
ID
 :INTEGER;
Name :STRING[20];
Wages :REAL;
END;
EmployeeFile = FILE OF EmployeeRecord;
VAR
MasterFile
 :EmployeeFile;
PayFile
 :TEXT;
EmployeeRec
 :EmployeeRecord;
PayRec
 :PayRecord;
HoursWorked, Wages :REAL;

{ --------------- Procedure GetInfo ------------------ }
{ This Procedure reads and displays a record from
the file EMPFILE.BIN
 }
PROCEDURE GetInfo(VAR F :EmployeeFile);
BEGIN
READ(F,EmployeeRec);
WITH EmployeeRec DO
BEGIN
WRITELN('ID: ',ID);
WRITELN('Name: ',Name);
WRITELN('Hourly rate: $', Rate:0:2);
END;
END;
{ --------------- Procedure CalcWages ---------------- }
PROCEDURE CalcWages(HoursWorked :REAL; VAR Wages :REAL);
BEGIN
WITH EmployeeRec DO
Wages := Hoursworked * Rate;
Wages := ROUND(100 * Wages) / 100
 { rounding cents }
END;
{ -------------- Procedure FilePayRoll --------------- }
{ This procedure writes a record to PAYFILE.TXT
 }
PROCEDURE FilePayRoll(VAR P :TEXT; Wages :REAL);
BEGIN
WITH EmployeeRec DO
BEGIN
PayRec.ID := ID;
PayRec.Name := Name;
Payrec.Wages := Wages
END;
WITH PayRec DO
BEGIN
WRITELN(P, ID);
WRITELN(P, Name);
WRITELN(P, Wages);
end;
END;
{ -------------- Procedure ReadPayRoll --------------- }
{ This procedure reads and displays PAYFILE.TXT
 }
PROCEDURE ReadPayRoll(VAR P:TEXT);
VAR
I :INTEGER;
BEGIN
WITH PayRec DO
BEGIN
READLN(P, ID);
READLN(P, Name);
READLN(P, Wages);
WRITE(ID:3,' ');
WRITE(Name);
{ Fill the rest of the 20 places with blanks }

FOR I := 1 TO 20-LENGTH(Name) DO
WRITE(' ');
WRITELN(' $',Wages:0:2)
END;
END;
{ --------------- Main Program ------------------ }
BEGIN
ASSIGN(MasterFile, 'EMPFILE.BIN');
 RESET(MasterFile);
ASSIGN(Payfile, 'PAYFILE.TXT');
 REWRITE(PayFile);
WHILE NOT EOF(MasterFile) DO
BEGIN
GetInfo(MasterFile);
WRITE('Please enter hours worked for this pay period: ');
READLN(HoursWorked);
CalcWages(HoursWorked, Wages);
FilePayRoll(PayFile, Wages)
END;
CLOSE(MasterFile);
CLOSE(PayFile);
RESET(PayFile);
WRITELN('--------- PayRoll Summary --------- ');
WRITELN('ID # ------- Name -------- Salary');
WHILE NOT EOF(PayFile) DO
ReadPayroll(PayFile);
WRITELN('----------------------------------- ');
CLOSE(PayFile);
WRITELN('Press ENTER to continue..');
READLN
END.

{ --------------- Procedure Menu ------------------ }
PROCEDURE Menu;
VAR
Option :INTEGER;
BEGIN
WRITELN(Header);
WRITELN;
WRITELN('1. Display employee file.');
WRITELN('2. Display an employee record.');
WRITELN('3. Add a new employee.');
WRITELN('4. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1 : Readit(DbFile);
2 : ReadRec(DbFile, EmployeeRec);
3 : AddRec(NewFile, DbFile, EmployeeRec);
4 : Exit
END;
Menu
END;

{ ------------------------- Example 10-1 ----------------------------- }
PROGRAM EmployeeDataBase2(INPUT, OUTPUT, PayrollFile, NewFile);
CONST
FileName = 'payroll.txt';
TempFile = 'temp.txt';
Header = '------------- Main Menu --------------';
Header1 = '--------- Employee DataBase ----------';
Header2 = '---------- Employee Record -----------';
Separator = '--------------------------------------';
TYPE
EmployeeRecord = RECORD
ID
 :STRING[5];
Name, Position
 :STRING[20];
SSN
 :STRING[11];
CASE Category
 :CHAR OF
'1': (MonthlySalary
 :REAL);
'2': (HourlyRate
 :REAL);
'3': (Commission,
BasicSalary
 :REAL;
Area
 :STRING[20])
END;
VAR
NewFile, PayrollFile
 :TEXT;
EmployeeRec
 :EmployeeRecord;
Title
 :ARRAY [1..9] OF STRING[20];
OneLine
 :STRING[80];
{ ------------------------- Procedure ReadRec ------------------------ }
PROCEDURE ReadRec(VAR PayrollFile: TEXT; Employee: EmployeeRecord);
VAR
SSNumber
 :STRING[11];
Found
 :INTEGER;
BEGIN
Found := 0;
 {Reset the flag}
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WRITELN;
WRITE('Please enter the SSN of the employee: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber = SSN THEN
BEGIN
WRITELN(Header2);
WRITELN(Title[1], ID);
WRITELN(Title[2], Name);
WRITELN(Title[3], Position);
WRITELN(Title[4], SSN);
CASE Category OF
'1': WRITELN(Title[5], MonthlySalary:0:2);
'2': WRITELN(Title[6], HourlyRate:0:2);
'3': BEGIN
WRITELN(Title[7], Commission:0:2);
WRITELN(Title[8], BasicSalary:0:2);
WRITELN(Title[9], Area)
END
END;
 { End of CASE structure }
Found := 1
END
END
 { End of WITH block }
END;
CLOSE(PayrollFile);
IF Found <> 1 THEN
BEGIN
WRITELN('SSN not found in file.');
WRITELN('Please try again.');
WRITELN
END
END;
{ ------------------------- Procedure AddRec ------------------------- }
PROCEDURE AddRec(VAR NewFile, PayrollFile: TEXT;
Employee: EmployeeRecord);
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
{ Check for the end of the text file }
WHILE NOT EOF(PayrollFile) DO
BEGIN
{ Copy each record from PayrollFile to the NewFile }
READLN(PayrollFile, OneLine);
WRITELN(NewFile, OneLine)
END;
{ Accept a new record from the keyboard }
WITH Employee DO
BEGIN
WRITE('Please enter Employee ID: ');
READLN(ID);
WRITE('Name: ');
 READLN(Name);
WRITE('Position: ');
 READLN(Position);
WRITE('SSN (xxx-xx-xxxx): ');
 READLN(SSN);
WRITE('Payroll category: ');
 READLN(Category);
CASE Category OF
'1': BEGIN
WRITE('Monthly Salary: ');
READLN(MonthlySalary);
END;
'2': BEGIN
WRITE('Rate: ');
READLN(HourlyRate);
END;
'3': BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITE('Basic salary: ');
READLN(BasicSalary);
WRITE('Area: ');
READLN(Area)
END
END;
{ Store the information in NewFile }
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1': WRITELN(NewFile, MonthlySalary:0:2);
'2': WRITELN(NewFile, HourlyRate:0:2);
'3': BEGIN
WRITELN(NewFile, Commission:0:2);
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area)
END
END
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile, OneLine);
WRITELN(PayrollFile, OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile)
END;
{ ------------------------- Procedure Menu --------------------------- }
PROCEDURE Menu;
VAR
Option: INTEGER;
BEGIN
WRITELN(Header);
WRITELN;
WRITELN('1. Display an employee record.');
WRITELN('2. Add a new employee.');
WRITELN('3. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1: ReadRec(PayrollFile, EmployeeRec);
2: AddRec(NewFile, PayrollFile, EmployeeRec);
3: Exit
END;
Menu
END;
{ --------------------------- Main Program --------------------------- }
BEGIN
{ Assign titles }
Title[1] := 'ID: ';
Title[2] := 'Name: ';
Title[3] := 'Position: ';
Title[4] := 'SSN: ';
Title[5]
 :=
 'Salary: ';
Title[6]
 :=
 'Rate: ';
Title[7]
 :=
 'Commission: ';
Title[8]
 :=
 'Basic Salary: ';
Title[9]
 :=
 'Area: ';
Menu
END.

Sample runs:

 ------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Exit.
--------------------------------------
Make a choice and press a number: 1
Please enter the SSN of the employee: 434-55-6666
---------- Employee Record -----------
ID: 1MGT1
Name: James A. Abolrous
Position: President
SSN: 434-55-6666
Salary: 4343.88
------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Exit.
--------------------------------------
Make a choice and press a number: 1
Please enter the SSN of the employee: 404-38-1132
---------- Employee Record -----------
ID: 2STF1
Name: Tara S. Strahan
Position: Secretary II
SSN: 404-38-1132
Rate: 8.24
------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Exit.
--------------------------------------
Make a choice and press a number: 1
Please enter the SSN of the employee: 334-88-1234
---------- Employee Record -----------
ID: 3SAL4
Name: John G. Trainer
Position: Sales Representative
SSN: 334-88-1234
Commission: 0.25
Basic Salary: 500.00
Area: Baton Rouge, LA
------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Exit.
--------------------------------------
Make a choice and press a number: 1
Please enter the SSN of the employee: 555-55-5555
SSN not found in file.
Please try again.
------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Exit.
--------------------------------------
Make a choice and press a number: 3
------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Exit.
--------------------------------------
Make a choice and press a number: 2
Please enter Employee ID: 3SAL6
Name: Barbara Ortiz
Position: Sales Representative
SSN (xxx-xx-xxxx): 347-12-3456
Payroll category: 3
Commission: .15
Basic salary: 450.0
Area: New Orleans, LA
------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Exit.
--------------------------------------
Make a choice and press a number: 3

{ ------------------------- Procedure DelRec ------------------------- }
PROCEDURE DelRec(VAR NewFile, PayrollFile: TEXT;
Employee: EmployeeRecord);
VAR
SSNumber: STRING[11];
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WRITE('Please enter the SSN of the employee to be deleted: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber <> SSN THEN
BEGIN
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1': WRITELN(NewFile, MonthlySalary:0:2);
'2': WRITELN(NewFile, HourlyRate:0:2);
'3': BEGIN
WRITELN(NewFile, Commission:0:2);
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area)
END
END;
 { End of CASE structure }
END
END
 { End of WITH block }
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile, OneLine);
WRITELN(PayrollFile, OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile);
WRITELN('The employee ', SSNumber, ' is removed from file.')
END;

{ ------------------------- Procedure Menu --------------------------- }
PROCEDURE Menu;
VAR
Option: INTEGER;
BEGIN
WRITELN(Header);
WRITELN;
WRITELN('1. Display an employee record.');
WRITELN('2. Add a new employee.');
WRITELN('3. Delete an employee.');
WRITELN('4. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1: ReadRec(PayrollFile, EmployeeRec);
2: AddRec(NewFile, PayrollFile, EmployeeRec);
3: DelRec(NewFile, PayrollFile, EmployeeRec);
4: Exit
END;
Menu
END;

{ ------------------------- Example 10-2 ----------------------------- }
PROGRAM EmployeeDataBase2(INPUT, OUTPUT, PayrollFile, NewFile);
CONST
FileName = 'payroll.txt';
TempFile = 'temp.txt';
Header = '------------- Main Menu --------------';
Header1 = '--------- Employee DataBase ----------';
Header2 = '---------- Employee Record -----------';
Separator = '--------------------------------------';
TYPE
EmployeeRecord = RECORD
ID
 :STRING[5];
Name, Position
 :STRING[20];
SSN
 :STRING[11];
CASE Category
 :CHAR OF
'1': (MonthlySalary
 :REAL);
'2': (HourlyRate
 :REAL);
'3': (Commission,
BasicSalary
 :REAL;
Area
 :STRING[20])
END;
VAR
NewFile, PayrollFile
 :TEXT;
EmployeeRec
 :EmployeeRecord;
Title
 :ARRAY [1..9] OF STRING[20];
OneLine
 :STRING[80];
{ ------------------------- Procedure ReadRec ------------------------ }
PROCEDURE ReadRec(VAR PayrollFile: TEXT; Employee: EmployeeRecord);
VAR
SSNumber
 :STRING[11];
Found
 :INTEGER;
BEGIN
Found := 0;
 {Reset the flag}
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WRITELN;
WRITE('Please enter the SSN of the employee: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber = SSN THEN
BEGIN
WRITELN(Header2);
WRITELN(Title[1], ID);
WRITELN(Title[2], Name);
WRITELN(Title[3], Position);
WRITELN(Title[4], SSN);
CASE Category OF
'1': WRITELN(Title[5], MonthlySalary:0:2);
'2': WRITELN(Title[6], HourlyRate:0:2);
'3': BEGIN
WRITELN(Title[7], Commission:0:2);
WRITELN(Title[8], BasicSalary:0:2);
WRITELN(Title[9], Area)
END
END;
 { End of CASE structure }
Found := 1
END
END
 { End of WITH block }
END;
CLOSE(PayrollFile);
IF Found <> 1 THEN
BEGIN
WRITELN('SSN not found in file.');
WRITELN('Please try again.');
WRITELN
END
END;
{ ------------------------- Procedure AddRec ------------------------- }
PROCEDURE AddRec(VAR NewFile, PayrollFile: TEXT;
Employee: EmployeeRecord);
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
{ Check for the end of the text file }
WHILE NOT EOF(PayrollFile) DO
BEGIN
{ Copy each record from PayrollFile to the NewFile }
READLN(PayrollFile, OneLine);
WRITELN(NewFile, OneLine)
END;
{ Accept a new record from the keyboard }
WITH Employee DO
BEGIN
WRITE('Please enter Employee ID: ');
READLN(ID);
WRITE('Name: ');
 READLN(Name);
WRITE('Position: ');
 READLN(Position);
WRITE('SSN (xxx-xx-xxxx): ');
 READLN(SSN);
WRITE('Payroll category: ');
 READLN(Category);
CASE Category OF
'1': BEGIN
WRITE('Monthly Salary: ');
READLN(MonthlySalary);
END;
'2': BEGIN
WRITE('Rate: ');
READLN(HourlyRate);
END;
'3': BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITE('Basic salary: ');
READLN(BasicSalary);
WRITE('Area: ');
READLN(Area)
END
END;
{ Store the information in NewFile }
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1': WRITELN(NewFile, MonthlySalary:0:2);
'2': WRITELN(NewFile, HourlyRate:0:2);
'3': BEGIN
WRITELN(NewFile, Commission:0:2);
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area)
END
END
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile, OneLine);
WRITELN(PayrollFile, OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile)
END;
{ ------------------ Procedure DelRec --------------------- }
PROCEDURE DelRec(VAR NewFile, PayrollFile: TEXT;
Employee: EmployeeRecord);
VAR
SSNumber: STRING[11];
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WRITE('Please enter the SSN of the employee to be deleted: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber <> SSN THEN
BEGIN
WRITELN(NewFile,ID);
WRITELN(NewFile,Name);
WRITELN(NewFile,Position);
WRITELN(NewFile,SSN);
WRITELN(NewFile,Category);
CASE Category OF
'1': WRITELN(NewFile,MonthlySalary:0:2);
'2': WRITELN(NewFile,HourlyRate:0:2);
'3': BEGIN
WRITELN(NewFile,Commission:0:2);
WRITELN(NewFile,BasicSalary:0:2);
WRITELN(NewFile,Area)
END
END; { End of CASE structure }
END
END { End of WITH block }
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile,OneLine);
WRITELN(PayrollFile,OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile);
WRITELN('The employee ', SSNumber, ' is removed from file.')
END;
{ ------------------------- Procedure Menu --------------------------- }
PROCEDURE Menu;
VAR
Option: INTEGER;
BEGIN
WRITELN(Header);
WRITELN;
WRITELN('1. Display an employee record.');
WRITELN('2. Add a new employee.');
WRITELN('3. Delete an employee.');
WRITELN('4. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1: ReadRec(PayrollFile, EmployeeRec);
2: AddRec(NewFile, PayrollFile, EmployeeRec);
3: DelRec(NewFile, PayrollFile, EmployeeRec);
4: Exit
END;
Menu
END;
{ --------------------------- Main Program --------------------------- }
BEGIN
{ Assign titles }
Title[1] := 'ID: ';
Title[2] := 'Name: ';
Title[3] := 'Position: ';
Title[4] := 'SSN: ';
Title[5] := 'Salary: ';
Title[6] := 'Rate: ';
Title[7] := 'Commission: ';
Title[8] := 'Basic Salary: ';
Title[9] := 'Area: ';
Menu
END.
Sample run:
The following is a sample run to delete the record of the employee whose SSN is
347-12-3456. The user input is italicized and bolded for clarity.
------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Delete an employee.
4. Exit.
--------------------------------------
Make a choice and press a number: 3
Please enter the SSN of the employee to be deleted: 347-12-3456
The employee 347-12-3456 is removed from file.
------------- Main Menu --------------
1. Display an employee record.
2. Add a new employee.
3. Delete an employee.
4. Exit.
--------------------------------------
Make a choice and press a number: 4

{ ---------------------- Procedure UpdateRec ------------------------- }
PROCEDURE UpdateRec(VAR NewFile, PayrollFile: TEXT;
Employee: EmployeeRecord);
VAR
SSNumber
 :STRING[11];
Found
 :INTEGER;
BEGIN
Found := 0;
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WRITE('Please enter the SSN of the employee to be updated: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber <> SSN THEN
BEGIN
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1': WRITELN(NewFile, MonthlySalary:0:2);
'2': WRITELN(NewFile, HourlyRate:0:2);
'3': BEGIN
WRITELN(NewFile, Commission:0:2);
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area);
END
END; { End of CASE structure }
END
ELSE
BEGIN
Found := 1;
WRITELN('Please enter the updated information:');
WRITE('ID: ');
 READLN(ID);
WRITELN(NewFile, ID);
WRITE('Name: ');
 READLN(Name);
WRITELN(NewFile, Name);
WRITE('Position: ');
 READLN(Position);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITE('Category: ');
 READLN(Category);
WRITELN(NewFile, Category);
CASE Category OF
'1': BEGIN
WRITE('Salary: ');
READLN(MonthlySalary);
WRITELN(NewFile, MonthlySalary:0:2)
END;
'2': BEGIN
WRITE('Hourly Rate: ');
READLN(HourlyRate);
WRITELN(NewFile, HourlyRate:0:2)
END;
'3': BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITELN(NewFile, Commission:0:2);
WRITE('Basic Salary: ');
READLN(BasicSalary);
WRITELN(NewFile, BasicSalary:0:2);
ND
END;
 { End of CASE structure }
END
END { End of WITH block }
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile, OneLine);
WRITELN(PayrollFile, OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile);
{ User Messages }
IF Found =1 THEN
WRITELN('The employee ', SSNumber, ' is updated.')
ELSE
BEGIN
WRITELN('The SSN ', SSNumber, ' is not found.');
WRITELN('Check the number and try again.');
WRITELN
END
END;

{ ------------------------- Procedure Menu --------------------------- }
PROCEDURE Menu;
VAR
Option: INTEGER;
BEGIN
WRITELN(Header);
WRITELN;
WRITELN('1. Display an employee record.');
WRITELN('2. Add a new employee.');
WRITELN('3. Delete an employee.');
WRITELN('4. Update an employee record.');
WRITELN('5. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1: ReadRec(PayrollFile, EmployeeRec);
2: AddRec(NewFile, PayrollFile, EmployeeRec);
3: DelRec(NewFile, PayrollFile, EmployeeRec);
4: UpdateRec(NewFile, PayrollFile, EmployeeRec);
5: Exit
END;
Menu
END;

{ -------------------------- Example 10-3 ----------------------------- }
PROGRAM EmployeeDataBase2(INPUT, OUTPUT, PayrollFile, NewFile);
CONST
FileName = 'payroll.txt';
TempFile = 'temp.txt';
Header = '------------- Main Menu --------------';
Header1 = '--------- Employee DataBase ----------';
Header2 = '---------- Employee Record -----------';
Separator = '--------------------------------------';
TYPE
EmployeeRecord = RECORD
ID
 :STRING[5];
Name, Position
 :STRING[20];
SSN
 :STRING[11];
CASE Category
 :CHAR OF
'1': (MonthlySalary :REAL);
'2': (HourlyRate
 :REAL);
'3': (Commission,
BasicSalary :REAL;
Area
 :STRING[20])
END;
SSNstring = STRING[11];
VAR
NewFile, PayrollFile :TEXT;
EmployeeRec
 :EmployeeRecord;
Title
 :ARRAY [1..9] OF STRING[20];
OneLine
 :STRING[80];
{ ------------------------- Procedure SearchRec --------------------- }
PROCEDURE SearchRec(VAR PayrollFile: TEXT;
Employee: EmployeeRecord;
SSNumber: SSNstring;
VAR Found: INTEGER);
BEGIN
Found := 0;
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber = SSN THEN
Found := 1;
END { End of WITH block }
END;
CLOSE(PayrollFile);
END;
{ ------------------------- Procedure ReadRec ------------------------ }
PROCEDURE ReadRec(VAR PayrollFile: TEXT;
Employee: EmployeeRecord);
VAR
SSNumber :STRING[11];
Found
 :INTEGER;
BEGIN
WRITELN;
WRITE('Please enter the SSN of the employee: ');
READLN(SSNumber);
SearchRec(PayrollFile, EmployeeRec, SSNumber, Found);
IF Found =1 THEN
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber = SSN THEN
BEGIN
WRITELN(Header2);
WRITELN(Title[1],ID);
WRITELN(Title[2],Name);
WRITELN(Title[3],Position);
WRITELN(Title[4], SSN);
CASE Category OF
'1': WRITELN(Title[5], MonthlySalary:0:2);
'2': WRITELN(Title[6], HourlyRate:0:2);
'3': BEGIN
WRITELN(Title[7], Commission:0:2);
WRITELN(Title[8], BasicSalary:0:2);
WRITELN(Title[9], Area)
END
END; { End of CASE structure }
END
END { End of WITH block }
END;
CLOSE(PayrollFile)
END
ELSE
 { If not found }
BEGIN
WRITELN('SSN not found in file.');
WRITELN('Please try again.');
WRITELN
END
END;
{ ------------------------- Procedure DelRec ------------------------- }
PROCEDURE DelRec(VAR NewFile, PayrollFile: TEXT;
Employee: EmployeeRecord);
VAR
SSNumber: STRING[11];
Found
 :INTEGER;
BEGIN
WRITE('Please enter the SSN of the employee to be deleted: ');
READLN(SSNumber);
SearchRec(PayrollFile, EmployeeRec, SSNumber, Found);
IF Found =1 THEN
BEGIN
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber <> SSN THEN
BEGIN
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1': WRITELN(NewFile, MonthlySalary:0:2);
'2': WRITELN(NewFile, HourlyRate:0:2);
'3': BEGIN
WRITELN(NewFile, Commission:0:2);
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area)
END
END; { End of CASE structure }
END;
END { End of WITH block }
END; {End of DO }
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile, OneLine);
WRITELN(PayrollFile, OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile);
{ User Messages }
WRITELN('The employee ', SSNumber,
' is removed from file.')
END { End of the "IF Found.." block }
ELSE { IF not found }
BEGIN
WRITELN('The SSN ', SSNumber, ' is not found.');
WRITELN('Check the number and try again.');
WRITELN
END
END;
{ -------------------------- Procedure AddRec ------------------------ }
PROCEDURE AddRec(VAR NewFile, PayrollFile: TEXT;
Employee: EmployeeRecord);
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
{ Copy each record from PayrollFile to the NewFile }
READLN(PayrollFile, OneLine);
WRITELN(NewFile, OneLine)
END;
{ Accept a new record from the keyboard }
WITH Employee DO
BEGIN
WRITE('Please enter Employee ID: ');
READLN(ID);
WRITE('Name: ');
 READLN(Name);
WRITE('Position: ');
 READLN(Position);
WRITE('SSN (xxx-xx-xxxx): '); READLN(SSN);
WRITE('Payroll category: ');
 READLN(Category);
CASE Category OF
'1': BEGIN
WRITE('Monthly Salary: ');
READLN(MonthlySalary)
END;
'2': BEGIN
WRITE('Rate: ');
READLN(HourlyRate)
END;
'3': BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITE('Basic salary: ');
READLN(BasicSalary);
WRITE('Area: ');
READLN(Area)
END
END;
{ Store the information in NewFile }
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1': WRITELN(NewFile, MonthlySalary:0:2);
'2': WRITELN(NewFile, HourlyRate:0:2);
'3': BEGIN
WRITELN(NewFile, Commission:0:2);
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area)
END
END
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile, OneLine);
WRITELN(PayrollFile, OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile)
END;
{ ---------------------- Procedure UpdateRec ------------------------- }
PROCEDURE UpdateRec(VAR NewFile, PayrollFile: TEXT;
Employee: EmployeeRecord);
VAR
SSNumber
 :STRING[11];
Found
 :INTEGER;
BEGIN
WRITE('Please enter the SSN of the employee to be updated: ');
READLN(SSNumber);
SearchRec(PayrollFile, EmployeeRec, SSNumber, Found);
IF Found =1 THEN
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1': READLN(PayrollFile, MonthlySalary);
'2': READLN(PayrollFile, HourlyRate);
'3': BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber <> SSN THEN
BEGIN
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1': WRITELN(NewFile, MonthlySalary:0:2);
'2': WRITELN(NewFile, HourlyRate:0:2);
'3': BEGIN
WRITELN(NewFile, Commission:0:2);
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area)
END
END { End of CASE structure }
END { End of IF block }
ELSE
BEGIN
WRITELN('Please enter the updated information:');
WRITE('ID: ');
 READLN(ID);
WRITELN(NewFile, ID);
WRITE('Name: ');
 READLN(Name);
WRITELN(NewFile, Name);
WRITE('Position: ');
 READLN(Position);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITE('Category: ');
 READLN(Category);
WRITELN(NewFile, Category);
CASE Category OF
'1': BEGIN
WRITE('Salary: ');
READLN(MonthlySalary);
WRITELN(NewFile, MonthlySalary:0:2)
END;
'2': BEGIN
WRITE('Hourly Rate: ');
READLN(HourlyRate);
WRITELN(NewFile, HourlyRate:0:2)
END;
'3': BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITELN(NewFile, Commission:0:2);
WRITE('Basic Salary: ');
READLN(BasicSalary);
WRITELN(NewFile, BasicSalary:0:2);
WRITE('Area: ');
READLN(Area);
WRITELN(NewFile, Area)
END
END
 { End of CASE structure }
END { End of ELSE block }
END { End of WITH block }
END; { End of DO }
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile, OneLine);
WRITELN(PayrollFile, OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile); { Erase the temporary file }
CLOSE(PayrollFile);
{ User Messages }
WRITELN('The employee ', SSNumber, ' is updated.')
END { End of IF block }
ELSE
BEGIN
WRITELN('The SSN ', SSNumber, ' is not found.');
WRITELN('Check the number and try again.');
WRITELN
END
END;
{ -------------------------- Procedure Menu -------------------------- }
PROCEDURE Menu;
VAR
Option: INTEGER;
BEGIN
WRITELN(Header);
WRITELN;
WRITELN('1. Display an employee record.');
WRITELN('2. Add a new employee.');
WRITELN('3. Delete an employee.');
WRITELN('4. Update an employee record.');
WRITELN('5. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1: ReadRec(PayrollFile, EmployeeRec);
2: AddRec(NewFile, PayrollFile, EmployeeRec);
3: DelRec(NewFile, PayrollFile, EmployeeRec);
4: UpdateRec(NewFile, PayrollFile, EmployeeRec);
5: Exit
END;
Menu
END;
{ --------------------------- Main Program --------------------------- }
BEGIN
{ Assign titles }
Title[1] := 'ID: ';
Title[2] := 'Name: ';
Title[3] := 'Position: ';
Title[4] := 'SSN: ';
Title[5] := 'Salary: ';
Title[6] := 'Rate: ';
Title[7] := 'Commission: ';
Title[8] := 'Basic Salary: ';
Title[9] := 'Area: ';
Menu
END.

{ ---------------------------- Example 11-1 -------------------------------- }
PROGRAM PointerExample(OUTPUT);
VAR
MyIntegerPointer
MyInteger
:^INTEGER;
:INTEGER;
BEGIN
MyInteger := 50;
NEW(MyIntegerPointer);
MyIntegerPointer^ := 500;
MyInteger := MyIntegerPointer^;
WRITELN('The value of MyInteger is: ', MyInteger);
WRITELN('The value pointed to by MyIntegerPointer is: '
, MyIntegerPointer^);
DISPOSE(MyIntegerPointer);
WRITELN('Press any key to continue...');
READLN
END.

{ -------------------- Example 11-2 ------------------------ }
PROGRAM PointerExample2(OUTPUT);
TYPE
intptr = ^INTEGER;
realptr = ^REAL;
VAR
MyIntegerPointer, AnotherIntPointer :intptr;
MyRealPointer
 :realptr;
BEGIN
NEW(MyIntegerPointer);
NEW(MyRealPointer);
NEW(AnotherIntPointer);
MyRealPointer^ := 2.25;
MyIntegerPointer^ := 500;
AnotherIntPointer^ := 400;
{ Copy contents of locations:}
MyRealPointer^ := MyIntegerPointer^;
{ Redirect MyIntegerPointer:}
MyIntegerPointer := AnotherIntPointer;
WRITELN('MyRealPointer is pointing to: ', MyRealPointer^:2:2);
WRITELN;
{Check if the two pointers point to the same location:}
IF (MyIntegerPointer = AnotherIntPointer) THEN
WRITELN('Yes, The two integer pointers are pointing to the same
location.');
WRITELN('MyIntegerPointer is pointing to: ', MyIntegerPointer^);
WRITELN('AnotherIntPointer is pointing to: ', AnotherIntPointer^);
WRITELN;
{ Note: The DISPOSE procedure is not necessary, for any one of the
pointers, in this program. }
DISPOSE(MyIntegerPointer);
DISPOSE(MyRealPointer);
{DISPOSE(AnotherIntPointer);} {illegal now..}
WRITELN('Press any key to continue...');
READLN
END.
When you run this program, it will display the following messages:
MyRealPointer is pointing to: 500.00
Yes, The two integer pointers are pointing to the same location.
MyIntegerPointer is pointing to: 400
AnotherIntPointer is pointing to: 400
Press any key to continue...

{ -------------------- Example 11-3 ------------------------ }
PROGRAM PointersToRecords(OUTPUT);
TYPE
emprec = RECORD
ID:INTEGER;
Wage: REAL;
END;
empptr = ^emprec;
VAR
ptr1, ptr2 : empptr;
BEGIN
NEW(ptr1);
NEW(ptr2);
{ Assign values to the fields }
ptr1^.ID := 123;
ptr1^.Wage := 25.5;
ptr2^.ID := 456;
ptr2^.Wage := 33.25;
{Print contents:}
WRITELN('Before redirection of ptr1:');
WRITELN('Ptr1 points
 to ID:', ptr1^.ID,
',
 and Wage: $', ptr1^.Wage:2:2);
WRITELN('Ptr2 points
 to ID:', ptr2^.ID,
',
 and Wage: $', ptr2^.Wage:2:2);
{Redirect ptr1:}
ptr1 := ptr2;
{Print contents:}
WRITELN;
WRITELN('After redirection of ptr1:');
WRITELN('Ptr1 points to ID:', ptr1^.ID,
', and Wage: $', ptr1^.Wage:2:2);
WRITELN('Ptr2 points to ID:', ptr2^.ID,
', and Wage: $', ptr2^.Wage:2:2);
WRITELN('Press any key to continue...');
READLN
END.
When you run this program, the following results are displayed on the screen:
Before redirection of ptr1:
Ptr1 points to ID: 123, and Wage: $25.50
Ptr2 points to ID: 456, and Wage: $33.25
After redirection of ptr1:
Ptr1 points to ID: 456, and Wage: $33.25
Ptr2 points to ID: 456, and Wage: $33.25
Press any key to continue...

{ ---------------------------- Example 11-4 -------------------------------- }
PROGRAM LinkedListDemo(INPUT, OUTPUT);
CONST
Header = '------------- Main Menu --------------';
Separator = '--------------------------------------';
TYPE
DataString = STRING[30];
ListPointer = ^ListRecord;
ListRecord = RECORD
DataField :DataString;
NextField :ListPointer
END;
VAR
FirstPointer :ListPointer;
{ --------------------------- Procedure BuildList -------------------------- }
PROCEDURE BuildList(VAR FirstPointer :ListPointer;
DataItem :DataString);
{Note: FirstPointer is passed using the VAR keyword because it will be updated
by this procedure.}
VAR
ToolPointer:ListPointer;
BEGIN
NEW(ToolPointer);
ToolPointer^.DataField := DataItem;
ToolPointer^.NextField := FirstPointer;
FirstPointer := ToolPointer
END;

{ -------------------------- Procedure ReadList ---------------------------- }
PROCEDURE ReadList(FirstPointer :ListPointer);
VAR
CurrentPointer :ListPointer;
BEGIN
CurrentPointer := FirstPointer;
WHILE CurrentPointer <> NIL DO
BEGIN
WRITELN(CurrentPointer^.DataField);
CurrentPointer := CurrentPointer^.NextField
END;
WRITELN
END;
{ -------------------------- Procedure GetData------------------------------ }
PROCEDURE GetData(VAR FirstPointer :ListPointer);
{Note: FirstPointer is passed using the VAR keyword because it will be updated
when passed to BuildList procedure.}
VAR
Name:DataString;
BEGIN
WRITELN('Enter the names to be added to the list,',
' when finished hit ENTER.');
{ Read the first data item }
READLN(Name);
{ Check for end-of-data }
WHILE LENGTH(Name) <> 0 DO
BEGIN
BuildList(FirstPointer, Name);
READLN(Name)
END
END;
{ ------------------------- Procedure DisplayInfo -------------------------- }
PROCEDURE DisplayInfo(FirstPointer :ListPointer);
BEGIN
WRITELN(Separator);
WRITELN('The contents of the list: ');
ReadList(FirstPointer);
WRITE('Hit any key to continue...');
READLN
END;
{ --------------------------- Procedure Menu ------------------------------- }
PROCEDURE Menu;
VAR
Option:INTEGER;
BEGIN
WRITELN(Header);
WRITELN('1. Store data in a list.');
WRITELN('2. Display the list.');
WRITELN('3. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1 : GetData(FirstPointer);
2 : DisplayInfo(FirstPointer);
3 : Exit
END;
Menu
END;
{ ----------------------------- Main Program ------------------------------- }
BEGIN
{ Initialize an empty list }
FirstPointer := NIL;
menu
END.

Sample run:
------------- Main Menu --------------
1. Store data in a list.
2. Display the list.
3. Exit.
--------------------------------------
Make a choice and press a number: 1
Enter the names to be added to the list, when finished hit ENTER.
John Smith
 <ENTER> -----> Names entered from the keyboard
Jean Murdock
 <ENTER>
Sally Bedford
 <ENTER>
Deanna Loerwold
 <ENTER>
<ENTER>
------------- Main Menu --------------
1. Store data in a list.
2. Display the list.
3. Exit.
--------------------------------------
Make a choice and press a number: 2
--------------------------------------
The contents of the list:
Deanna Loerwold
 ----->
 Notice the sequence of names
Sally Bedford
Jean Murdock
John Smith
Hit any key to continue...
------------- Main Menu --------------
1. Store data in a list.
2. Display the list.
3. Exit.
--------------------------------------
Make a choice and press a number: 3

{ ----------------------------- Example 11-5 ------------------------------- }
PROGRAM LinkedListDB(INPUT, OUTPUT, MyListFile);
{ This program processes an employee database as list of records. }
CONST
FileName = 'emplist.bin';
Header = '------------- Main Menu --------------';
Separator = '--------------------------------------';
TYPE
{Declaration of data type }
SSNstring = STRING[11];
DataRecord = RECORD
ID
Name, Position
:STRING[5];
:STRING[20];
SSN
 :SSNstring;
Rate
 :REAL
END;
{Declaration of the list }
ListPointer = ^ListRecord;
ListRecord = RECORD
DataField :DataRecord;
NextField :ListPointer
END;
EmpFile = FILE OF DataRecord;
VAR
FirstPointerMyListFile
EmpRecord
:ListPointer;
:EmpFile;
:DataRecord;
{ -------------------------- Procedure SearchList -------------------------- }
PROCEDURE SearchList(FirstPointer :ListPointer;
VAR CurrentPointer :ListPointer;
SSNumber :SSNstring;
VAR Found :BOOLEAN);
{ This procedure searches the linked list for an employee's SSN. If found, the
value of the boolean flag Found becomes TRUE, and the CurrentPointer points to
the required node. }
BEGIN
CurrentPointer := FirstPointer;
WHILE (CurrentPointer <> NIL) AND (NOT Found) DO
IF CurrentPointer^.DataField.SSN = SSNumber THEN
Found := TRUE
ELSE
CurrentPointer := CurrentPointer^.NextField;
END;
{ -------------------------- Procedure BuildList --------------------------- }
PROCEDURE BuildList(VAR FirstPointer :ListPointer;
DataItem :DataRecord);
{ This procedure builds the linked list, or adds nodes to it.}
{Note: The FirstPointer is passed using the VAR keyword as it will be updated
by this procedure. }
VAR
ToolPointer :ListPointer;
BEGIN
NEW(ToolPointer);
ToolPointer^.DataField := DataItem;
ToolPointer^.NextField := FirstPointer;
FirstPointer := ToolPointer
END;

{ -------------------------- Procedure ReadList ---------------------------- }
PROCEDURE ReadList(FirstPointer :ListPointer);
{ This procedure reads and displays the contents of the list. }
VAR
CurrentPointer:ListPointer;
BEGIN
CurrentPointer := FirstPointer;
WHILE CurrentPointer <> NIL DO
BEGIN
WITH CurrentPointer^.DataField DO
BEGIN
WRITE(ID :7);
WRITE(Name :22);
WRITE(Position :22);
WRITE(SSN :13);
WRITELN(' $' ,Rate :0:2)
END;
CurrentPointer := CurrentPointer^.NextField
END;
WRITELN
END;
{ -------------------------- Procedure GetData ----------------------------- }
PROCEDURE GetData(VAR FirstPointer :ListPointer);
{ This procedure receives the employee data from the keyboard, and passes the
record information to the procedure BuildList to be added to the linked list. }
VAR
Item:DataRecord;
BEGIN
WRITELN('Please enter the record information,',
' when finished hit ENTER.');
{ Read the first data item }
WITH Item DO
BEGIN
WRITE('ID: ');
 READLN(ID);
WRITE('Name: ');
 READLN(Name);
WRITE('Position: ');
 READLN(Position);
WRITE('SSN: ');
 READLN(SSN);
WRITE('Rate: ');
 READLN(Rate);
WRITE(Separator)
END;
BuildList(FirstPointer, Item);
END;
{ ------------------------ Procedure DisplayItAll -------------------------- }
PROCEDURE DisplayItAll(FirstPointer :ListPointer);
{ This procedures displays the headers of the fields in the proper format and
calls the procedure ReadList to display the contents of the list. }
BEGIN
WRITELN(Separator);
WRITELN('The contents of the list: ');
WRITELN('ID' :7, 'Name' :22, 'Position' :22, 'SSN' :13,
'Rate' :7);
WRITELN;
ReadList(FirstPointer);
WRITE('Hit any key to continue...');
READLN
END;
{ -------------------------- Procedure DisplayRec -------------------------- }
PROCEDURE DisplayRec(FirstPointer :ListPointer);
{ This procedure displays the information for a specific employee. It calls the
procedure SearchList to search the list using the social security number of the
employee. If found, the information is displayed, otherwise a message "not
found" is issued. }
VAR
CurrentPointerSSNumber
Found
:ListPointer;
:SSNstring;
:BOOLEAN;
BEGIN
Found := FALSE;
WRITELN(Separator);
WRITE('Enter the SSN for the employee:'); READLN(SSNumber);
SearchList(FirstPointer, CurrentPointer, SSNumber, Found);
IF NOT Found THEN
WRITELN('SSN: ', SSNumber, ' Not Found')
ELSE
WITH CurrentPointer^.DataField DO
BEGIN
WRITELN('ID: ',ID);
WRITELN('Name: ',Name);
WRITELN('Position: ', Position);
WRITELN('Social Security Number: ',SSN);
WRITELN('Hourly Rate: ',Rate :2:2)
END;
WRITE('Hit any key to continue...');
READLN
END;
{ --------------------------- Procedure SaveList --------------------------- }
PROCEDURE SaveList(FirstPointer :ListPointer;
VAR MyListFile: EmpFile);
{This procedure saves the data fields in the linked list to a file of the type
RECORD. }
VAR
CurrentPointer:ListPointer;
BEGIN
ASSIGN(MyListFile, FileName);
REWRITE(MyListFile);
CurrentPointer := FirstPointer;
WHILE CurrentPointer <> NIL DO
BEGIN
WRITE(MyListFile, CurrentPointer^.DataField);
CurrentPointer := CurrentPointer^.NextField
END;
CLOSE(MyListFile)
END;
{ --------------------------- Procedure ReadFile -------------------------- }
PROCEDURE ReadFile(VAR FirstPointer :ListPointer;
VAR MyListFile: EmpFile);
{This procedure reads data from the file emplist.bin and adds the data to the
linked list. }
VAR
Item
:DataRecord;
BEGIN
ASSIGN(MyListFile, FileName);
RESET(MyListFile);
WHILE NOT EOF (MyListFile) DO
BEGIN
READ(MyListFile, Item);
BuildList(FirstPointer, Item);
END;
CLOSE(MyListFile)
END;
{ ---------------------------- Procedure Menu ------------------------------ }
PROCEDURE Menu;
VAR
Option:INTEGER;
BEGIN
WRITELN(Header);
WRITELN('1. Add records to the list.');
WRITELN('2. Display the whole list.');
WRITELN('3. Display an employee record.');
WRITELN('4. Add records from file.');
WRITELN('5. Save the list to a file.');
WRITELN('6. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1
 :
 GetData(FirstPointer);
2
 :
 DisplayItAll(FirstPointer);
3
 :
 DisplayRec(FirstPointer);
4
 :
 ReadFile(FirstPointer, MyListFile);
5
 :
 SaveList(FirstPointer, MyListFile);
6
 :
 Exit
END;
Menu
END;
{ ------------------------------ Main Program ------------------------------ }
BEGIN
{ Initialize an empty list. }
FirstPointer := NIL;
menu
END.
Sample run:
------------- Main Menu --------------
1. Add records to the list.
2. Display the whole list.
3. Display an employee record.
4. Add records from file.
5. Save the list to a file.
6. Exit.
--------------------------------------
Make a choice and press a number: 4 ----->
 At this point, the list is loaded into memory.
------------- Main Menu --------------
1. Add records to the list.
2. Display the whole list.
3. Display an employee record.
4. Add records from file.
5. Save the list to a file.
6. Exit.
--------------------------------------
Make a choice and press a number: 2
--------------------------------------
The contents of the list:
ID
 Name
 Position
 SSN
 Rate
456
345
123
Mark Poche
Deanna Bedford
John Martin Smith
Staff Assistant
 999-99-9999 $23.00
Secretary I
 444-44-4444 $12.55
Sales Manager
 111-11-1111 $22.50
234
987
James Strahan
 Sales Representative
 222-22-2222 $11.50
Charles Berlin
 President
 333-33-3333 $60.50
Hit any key to continue...

------------- Main Menu --------------
1. Add records to the list.
2. Display the whole list.
3. Display an employee record.
4. Add records from file.
5. Save the list to a file.
6. Exit.
--------------------------------------
Make a choice and press a number: 3
--------------------------------------
Enter the SSN for the employee: 111-11-1111
ID: 123
Name: John Martin Smith
Position: Sales Manager
Social Security Number: 111-11-1111
Hourly Rate: 22.50
Hit any key to continue...
------------- Main Menu --------------
1. Add records to the list.
2. Display the whole list.
3. Display an employee record.
4. Add records from file.
5. Save the list to a file.
6. Exit.
--------------------------------------
Make a choice and press a number: 6

{ ----------------------------- Example 11-6 ------------------------------- }
PROGRAM LinkedListDB(INPUT, OUTPUT, MyListFile);
CONST
FileName = 'emplist.bin';
Header = '------------- Main Menu --------------';
Separator = '--------------------------------------';
TYPE
{Declaration of data type }
SSNstring = STRING[11];
DataRecord = RECORD
ID
 :STRING[5];
Name, Position
 :STRING[20];
SSN
 :SSNstring;
Rate
 :REAL
END;
{Declaration of the list }
ListPointer = ^ListRecord;
ListRecord = RECORD
DataField :DataRecord;
NextField :ListPointer
END;
EmpFile = FILE OF DataRecord;
VAR
FirstPointerMyListFile
EmpRecord
:ListPointer;
:EmpFile;
:DataRecord;
{ -------------------------- Procedure SearchList -------------------------- }
PROCEDURE SearchList(FirstPointer :ListPointer;
VAR CurrentPointer :ListPointer;
VAR PreviousPointer :ListPointer;
SSNumber :SSNstring;
VAR Found :BOOLEAN);
{ This procedure searches the linked list for an employee's SSN. If found, the
value of the boolean flag Found becomes TRUE. }
BEGIN
PreviousPointer := NIL;
CurrentPointer := FirstPointer;
WHILE (CurrentPointer <> NIL) AND (NOT Found) DO
IF CurrentPointer^.DataField.SSN = SSNumber THEN
Found := TRUE
ELSE
BEGIN
PreviousPointer := CurrentPointer;
CurrentPointer := CurrentPointer^.NextField
END
END;
{ -------------------------- Procedure BuildList --------------------------- }
PROCEDURE BuildList(VAR FirstPointer :ListPointer;
DataItem :DataRecord);
{ This procedure builds the linked list, or adds nodes to it.}
{Note: The FirstPointer is passed using the VAR keyword because it will be
updated by this procedure.}
VAR
ToolPointer :ListPointer;
BEGIN
NEW(ToolPointer);
ToolPointer^.DataField := DataItem;
ToolPointer^.NextField := FirstPointer;
FirstPointer := ToolPointer
END;
{ -------------------------- Procedure ReadList ---------------------------- }
PROCEDURE ReadList(FirstPointer :ListPointer);
{ This procedure reads and displays the contents of the list }
VAR
CurrentPointer:ListPointer;
BEGIN
CurrentPointer := FirstPointer;
WHILE CurrentPointer <> NIL DO
BEGIN
WITH CurrentPointer^.DataField DO
BEGIN
WRITE(ID :7);
WRITE(Name :22);
WRITE(Position :22);
WRITE(SSN :13);
WRITELN(' $' ,Rate :0:2)
END;
CurrentPointer := CurrentPointer^.NextField
END;
WRITELN
END;
{ ------------------------- Procedure DelRecord ---------------------------- }
PROCEDURE DelRecord(VAR FirstPointer :ListPointer);
{ This procedure deletes a node from the list. If the node to be deleted is the
first node, FirstPointer is moved to the next node; otherwise, the pointer
field of the previous node is updated to point to the next node. In both cases
the CurrentPointer is disposed. }
VAR
CurrentPointer, PreviousPointer :ListPointer;
Found :BOOLEAN;
SSNumber: SSNstring;
BEGIN
Found := FALSE;
WRITELN(Separator);
WRITE('Enter the SSN of the employee to be removed:');
READLN(SSNumber);
SearchList(FirstPointer, CurrentPointer, PreviousPointer,
SSNumber, Found);
IF NOT Found THEN
WRITELN('SSN: ', SSNumber, ' Not Found')
ELSE
BEGIN
IF PreviousPointer = NIL THEN
{ The node to be deleted is the first node. }
FirstPointer := FirstPointer^.NextField
ELSE
{ The node to be deleted has a predecessor. }
PreviousPointer^.NextField := CurrentPointer^.NextField;
DISPOSE(CurrentPointer);
WRITELN('The record has been deleted from the list.')
END;
WRITE('Hit any key to continue...');
READLN
END;
{ --------------------------- Procedure GetData ---------------------------- }
PROCEDURE GetData(VAR FirstPointer :ListPointer);
{ This procedure receives the employee data from the keyboard, and passes the
record information to the procedure BuildList to be added to the linked list. }
VAR
CurrentPointer, DummyPointer :ListPointer;
Item
 :DataRecord;
SSNumber: SSNstring;
Found
 :BOOLEAN;
BEGIN
Found := FALSE;
WRITE('Please enter the SSN of the employee: ');
READLN(SSNumber);
SearchList(FirstPointer, CurrentPointer, DummyPointer,
SSNumber, Found);
IF NOT Found THEN
BEGIN
WRITELN('Please enter the employee information:');
WITH Item DO
BEGIN
SSN := SSNumber;
WRITE('ID: ');
 READLN(ID);
WRITE('Name: ');
 READLN(Name);
WRITE('Position: ');
 READLN(Position);
WRITE('Rate: ');
 READLN(Rate);
WRITELN(Separator)
END;
BuildList(FirstPointer, Item);
WRITELN('The employee has been added to the list.')
END
ELSE
WRITELN('The SSN: ', SSNumber, ' is already in the list.');
WRITE('Hit any key to continue...');
READLN
END;
{ -------------------------- Procedure DisplayItAll ------------------------ }
PROCEDURE DisplayItAll(FirstPointer :ListPointer);
{ This procedure displays the headers of the fields in the proper format and
calls the procedure ReadList to display the contents of the list. }
BEGIN
WRITELN(Separator);
WRITELN('The contents of the list: ');
WRITELN('ID' :7, 'Name' :22, 'Position' :22, 'SSN' :13,
'Rate' :7);
WRITELN;
ReadList(FirstPointer);
WRITE('Hit any key to continue...');
READLN
END;
{ -------------------------- Procedure DisplayRec -------------------------- }
PROCEDURE DisplayRec(FirstPointer :ListPointer);
{ This procedure displays the information for a specific employee. It calls the
procedure SearchList to search the list using the social security number of the
employee.}
VAR
CurrentPointer, DummyPointer :ListPointer;
SSNumber
 :SSNstring;
Found
 :BOOLEAN;
{ Note: DummyPointer is used to call the SearchList
procedure (which takes three pointers as parameters), but this
pointer is not required in this procedure. }
BEGIN
Found := FALSE;
WRITELN(Separator);
WRITE('Enter the SSN of the employee:'); READLN(SSNumber);
SearchList(FirstPointer, CurrentPointer,
DummyPointer, SSNumber, Found);
IF NOT Found THEN
WRITELN('SSN: ', SSNumber, ' Not Found')
ELSE
WITH CurrentPointer^.DataField DO
BEGIN
WRITELN('ID: ',ID);
WRITELN('Name: ',Name);
WRITELN('Position: ', Position);
WRITELN('Social Security Number: ', SSN);
WRITELN('Hourly Rate: $', Rate :2:2)
END;
WRITE('Hit any key to continue...');
READLN
END;
{ -------------------------- Procedure UpdateRec --------------------------- }
PROCEDURE UpdateRec(FirstPointer :ListPointer);
{ This procedure updates record information for a specific employee. It calls
the procedure SearchList to search the list using the social security number of
the employee. The new information is accepted from the user, otherwise a
message "not found" is issued. }
VAR
CurrentPointer, DummyPointer :ListPointer;
SSNumber
 :SSNstring;
Found
 :BOOLEAN;
{ Note: DummyPointer is used to call the SearchList
procedure (which takes three pointers as parameters), but this
pointer is not required in this procedure. }
BEGIN
Found := FALSE;
WRITELN(Separator);
WRITE('Enter the SSN of the employee:'); READLN(SSNumber);
SearchList(FirstPointer, CurrentPointer,
DummyPointer, SSNumber, Found);
IF NOT Found THEN
WRITELN('SSN: ', SSNumber, ' Not Found')
ELSE
WITH CurrentPointer^.DataField DO
BEGIN
WRITELN('Please enter the now information for',
' the employee (SSN: ', SSNumber,'):');
WRITE('ID: ');
 READLN(ID);
WRITE('Name: ');
 READLN(Name);
WRITE('Position: ');
 READLN(Position);
WRITE('Hourly Rate: ');
 READLN(Rate);
WRITELN('Record updated.')
END;
WRITE('Hit any key to continue...');
READLN
END;
{ -------------------------- Procedure SaveList ---------------------------- }
PROCEDURE SaveList(FirstPointer :ListPointer;
VAR MyListFile: EmpFile);
{This procedure saves the data fields in the linked list to a file of the type
RECORD. }
VAR
CurrentPointer:ListPointer;
BEGIN
ASSIGN(MyListFile, FileName);
REWRITE(MyListFile);
CurrentPointer := FirstPointer;
WHILE CurrentPointer <> NIL DO
BEGIN
WRITE(MyListFile, CurrentPointer^.DataField);
CurrentPointer := CurrentPointer^.NextField
END;
CLOSE(MyListFile);
WRITELN('The list has been saved to the file.');
WRITE('Hit any key to continue...');
READLN
END;
{ -------------------------- Procedure ReadFile ---------------------------- }
PROCEDURE ReadFile(VAR FirstPointer :ListPointer;
VAR MyListFile: EmpFile);
{This procedure reads data from the file emplist.bin and adds the data to the
linked list. }
VAR
Item
:DataRecord;
BEGIN
ASSIGN(MyListFile, FileName);
RESET(MyListFile);
WHILE NOT EOF (MyListFile) DO
BEGIN
READ(MyListFile, Item);
BuildList(FirstPointer, Item);
END;
CLOSE(MyListFile);
WRITELN('The employee list is ready in memory.');
WRITE('Hit any key to continue...');
READLN
END;
{ ---------------------------- Procedure Menu ------------------------------ }
PROCEDURE Menu;
VAR
Option :INTEGER;
BEGIN
WRITELN(Header);
WRITELN('1. Add records to the list.');
WRITELN('2. Display the whole list.');
WRITELN('3. Display an employee record.');
WRITELN('4. Add records from file.');
WRITELN('5. Save the list to a file.');
WRITELN('6. Delete a record.');
WRITELN('7. Update a record.');
WRITELN('8. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1 : GetData(FirstPointer);
2 : DisplayItAll(FirstPointer);
3 : DisplayRec(FirstPointer);
4 : ReadFile(FirstPointer, MyListFile);
5 : SaveList(FirstPointer, MyListFile);
6 : DelRecord(FirstPointer);
7 : UpdateRec(FirstPointer);
8 : Exit
END;
Menu
END;
{ ------------------------------ Main Program ------------------------------ }
BEGIN
{ Initialize an empty List }
FirstPointer := NIL;
menu
END.
Sample run:
------------- Main Menu --------------
1. Add records to the list.
2. Display the whole list.
3. Display an employee record.
4. Add records from file.
5. Save the list to a file.
6. Delete a record.
7. Update a record.
8. Exit.
--------------------------------------
Make a choice and press a number: 4
The employee list is ready in memory.
Hit any key to continue...
------------- Main Menu --------------
1. Add records to the list.
2. Display the whole list.
3. Display an employee record.
4. Add records from file.
5. Save the list to a file.
6. Delete a record.
7. Update a record.
8. Exit.
--------------------------------------
Make a choice and press a number: 1
Please enter the SSN of the employee: 222-22-2222
The SSN: 222-22-2222 is already in the list.
Hit any key to continue...

{ ------------------------------ DRILL 1-1 --------------------------------- }
PROGRAM DisplayText(OUTPUT);
BEGIN
WRITELN('wordware Publishing, Inc.');
WRITELN('-------------------------');
WRITELN('2320 Los Rios Boulevard');
WRITELN('Plano, Texas 75074')
END.

{ -------------------------------- DRILL 1-2 ------------------------------- }
PROGRAM Expressions(OUTPUT);
BEGIN
WRITELN;
WRITELN('A. 144/12 = ',144 / 12:0:2);
WRITELN('B. 144 DIV 12 = ', 144 DIV 12);
WRITELN('C. 17 MOD 5 = ', 17 MOD 5);
WRITELN('D. 3 MOD 5 = ', 3 MOD 5);
WRITELN('E. 3e+02 + 3 = ',3E+02+3:0:2);
WRITELN('F. 345E-01 -1 = ',345E-01-1:0:2);
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------- DRILL 1-3 -------------------------------- }
PROGRAM Expressions1(OUTPUT);
BEGIN
WRITELN;
WRITELN('A. 15 - 15 DIV 15 = ',15-15 DIV 15);
WRITELN('B. 22 + 10 / 2 = ', 22+10/2:0:2);
WRITELN('B. (22 + 10) / 2 = ', (22+10)/2:0:2);
WRITELN('C. 50 * 10 - 4 MOD 3 * 5 + 80 = ',50*10-4 MOD 3*5+80);
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------- DRILL 1-4 -------------------------------- }
PROGRAM Expressions2(OUTPUT);
{ Variable Declarations }
VAR
a, b :INTEGER;
{ Program Block }
BEGIN
a := 2;
b := 9;
WRITELN;
WRITELN('a=',a);
WRITELN('b=',b);
WRITELN('a+b DIV 2 = ',a+b DIV 2);
WRITELN('(a+b) DIV 2 = ',(a+b) DIV 2)
END.

{ ------------------------------- DRILL 1-5 -------------------------------- }
PROGRAM Payroll(INPUT,OUTPUT);
{ Variable Declarations }
VAR
HoursWorked, PayRate, Wages :REAL;
{ Program Block }
BEGIN
WRITE('Please enter hours worked: ');
READLN(HoursWorked);
WRITE('Please enter pay rate: ');
READLN(PayRate);
Wages := HoursWorked * PayRate;
WRITELN;
WRITELN('Wages = $', Wages:0:2)
END.

{ -------------------------------- DRILL 2-1 ------------------------------- }
{ Grocery Store }
PROGRAM Grocery(INPUT,OUTPUT);
VAR
Change, AmountPaid, TotalPrice :REAL;
IntChange, Dollars, Quarters, Dimes, Nickels, Cents :INTEGER;
BEGIN
WRITE('Enter the total-price in dollars:');
READLN(TotalPrice);
WRITE('Enter the amount-paid in dollars:');
READLN(AmountPaid);
{ dollars }
Change := AmountPaid - TotalPrice;
Dollars := TRUNC(Change);
Change := (Change - Dollars)*100;
IntChange := ROUND(Change);
{ Quarters }
Quarters := IntChange DIV 25;
IntChange := IntChange MOD 25;
{ Dimes }
Dimes := IntChange DIV 10;
IntChange := IntChange MOD 10;
{ Nickels }
Nickels := IntChange DIV 5;
IntChange := IntChange MOD 5;
{ Cents }
Cents := IntChange;
WRITELN('The change is:');
WRITELN(Dollars,' Dollars');
WRITELN(Quarters,' Quarters');
WRITELN(Dimes,' Dimes');
WRITELN(Nickels, ' Nickels');
WRITELN(Cents, ' Cents');
READLN
END.

{--------------------------------- DRILL 2-2 ------------------------------- }
{ Solution of a Quadratic Equation }
PROGRAM Quadratic(INPUT,OUTPUT);
VAR
A, B, C, D, X1, X2 :REAL;
BEGIN
WRITE('Enter the values of A,B and C for the quadratic equation:');
READLN(a,b,c);
{ Determinant}
D:=SQR(B)-4.0*A*C;
{ Roots }
X1:=(-B+SQRT(D))/(2*A);
X2:=(-B-SQRT(D))/(2*A);
WRITELN('X1=',X1:2:2,' X2=',X2:2:2);
WRITELN('Press ENTER to continue...');
READLN
END.
{ Sample runs:
A=2, B=4, C=1
X1=0.29
X2=1.70
A=1, B=2, C=1
X1=-1
X2=-1 }

{ ------------------------------- DRILL 2-3 -------------------------------- }
{ Boolean Expressions }
PROGRAM CompoundBoolean(OUTPUT);
VAR
A, X, Y, Z
 :INTEGER;
One, Two, Three, Four :BOOLEAN;
BEGIN
{ Run the program for different values of A, X, Y, Z, and see the results }
WRITE('Enter values of A, X, Y, Z:');
READLN(A,X,Y,Z);
One := A < 55.5;
Two := (X=Y) OR (X>=Z);
Three := (X=40) OR (Y=80);
Four := (X=40)<>(Y=80);
{ Four := (X=40) XOR (Y=80); }
 { Turbo Pascal version }
WRITELN('Expression #1= ', One);
WRITELN('Expression #2= ', Two);
WRITELN('Expression #3= ', Three);
WRITELN('Expression #4= ', Four)
END.

{ ------------------------------- DRILL 3-1 -------------------------------- }
PROGRAM CharsTester(INPUT,OUTPUT);
VAR
InputChar :CHAR;
BEGIN
WRITE('Please enter an alphabetic character:');
READLN(InputChar);
IF (ORD(InputChar) > 64) AND (ORD(InputChar) < 91) THEN
WRITELN('This is an upper-case letter.');
IF (ORD(InputChar) > 96) AND (ORD(InputChar) < 123) THEN
WRITELN('This is a lower-case letter.');
IF (ORD(InputChar) > 47) AND (ORD(InputChar) < 58) THEN
WRITELN('This is a number.');
WRITELN('Press ENTER to continue..');
READLN
END.

{--------------------------------- DRILL 3-2 ------------------------------- }
{ Complete Solution of a Quadratic Equation }
PROGRAM Quadratic2(INPUT,OUTPUT);
VAR
A, B, C, D, X1, X2 :REAL;
BEGIN
WRITE('Enter the values of A,B,C separated by spaces:');
READLN(a,b,c);
{ Determinant}
D:=SQR(B)-4.0*A*C;
IF D < 0 THEN
BEGIN
WRITELN('Roots are imaginary.');
WRITELN('X1=',-B/(2*A):0:2,'+j',SQRT(ABS(D))/(2*A):0:2);
WRITELN('X2=',-B/(2*A):0:2,'-j',SQRT(ABS(D))/(2*A):0:2)
END
ELSE
BEGIN
WRITELN('Roots are real.');
WRITELN('X1=',(-B+SQRT(D))/(2*A):0:2);
WRITELN('X2=',(-B-SQRT(D))/(2*A):0:2)
END;
WRITELN('Press ENTER to continue ...');
READLN
END.

{ Sample runs:
Real roots:
A=2, B=4, C=1
X1=0.29
X2=1.70
Equal real roots:
A=1, B=2, C=1
X1=-1
X2=-1
Imaginary roots:
A=1, B=1,C=1
X1=-0.5+j0.87
X2=-0.5-j0.87 }

{ ------------------------------- DRILL 3-3 -------------------------------- }
PROGRAM WeatherTester(INPUT,OUTPUT);
VAR
Temperature
 :INTEGER;
Hot, Cool, Cold, Freezing :BOOLEAN;
BEGIN
WRITE('Please enter the temperature:');
READLN(Temperature);
Hot := (Temperature >= 75) AND (Temperature < 140);
Cool := (Temperature >= 50) AND (Temperature < 75);
Cold := (Temperature >= 35) AND (Temperature < 50);
Freezing := (Temperature < 35) AND (Temperature > -80);
WRITELN;
{ Beginning of the IF construct }
{ ----------------------------- }
IF Hot THEN
WRITELN('It is hot out there!')
ELSE IF Cool THEN
WRITELN('Wow, the weather is cool.')
ELSE IF Cold THEN
WRITELN('Oh, it is cold. ')
ELSE IF Freezing THEN
WRITELN('Uh-oh, It is freezing.')
ELSE
WRITELN('Hey, I have never heard of this temperature!');
{ End of the IF construct }
{ ----------------------- }
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------- DRILL 3-4 -------------------------------- }
PROGRAM DateConverter(INPUT,OUTPUT);
VAR
Day, Month, Year :INTEGER;
BEGIN
WRITE('Please enter date in the format mm dd yy:');
READLN(Month, Day, Year);
CASE Month OF
1: WRITE('January ');
2: WRITE('February ');
3: WRITE('March ');
4: WRITE('April ');
5: WRITE('May ');
6: WRITE('June ');
7: WRITE('July ');
8: WRITE('August ');
9: WRITE('September ');
10: WRITE('October ');
11: WRITE('November ');
12: WRITE('December ')
END;
IF (Day=1) OR (Day=21) OR (Day=31) THEN
WRITE(Day,'st')
ELSE IF (Day=2) OR (Day=22) THEN
WRITE(Day,'nd')
ELSE IF (Day=3) OR (Day=23) THEN
WRITE(Day,'rd')
ELSE
WRITE(Day,'th');
WRITELN(', 19', Year);
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------- DRILL 4-1 -------------------------------- }
PROGRAM LeapYears(OUTPUT);
VAR
Year :INTEGER;
BEGIN
FOR Year := 1990 TO 2000 DO
BEGIN
IF (Year MOD 4 = 0) AND
(Year MOD 100<>0) OR (Year MOD 400 = 0) THEN
WRITELN('The year ', Year, ' is a leap year.')
ELSE
WRITELN('The year ', Year, ' is not a leap year.')
END;
WRITELN('Press ENTER to continue...');
READLN
END.

{ -------------------------------- DRILL 4-2 ------------------------------- }
PROGRAM FactorialProg3(INPUT,OUTPUT);
VAR
Factorial
 :REAL;
Kounter, Number :INTEGER;
BEGIN
WRITE('Give me a number (or 0 to exit): ');
READLN(Number);
IF Number = 0 THEN
EXIT;
Factorial := 1;
FOR kounter := Number DOWNTO 1 DO
Factorial := Factorial * Kounter;
WRITELN('The factorial of ', Number,' is ', Factorial:0:0);
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------- DRILL 4-3 -------------------------------- }
PROGRAM FlagLoop(OUTPUT);
VAR
Row, Column : INTEGER;
BEGIN
FOR Row := 1 TO 5 DO
BEGIN
FOR Column := 1 to 10 DO
WRITE('* ');
WRITELN
END;
WRITELN;
WRITELN('Press ENTER to continue...');
READLN
END.

{ -------------------------------- DRILL 4-4 ------------------------------- }
PROGRAM Multiplication(INPUT,OUTPUT);
VAR
Result, Kounter, Number :INTEGER;
BEGIN
WRITE('Give me a number: ');
READLN(Number);
Kounter := 1;
WHILE Kounter <= 9 DO
BEGIN
Result := Kounter * Number;
WRITELN(Kounter,' * ',Number, ' = ', Result);
Kounter := Kounter +1
END;
WRITELN;
WRITELN('Press ENTER to continue...');
READLN
END.

{ -------------------------------- DRILL 4-5 ------------------------------- }
PROGRAM FactorialProg3(INPUT,OUTPUT);
VAR
Factorial :REAL;
Kounter, Number :INTEGER;
BEGIN
WRITE('Give me a number (or 0 to exit): ');
READLN(Number);
WHILE Number<>0 DO
BEGIN
Factorial := 1;
FOR kounter := Number DOWNTO 1 DO
Factorial := Factorial * Kounter;
WRITELN('The factorial of ', Number,' is ', Factorial:0:0);
WRITE('Give me a number (or 0 to exit): ');
READLN(Number)
END
END.

{ -------------------------------- DRILL 5-1 ------------------------------- }
PROGRAM Subrange2(INPUT,OUTPUT);
VAR
UpperCase
 :'A'..'Z';
LowerCase
 :'a'..'z';
Digit
 :'0'..'9';
BEGIN
WRITE('Please enter a lowercase letter: ');
READLN(LowerCase);
WRITE('Please enter an uppercase letter: ');
READLN(UpperCase);
WRITE('Please enter a digit: ');
READLN(Digit);
WRITELN('-----------------------------------------------');
WRITELN('Your inputs are:');
WRITELN('Lowercase letter
 : ', LowerCase);
WRITELN('Uppercase letter
 : ', UpperCase);
WRITELN('Digit
 : ', Digit);
WRITELN('Press ENTER to continue...');
READLN
END.

{ -------------------------------- DRILL 5-2 ------------------------------- }
PROGRAM SubrangesAndEnum(INPUT,OUTPUT);
{
****************************************************
*** Remove the comment markers to see the error messages ***
****************************************************
}
TYPE
Football = (Saints, Cowboys);
{ Games
 = (Football, Baseball, Basketball) }
{ Duplicate identifier: Football }
Week
 = (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
Weekend = Sat..Sun;
Compiler = (C, Pascal, Fortran, Ada, Basic);
VAR
WholeWeek :Week;
{ WorkingDay :(Mon, Tue, Wed, Fri);}
{ Duplicate identifier: Mon,..}
Weekday
 :Mon..Fri;
{ SW
 :(Compiler, OperatingSystem, ApplicationProgram); }
{ Duplicate identifier: Compiler}
{
DpTools
DpTool
C
Margin
BEGIN
END.
:(Hardware, Software, PeopleWare);
:(HW, SW, PW);
:(TurboC, QuickC); }
{ Duplicate identifier: C}
: -10..+10;

{ -------------------------------- DRILL 5-3 ------------------------------- }
PROGRAM Scores4(INPUT,OUTPUT);
CONST
NumberOfStudents = 5;
Tab = '
 ';
 { 9 spaces }
Dash = '-';
NumberOfDashes = 23;
VAR
Score :ARRAY[1..NumberOfStudents] OF REAL;
Average, SumOfScores :REAL;
Index
 :INTEGER;
BEGIN
{ Read the scores array }
{ --------------------- }
FOR Index := 1 TO NumberOfStudents DO
BEGIN
WRITE('Enter Score of Student #', Index,': ');
READLN(Score[Index])
END;
{ Calculate the average score }
{ --------------------------- }
SumOfScores := 0;
FOR Index := 1 TO NumberOfStudents DO
SumOfScores := SumOfScores + Score[Index];
Average := SumOfScores / NumberOfStudents;
{ Display Results }
{ --------------- }
WRITELN;
WRITE(Tab, 'Student #');
WRITE(Tab, 'Score');
WRITELN;
WRITE(Tab);
FOR Index := 1 TO NumberOfDashes DO
WRITE(Dash);
WRITELN;
FOR Index := 1 TO NumberOfStudents DO
WRITELN(Tab,Index:3,tab,Score[Index]:10:2);
WRITE(Tab);
FOR Index := 1 TO NumberOfDashes DO
WRITE(Dash);
WRITELN;
WRITELN(Tab,'Average score = ', Average:0:2);
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

{ -------------------------------- DRILL 5-4 ------------------------------- }
PROGRAM Scores5(INPUT,OUTPUT);
CONST
NumberOfStudents = 5;
Tab = '
 ';
Dash = '-';
NumberOfDashes = 23;
VAR
Score :ARRAY[1..NumberOfStudents] OF REAL;
Average, SumOfScores, BestScore :REAL;
Index, BestOfClass
 :INTEGER;
BEGIN
{ Read the scores array }
{ --------------------- }
FOR Index := 1 TO NumberOfStudents DO
BEGIN
WRITE('Enter score of student #', Index,': ');
READLN(Score[Index])
END;
{ Calculate the average score }
{ --------------------------- }
SumOfScores := 0;
FOR Index := 1 TO NumberOfStudents DO
SumOfScores := SumOfScores + Score[Index];
Average := SumOfScores / NumberOfStudents;
{ Get the best score }
{ ------------------ }
BestScore := Score[1];
 { initial value }
BestOfClass := 1;
 { initial value }
FOR Index := 2 TO NumberOfStudents DO
BEGIN
IF Score[Index] > BestScore THEN
BEGIN
BestScore := Score[Index];
BestOfClass := Index;
END
END;
{ Display Results }
{ --------------- }
WRITELN;
WRITE(Tab, 'Student #', Tab, 'Score');

WRITELN;
WRITE(Tab);
FOR Index := 1 TO NumberOfDashes DO
WRITE(Dash);
WRITELN;
FOR Index := 1 TO NumberOfStudents DO
WRITELN(Tab, Index:3, Tab, Score[Index]:10:2);
WRITE(Tab);
FOR Index := 1 TO NumberOfDashes DO
WRITE(Dash);
WRITELN;
WRITELN(Tab,'Average score = ', Average:0:2);
WRITELN(Tab,'The best score = ', BestScore:0:2);
WRITELN(Tab,'The best of the class is student #',BestOfClass);
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------- DRILL 5-5 -------------------------------- }
PROGRAM Scores6(INPUT,OUTPUT);
{ using two-dimensional array }
CONST
NumberOfClasses = 3;
 { Change this number for more classes }
NumberOfStudents = 4;
 { Change this number for more students }
Tab = '
 ';
 { 5 spaces }
Dash = '-';
NumberOfDashes = 23;
TYPE
ScoreArray = ARRAY[1..NumberOfStudents, 1..NumberOfClasses] OF REAL;
AverageArray = ARRAY[1..NumberOfStudents] OF REAL;
NameArray = ARRAY[1..NumberOfStudents] OF STRING;
VAR
Score
 :ScoreArray;
Average
 :AverageArray;
Name
 :NameArray;
SumOfScores, AveragePot
 :REAL;
StudentCount, ScoreCount, DashCount :INTEGER;
I, J
 :INTEGER;
NamePot
 :STRING;
BEGIN
{ Read the scores array }
{ --------------------- }
FOR StudentCount := 1 TO NumberOfStudents DO
BEGIN
WRITELN;
WRITE('Name of student #', StudentCount ,': ');
READLN(Name[StudentCount]);
WRITELN('Scores of ', Name[StudentCount], ': ');
FOR ScoreCount := 1 TO NumberOfClasses DO
BEGIN
WRITE('Enter score of class #', ScoreCount,': ');
READLN(Score[StudentCount, ScoreCount])
END;
END;
{ Calculate the average for each student }
{ -------------------------------------- }
FOR StudentCount := 1 TO NumberOfStudents DO
BEGIN
SumOfScores := 0; { Initialize for each student }
FOR ScoreCount := 1 TO NumberOfClasses DO
SumOfScores := SumOfScores + Score[StudentCount, ScoreCount];
Average[StudentCount] := SumOfScores/NumberOfClasses
END;
{
 Sort averages in a descending order }
{
 ------------------------------------ }
FOR I := 1 TO NumberOfStudents-1 DO
BEGIN
FOR J := I+1 TO NumberOfStudents DO
IF Average[J] > Average[I] THEN
BEGIN
{ swap the averages }
AveragePot := Average[I];
Average[I] := Average[J];
Average[J] := AveragePot;
{ swap the corresponding student number }
NamePot := Name[I];
Name[I] := Name[J];
Name[J] := NamePot
END
 { End of IF and inner loop }
END;
 { End of outer loop }
{
 Display results }
{
 --------------- }
WRITELN;
WRITELN(Tab, 'Student name', Tab, 'Average');
WRITE(Tab);
FOR DashCount := 1 TO NumberOfDashes DO
WRITE(Dash);
WRITELN;
FOR StudentCount := 1 TO NumberOfStudents DO
BEGIN
WRITE(Tab, Name[StudentCount]);
FOR I := 1 TO 15 - LENGTH(Name[StudentCount]) DO
WRITE(' ');
WRITELN(Average[StudentCount]:8:2)
END;
WRITE(Tab);
FOR DashCount := 1 TO NumberOfDashes DO
WRITE(Dash);
WRITELN;
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------- DRILL 6-3 -------------------------------- }
PROGRAM AlphaCounter(INPUT,OUTPUT);
VAR
Ch
 :CHAR;
Counter :INTEGER;
BEGIN
Counter := 0;
WHILE NOT EOLN DO
BEGIN
READ(Ch);
IF (Ch >= 'a') AND (Ch <= 'z')
OR (Ch >= 'A') AND (Ch <= 'Z') THEN
Counter := Counter + 1
END;
WRITELN('Number of letters= ', Counter);
READLN;
 { To advance the pointer past to End-Of-Line mark }
WRITELN('Press ENTER to continue...');
READLN
END.
Drill 6-4
{ ------------------------------- DRILL 6-4 -------------------------------- }
PROGRAM ScramblingStrings(INPUT,OUTPUT);
CONST
NumberOfElements = 3;
TYPE
ScrambleArray = Array[1..NumberOfElements] OF STRING[10];
VAR
A
 :ScrambleArray;
I1, I2, I3
 :INTEGER;
BEGIN
WRITE('Enter a word: ');
READLN(A[1]);
WRITE('Enter a word: ');
READLN(A[2]);
WRITE('Enter a word: ');
READLN(A[3]);
280
 n
 Appendix C
FOR I1 := 1 TO 3 DO
FOR I2 := 1 TO 3 DO
IF I2<>I1 THEN
BEGIN
I3 := 6- (I1 + I2);
WRITELN(A[I1],' ',A[I2],' ',A[I3]);
END;
WRITELN('Press ENTER to continue...');
READLN
END.
Drill 6-5
{ ------------------------------- DRILL 6-5 -------------------------------- }
PROGRAM StringFunctions2(INPUT,OUTPUT);
VAR
Name
 :STRING[30];
First, Middle, Last :STRING[10];
BEGIN
WRITE('Please enter your first name: ');
READLN(First);
{ Capitalize the first letter if it is lowercase }
IF ORD(First[1]) > 90 THEN
First[1] := CHR(ORD(First[1]) - 32);
First := CONCAT(First, ' ');
WRITE('Please enter your middle name: ');
READLN(Middle);
{ Capitalize the first letter if it is lowercase }
IF ORD(Middle[1]) > 90 THEN
Middle[1] := CHR(ORD(Middle[1]) - 32);
{ Get the middle initial from the middle name }
Middle := COPY(Middle, 1, 1);
Middle := CONCAT(Middle, '. ');
WRITE('Please enter your last name: ');
READLN(Last);
{ Capitalize the first letter if it is lowercase }
IF ORD(Last[1]) > 90 THEN
Last[1] := CHR(ORD(Last[1]) - 32);
Name := CONCAT(First, Middle, Last);
WRITELN;
WRITELN('Your complete name is: ',Name);
WRITELN('Press ENTER to continue...');
READLN
END.
Answers to Drills
 n
 281
Chapter 7
Drill 7-1
{ ------------------------------- DRILL 7-1 ------------------------------- }
PROGRAM Header(OUTPUT);
VAR
Len, Tab, Kounter
 :INTEGER;
TestSentence
 :STRING;
LineChar
 :CHAR;
{ ----------------------- Beginning of Procedure --------------------- }
PROCEDURE DrawLine(LineLength, TabLength :INTEGER; LineCh: CHAR);
VAR
Counter :INTEGER;
BEGIN
FOR Counter := 1 TO TabLength DO
WRITE(' ');
FOR Counter := 1 TO LineLength DO
WRITE(LineCh);
WRITELN
END;
{ ------------------------- End of Procedure ------------------------- }
{ --------------------------- Main program --------------------------- }
BEGIN
WRITE('Please enter a sentence: ');
READLN(TestSentence);
Len := LENGTH(TestSentence);
Tab := (80 - Len) DIV 2;
WRITE('Please enter the line character: ');
READLN(LineChar);
WRITELN;
Drawline(Len, Tab, LineChar);
FOR Kounter := 1 TO Tab DO
WRITE(' ');
WRITELN(TestSentence);
Drawline(Len, Tab, LineChar);
WRITELN('Press ENTER to continue...');
READLN
END.
Drill 7-2
{ ------------------------------- DRILL 7-2 -------------------------------- }
PROGRAM FunctionMax(INPUT, OUTPUT);
CONST
ArraySize = 6;
TYPE
Range = 1..ArraySize;
282
 n
 Appendix C
NumbersArray = ARRAY[Range] OF INTEGER;
VAR
Numbers
 :NumbersArray;
{ --------------------------- Read procedure -------------------------
 }
PROCEDURE ReadNumbers(L: INTEGER; VAR R :NumbersArray);
VAR
I :INTEGER;
BEGIN
WRITELN('Give me an array of numbers of six elements.');
FOR I := 1 TO L DO
BEGIN
WRITE('Enter element #', I,': ');
READLN(R[I])
END
END;
{ ----------------------- Function MaxNumber -------------------------
 }
FUNCTION MaxNumber(S :INTEGER; N: NumbersArray) :INTEGER;
VAR
K, Maximum :INTEGER;
BEGIN
Maximum := N[1];
FOR K := 1 TO S DO
IF N[K] > Maximum THEN
Maximum := N[K];
MaxNumber := Maximum
 { Assign the max value to the function
 }
END;
{ ------------------------- End of Function --------------------------
 }
{ --------------------------- Main program ---------------------------
 }
BEGIN
ReadNumbers(ArraySize, Numbers);
WRITELN('The maximum number is: ', MaxNumber(ArraySize, Numbers));
WRITELN;
WRITELN('Press ENTER to continue...');
READLN
END.
Drill 7-3
{ -------------------------------- DRILL 7-3 ------------------------------- }
PROGRAM ProcedureRecursion(INPUT, OUTPUT);
VAR
A
 :INTEGER;
Fact :REAL;
{ ------------- Procedure Definition -------------- }
PROCEDURE Factorial(X :INTEGER; VAR Fac :REAL);
BEGIN
IF X > 1 THEN
BEGIN
Factorial(X-1, Fac);
Answers to Drills
 n
 283
Fac := Fac * X
END
ELSE
Fac := 1;
END;
{ -------------- End of Procedure ---------------- }
{ ----------------- Main program ----------------- }
BEGIN
WRITE('Enter a number: ');
READLN(A);
Factorial(A, Fact);
WRITELN('The Factorial of ', A,' = ', Fact:0:0);
WRITELN('Press ENTER to continue...');
READLN
END.
Chapter 8
Drill 8-1
{ ------------------------------- DRILL 8-1 -------------------------------- }
Expression
 Value
1. ['A','B','C','D'] + ['E','F']
 ['A','B','C','D','E','F']
2. ['A','B','C','D'] + ['B','C','E','F']
 ['A','B','C','D','E','F']
3. [1,3,7] + []
 [1,3,7]
4. ['A','D','F'] * ['O','F']
 ['F']
5. [1,2,3,4] * [5,6,7]
 []
6. [1,2,3,4] - [5,6,7]
 [1,2,3,4]
7. [5,6,7] - []
 [5,6,7]
8. [Able, Baker, Charlie] - [Able, Charlie]
 [Baker]
Drill 8-2
{ ------------------------------- DRILL 8-2 -------------------------------- }
PROGRAM TestExpressions(OUTPUT);
CONST
CR = CHR(13);
LF = CHR(10);
T = '
 ';
A1= '[1,0] = [1,0]';
B1= '[1,0]<>[1,4]';
C1= '[1,2,3] >= [1,2]';
D1= '[1,2,3] >= [1,2,3]';
E1= '[] <= [1,2,3]';
F1= '[1,2,3] <= [1,2,3]';
VAR
A, B, C, D, E, F :BOOLEAN;
BEGIN
284
 n
 Appendix C
A:= [1,0] = [1,0];
B:= [1,0]<>[1,4];
C:= [1,2,3] >= [1,2];
D:= [1,2,3] >= [1,2,3];
E:= [] <= [1,2,3];
F:= [1,2,3] <= [1,2,3];
WRITELN(A1:30, T, A, CR, LF, B1:30, T, B, CR, LF,
C1:30, T, C, CR, LF, D1:30, T, D, CR, LF,
E1:30, T, E, CR, LF, F1:30, T, F);
WRITELN;
WRITELN('Press ENTER to continue...');
READLN
END.
Drill 8-3
{-------------------------------- DRILL 8-3 ---------------------------------}
PROGRAM NestedRecord2(OUTPUT);
TYPE
AddressRecord
 = RECORD
Street
 :STRING[18];
City
 :STRING[15];
State
 :STRING[2];
Zip
 :String[5];
END;
EmployeeRecord = RECORD
Name
 :STRING[25];
AddressRec
 :AddressRecord;
Phone
 :STRING[12];
Rate
 :REAL;
MaritalStatus :CHAR;
END;
VAR
EmployeeRec
 :EmployeeRecord;
BEGIN
{ Assign values to the fields }
WITH EmployeeRec DO
WITH AddressRec DO
BEGIN
Name := 'Sally A. Abolrous';
Street := '5 Belle Chasse Dr.';
City := 'LaPlace';
State := 'LA';
Zip := '70068';
Phone := '504-285-3434';
Rate := 22.5;
MaritalStatus := 'S';
{ Display record information }
WRITELN('Employee name:
 ', Name);
WRITELN('Address:
 ', Street);
Answers to Drills
 n
 285
WRITELN('
 ', City);
WRITE('
 ', State);
WRITELN(' ', Zip);
WRITELN('Telephone #:
 ', Phone);
WRITELN('Hourly rate:
 $', Rate:0:2);
WRITELN('Marital status: ', MaritalStatus)
END;
WRITELN('Press ENTER to continue...');
READLN
END.
Chapter 9
Drill 9-1
{ -------------------------------- DRILL 9-1 ------------------------------- }
PROGRAM EmployeeInfoFile(INPUT,OUTPUT,TimeFile);
{ This program is used to create a time sheet file for one month period }
TYPE
EmployeeRecord = RECORD
ID
 :INTEGER;
Name
 :STRING[25];
HoursWorked :INTEGER;
END;
VAR
TimeFile
 :TEXT;
EmployeeRec :EmployeeRecord;
{ ----------- Procedure FileInfo ------------ }
PROCEDURE FileInFo(VAR F:TEXT; Employee :EmployeeRecord);
{ A procedure to file one record at a time }
BEGIN
WITH Employee DO
BEGIN
WRITELN(F, ID);
WRITELN(F, Name);
WRITELN(F, HoursWorked)
END
END;
{ ------------- Procedure GetData -------------- }
{ A procedure to accept data from the keyboard,
and pass them to the "FileInfo" procedure
 }
PROCEDURE GetData(VAR F:TEXT; VAR Employee :EmployeeRecord);
VAR
Counter :INTEGER;
BEGIN
Counter := 0;
WITH Employee DO
286
 n
 Appendix C
BEGIN
WRITE('Employee ID (or 0 to exit): '); READLN(ID);
WHILE ID<>0 DO
BEGIN
Counter := Counter + 1;
WRITE('Employee Name: '); READLN(Name);
WRITE('HoursWorked : '); READLN(HoursWorked);
FILEINFO(F, Employee);
WRITE('Employee ID (or 0 to exit): '); READLN(ID);
END
END;
WRITELN(Counter,' Employee records have been filed.')
END;
{ --------------- Main Program ----------------- }
BEGIN
ASSIGN(TimeFile, 'TIMSHEET.TXT');
REWRITE(TimeFile);
GetData(TimeFile, EmployeeRec);
CLOSE(TimeFile)
END.
Drill 9-2
{ -------------------------------- DRILL 9-2 ------------------------------- }
PROGRAM CreateEmpFile(INPUT,OUTPUT,F);
TYPE
AddressRecord
 = RECORD
Street
 :STRING[18];
City
 :STRING[15];
State
 :STRING[2];
Zip
 :String[5];
END;
EmployeeRecord = RECORD
ID
 :INTEGER;
Name
 :STRING[25];
AddressRec
 :AddressRecord;
Phone
 :STRING[12];
Rate
 :REAL;
MaritalStatus
 :CHAR;
END;
VAR
F
 :TEXT;
 { The file variable }
EmployeeRec :EmployeeRecord;
{ ----------- Procedure WriteRecord ---------- }
PROCEDURE WriteRecord;
BEGIN
{ Store one record to the file }
WITH EmployeeRec DO
WITH AddressRec DO
Answers to Drills
 n
 287
END;
BEGIN
WRITELN(F,
WRITELN(F,
WRITELN(F,
WRITELN(F,
WRITELN(F,
WRITELN(F,
WRITELN(F,
WRITELN(F,
WRITELN(F,
END
ID);
Name);
Street);
City);
State);
Zip);
Phone);
Rate:0:2);
MaritalStatus)
{ ----------- Procedure GetData ---------- }
PROCEDURE getdata;
VAR
Counter :INTEGER;
BEGIN
Counter := 0;
WITH EmployeeRec DO
WITH AddressRec DO
BEGIN
WRITE('Please enter Employee ID (or 0 to exit): '); READLN(ID);
WHILE ID<>0 DO
BEGIN
Counter := counter + 1;
WRITE('Employee Name: ');
 READLN(Name);
WRITE('Address: Street: ');
 READLN(Street);
WRITE('
 City: ');
 READLN(City);
WRITE('
 State: ');
 READLN(State);
WRITE('
 Zip code: ');
 READLN(Zip);
WRITE('Phone Number: ');
 READLN(Phone);
WRITE('Hourly Rate: ');
 READLN(Rate);
WRITE('Marital Status (S/M): ');
 READLN(MaritalStatus);
WriteRecord;
WRITE('Please enter Employee ID (or 0 to exit): ');
READLN(ID);
END
END;
WRITELN(Counter, ' Employee records have been filed.')
END;
{ ---------------- Main Program -------------- }
{ Main Program }
BEGIN
ASSIGN(F, 'EMPFILE.TXT');
REWRITE(F);
GetData;
CLOSE(F)
END.
288
 n
 Appendix C
Drill 9-3
{ ---------------------------------- DRILL 9-3 ------------------------------ }
PROGRAM PayRoll2(INPUT,OUTPUT,MasterFile,PayFile);
TYPE
AddressRecord
 = RECORD
Street
 :STRING[18];
City
 :STRING[15];
State
 :STRING[2];
Zip
 :String[5];
END;
EmployeeRecord = RECORD
ID :INTEGER;
Name
 :STRING[20];
AddressRec
 :AddressRecord;
Phone
 :STRING[12];
Rate
 :REAL;
MaritalStatus
 :CHAR;
END;
PayRecord = RECORD
ID
 :INTEGER;
Name :STRING[20];
Wages :REAL;
END;
VAR
MasterFile, PayFile :TEXT;
EmployeeRec
 :EmployeeRecord;
PayRec
 :PayRecord;
HoursWorked, Wages :REAL;
{ --------------- Procedure Getinfo ------------------ }
{ This procedure reads the employee file EMPFILE.TXT
and displays the ID, Name, and Hourly Rate. Then it accepts
the Hours Worked during this pay period from the keyboard }
PROCEDURE Getinfo(VAR F:TEXT);
BEGIN
WITH EmployeeRec DO
WITH AddressRec DO
BEGIN
READLN(F,ID);
 WRITELN('ID: ',ID);
READLN(F,Name);
 WRITELN('Name: ',Name);
READLN(F,Street);
READLN(F,City);
READLN(F,State);
READLN(F,Zip);
READLN(F,Phone);
READLN(F,Rate);
 WRITELN('Hourly rate: $', Rate:0:2);
READLN(F,MaritalStatus);
END;
END;
Answers to Drills
 n
 289
{ --------------- Procedure CalcWages ---------------- }
{ This procedure is used to calculate Wages and round
the cents in the resulting number. The result is
returned to the main program
 }
PROCEDURE CalcWages(HoursWorked:REAL; VAR Wages:REAL);
BEGIN
WITH EmployeeRec DO
WITH AddressRec DO
Wages := Hoursworked * Rate;
Wages := ROUND(100 * Wages) / 100;
END;
{ -------------- Procedure FilePayRoll --------------- }
{ This procedure is used to write one record
in the output file PAYFILE.TXT
 }
PROCEDURE FilePayRoll(VAR P :TEXT; Wages :REAL);
BEGIN
WITH EmployeeRec DO
WITH AddressRec DO
BEGIN
PayRec.ID := ID;
PayRec.Name := Name;
Payrec.Wages := Wages
END;
WITH PayRec DO
WRITELN(P, ID:3, Name:20, Wages:10:2)
END;
{ -------------- Procedure ReadPayRoll --------------- }
{ This procedure is used to read the file PAYFILE.TXT
and display the records at the end of the program
 }
PROCEDURE ReadPayRoll(VAR P :TEXT);
BEGIN
WITH PayRec DO
BEGIN
READLN(P, ID, Name, Wages);
WRITELN(ID:3, Name:20, '
 $',Wages:0:2)
END;
END;
{ --------------- Main Program ------------------ }
BEGIN
ASSIGN(MasterFile, 'EMPFILE.TXT');
ASSIGN(Payfile, 'PAYFILE.TXT');
REWRITE(PayFile);
RESET(MasterFile);
WHILE NOT EOF(MasterFile) DO
BEGIN
Getinfo(MasterFile);
WRITE('Please enter hours worked for this pay period: ');
READLN(HoursWorked);
CalcWages(HoursWorked, Wages);
290
 n
 Appendix C
FilePayRoll(PayFile, Wages)
END;
CLOSE(MasterFile);
CLOSE(PayFile);
RESET(PayFile);
WRITELN('--------- PayRoll Summary --------- ');
WRITELN('ID --------- Name -------- Salary');
WHILE NOT EOF(PayFile) DO
ReadPayroll(PayFile);
CLOSE(PayFile);
WRITELN('----------------------------------- ');
WRITELN('Press ENTER to continue..');
READLN
END.

{ ------------------------------ DRILL 10-1 -------------------------------- }
PROGRAM CreateEmployeeDataBase2(INPUT, OUTPUT, PayrollFile, NewFile);
{ This program is to create the TEXT file PR.TXT which stores employee records.
}
CONST
FileName = 'PR.TXT';
Header = '---------- Creating Payroll File ----------';
Separator = '--------------------------------------';
TYPE
EmployeeRecord = RECORD
ID
 :STRING[5];
Name, Position
 :STRING[20];
SSN
 :STRING[11];
CASE Category
 :CHAR OF
'1'
 :(MonthlySalary :REAL);
'2'
 :(HourlyRate
 :REAL);
'3'
 :(Commission,
BasicSalary
 :REAL;
Area
 :STRING[20])
END;
VAR
PF :TEXT;
EmployeeRec
Title
:EmployeeRecord;
:ARRAY [1..9] OF STRING[20];
Answers to Drills
BEGIN
{ Assign titles }
Title[1] := 'ID: ';
Title[2] := 'Name: ';
Title[3] := 'Position: ';
Title[4] := 'SSN: ';
Title[5] := 'Salary: ';
Title[6] := 'Rate: ';
Title[7] := 'Commission: ';
Title[8] := 'Basic Salary: ';
Title[9] := 'Area: ';
ASSIGN(PF, FileName);
REWRITE(PF);
WRITELN(Header);
WITH EmployeeRec DO
BEGIN
WRITE('Please enter Employee ID: '); READLN(ID);
WRITELN(PF,ID);
WRITE('Name: ');
 READLN(Name);
WRITELN(PF,Name);
WRITE('Position: ');
 READLN(Position);
WRITELN(PF,Position);
WRITE('SSN (xxx-xx-xxxx): ');
 READLN(SSN);
WRITELN(PF,SSN);
WRITE('Payroll category: ');
 READLN(Category);
CASE Category OF
'1' : BEGIN
WRITE('Monthly Salary: ');
READLN(MonthlySalary);
WRITELN(PF,MonthlySalary)
END;
'2' : BEGIN
WRITE('Hourly Rate: ');
READLN(HourlyRate);
WRITELN(PF,HourlyRate)
END;
'3' : BEGIN
WRITE('Commission Rate: ');
READLN(Commission);
WRITELN(PF,Commission);
WRITE('Basic Salary: ');
READLN(BasicSalary);
WRITELN(PF,BasicSalary);
WRITE('Area: ');
READLN(Area);
WRITELN(PF,Area)
END
END
END;
n
 291
292
 n
 Appendix C
CLOSE(PF);
WRITELN(Separator);
WRITELN('Payroll file has been created. Press any key');
READLN
END.
Drill 10-2
{ ----------------------------- DRILL 10-2 --------------------------------- }
PROCEDURE DelRec(VAR NewFile, PayrollFile :TEXT; Employee :EmployeeRecord);
VAR
SSNumber :STRING[11];
Found
 :INTEGER;
BEGIN
Found := 0;
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WRITE('Please enter the SSN of the employee to be deleted: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1' : READLN(PayrollFile, MonthlySalary);
'2' : READLN(PayrollFile, HourlyRate);
'3' : BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber<>SSN THEN
BEGIN
WRITELN(NewFile,ID);
WRITELN(NewFile,Name);
WRITELN(NewFile,Position);
WRITELN(NewFile,SSN);
WRITELN(NewFile,Category);
CASE Category OF
'1' : WRITELN(NewFile,MonthlySalary:0:2);
Answers to Drills
 n
 293
'2' : WRITELN(NewFile,HourlyRate:0:2);
'3' : BEGIN
WRITELN(NewFile,Commission:0:2);
WRITELN(NewFile,BasicSalary:0:2);
WRITELN(NewFile,Area)
END
END; { End of CASE structure }
END
ELSE
Found := 1;
END { End of WITH block }
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile,OneLine);
WRITELN(PayrollFile,OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile);
{ User Messages }
IF Found =1 THEN
WRITELN('The employee ', SSNumber, ' is removed from file.')
ELSE
BEGIN
WRITELN('The SSN ', SSNumber, ' is not found.');
WRITELN('Check the number and try again.');
WRITELN
END
END;
Drill 10-3
{ ----------------------------- DRILL 10-3 --------------------------------- }
PROGRAM EmployeeDataBase2(INPUT, OUTPUT, PayrollFile, NewFile);
CONST
FileName = 'Payroll.TXT';
TempFile = 'TEMP.TXT';
Header = '------------- Main Menu --------------';
Header1 = '--------- Employee DataBase ----------';
Header2 = '---------- Employee Record -----------';
Separator = '--------------------------------------';
294
 n
 Appendix C
TYPE
EmployeeRecord = RECORD
ID
 :STRING[5];
Name, Position
 :STRING[20];
SSN
 :STRING[11];
CASE Category
 :CHAR OF
'1'
 :(MonthlySalary :REAL);
'2'
 :(HourlyRate
 :REAL);
'3'
 :(Commission,
BasicSalary
 :REAL;
Area
 :STRING[20])
END;
VAR
NewFile, PayrollFile :TEXT;
EmployeeRec
 :EmployeeRecord;
Title
 :ARRAY [1..9] OF STRING[20];
OneLine
 :STRING[80];
{ ------------------ Procedure ReadRec -------------------- }
PROCEDURE ReadRec(VAR PayrollFile :TEXT;
Employee :EmployeeRecord);
VAR
SSNumber
Found
:STRING[11];
:INTEGER;
BEGIN
Found := 0;
 {Reset the flag}
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WRITELN;
WRITE('Please enter the SSN of the employee: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1' : READLN(PayrollFile, MonthlySalary);
'2' : READLN(PayrollFile, HourlyRate);
'3' : BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
Answers to Drills
 n
 295
END; { End of CASE structure }
IF SSNumber = SSN THEN
BEGIN
WRITELN(Header2);
WRITELN(Title[1],ID);
WRITELN(Title[2],Name);
WRITELN(Title[3],Position);
WRITELN(Title[4], SSN);
CASE Category OF
'1' : WRITELN(Title[5], MonthlySalary:0:2);
'2' : WRITELN(Title[6], HourlyRate:0:2);
'3' : BEGIN
WRITELN(Title[7], Commission:0:2);
WRITELN(Title[8], BasicSalary:0:2);
WRITELN(Title[9], Area)
END
END; { End of CASE structure }
Found := 1
END
END { End of WITH block }
END;
CLOSE(PayrollFile);
IF Found<>1 THEN
BEGIN
WRITELN('SSN not found in file.');
WRITELN('Please try again.');
WRITELN
END
END;
{ ------------------ Procedure DelRec --------------------- }
PROCEDURE DelRec(VAR NewFile, PayrollFile :TEXT;
Employee :EmployeeRecord);
VAR
SSNumber:STRING[11];
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WRITE('Please enter the SSN of the employee to be deleted: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
296
 n
 Appendix C
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1' : READLN(PayrollFile, MonthlySalary);
'2' : READLN(PayrollFile, HourlyRate);
'3' : BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber<>SSN THEN
BEGIN
WRITELN(NewFile,ID);
WRITELN(NewFile,Name);
WRITELN(NewFile,Position);
WRITELN(NewFile,SSN);
WRITELN(NewFile,Category);
CASE Category OF
'1' : WRITELN(NewFile,MonthlySalary:0:2);
'2' : WRITELN(NewFile,HourlyRate:0:2);
'3' : BEGIN
WRITELN(NewFile,Commission:0:2);
WRITELN(NewFile,BasicSalary:0:2);
WRITELN(NewFile,Area)
END
END; { End of CASE structure }
END
END { End of WITH block }
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile,OneLine);
WRITELN(PayrollFile,OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile);
WRITELN('The employee ', SSNumber, ' is removed from file.')
END;
{ ------------------ Procedure AddRec --------------------- }
PROCEDURE AddRec(VAR NewFile, PayrollFile :TEXT;
Answers to Drills
Employee: EmployeeRecord);
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
{ Check for the end of the text file }
WHILE NOT EOF(PayrollFile) DO
BEGIN
{ Copy each record from PayrollFile to the NewFile }
READLN(PayrollFile,OneLine);
WRITELN(NewFile,OneLine)
END;
{ Accept a new record from the keyboard }
WITH Employee DO
BEGIN
WRITE('Please enter Employee ID: ');
READLN(ID);
WRITE('Name: ');
 READLN(Name);
WRITE('Position: ');
 READLN(Position);
WRITE('SSN (xxx-xx-xxxx): '); READLN(SSN);
WRITE('Payroll category: ');
 READLN(Category);
CASE Category OF
'1' : BEGIN
WRITE('Monthly Salary: ');
READLN(MonthlySalary);
END;
'2' : BEGIN
WRITE('Rate: ');
READLN(HourlyRate);
END;
'3' : BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITE('Basic salary: ');
READLN(BasicSalary);
WRITE('Area: ');
READLN(Area)
END
END;
{ Store the information in NewFile }
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1' : WRITELN(NewFile, MonthlySalary:0:2);
'2' : WRITELN(NewFile, HourlyRate:0:2);
'3' : BEGIN
WRITELN(NewFile, Commission:0:2);
n
 297
298
 n
 Appendix C
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area)
END
END
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile,OneLine);
WRITELN(PayrollFile,OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile)
END;
{ ----------------- Procedure UpdateRec ------------------- }
PROCEDURE UpdateRec(VAR NewFile, PayrollFile :TEXT;
Employee :EmployeeRecord);
VAR
SSNumber
 :STRING[11];
Found
 :INTEGER;
BEGIN
Found := 0;
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WRITE('Please enter the SSN of the employee to be updated: ');
READLN(SSNumber);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1' : READLN(PayrollFile, MonthlySalary);
'2' : READLN(PayrollFile, HourlyRate);
'3' : BEGIN
Answers to Drills
 n
 299
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber<>SSN THEN
BEGIN
WRITELN(NewFile,ID);
WRITELN(NewFile,Name);
WRITELN(NewFile,Position);
WRITELN(NewFile,SSN);
WRITELN(NewFile,Category);
CASE Category OF
'1' : WRITELN(NewFile,MonthlySalary:0:2);
'2' : WRITELN(NewFile,HourlyRate:0:2);
'3' : BEGIN
WRITELN(NewFile,Commission:0:2);
WRITELN(NewFile,BasicSalary:0:2);
WRITELN(NewFile,Area)
END
END; { End of CASE structure }
END
ELSE
BEGIN
Found := 1;
WRITELN('Please enter the updated information:');
WRITE('ID: ');
 READLN(ID);
WRITELN(NewFile,ID);
WRITE('Name: ');
 READLN(Name);
WRITELN(NewFile,Name);
WRITE('Position: ');
 READLN(Position);
WRITELN(NewFile,Position);
WRITELN(NewFile,SSN);
WRITE('Category: ');
 READLN(Category);
WRITELN(NewFile,Category);
CASE Category OF
'1' : BEGIN
WRITE('Salary: ');
READLN(MonthlySalary);
WRITELN(NewFile,MonthlySalary:0:2)
END;
'2' : BEGIN
WRITE('Hourly Rate: ');
READLN(HourlyRate);
WRITELN(NewFile,HourlyRate:0:2)
END;
'3' : BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITELN(NewFile,Commission:0:2);
WRITE('Basic Salary: ');
300
 n
 Appendix C
READLN(BAsicSalary);
WRITELN(NewFile,BasicSalary:0:2);
WRITE('Area: ');
READLN(Area);
WRITELN(NewFile,Area)
END
END;
 { End of CASE structure }
END
END { End of WITH block }
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile,OneLine);
WRITELN(PayrollFile,OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile);
{ User Messages }
IF Found =1 THEN
WRITELN('The employee ', SSNumber, ' is updated.')
ELSE
BEGIN
WRITELN('The SSN ', SSNumber, ' is not found.');
WRITELN('Check the number and try again.');
WRITELN
END
END;
{ -------------------- Procedure Menu --------------------- }
PROCEDURE Menu;
VAR
Option:INTEGER;
BEGIN
WRITELN(Header);
WRITELN;
WRITELN('1. Display an employee record.');
WRITELN('2. Add a new employee.');
WRITELN('3. Delete an employee.');
WRITELN('4. Update an employee record.');
WRITELN('5. Exit.');
WRITELN(Separator);
Answers to Drills
 n
 301
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1 : ReadRec(PayrollFile, EmployeeRec);
2 : AddRec(NewFile, PayrollFile, EmployeeRec);
3 : DelRec(NewFile, PayrollFile, EmployeeRec);
4 : UpdateRec(NewFile, PayrollFile, EmployeeRec);
5 : Exit
END;
Menu
END;
{ --------------------- Main Program ---------------------- }
BEGIN
{ Assign titles }
Title[1] := 'ID: ';
Title[2] := 'Name: ';
Title[3] := 'Position: ';
Title[4] := 'SSN: ';
Title[5] := 'Salary: ';
Title[6] := 'Rate: ';
Title[7] := 'Commission: ';
Title[8] := 'Basic Salary: ';
Title[9] := 'Area: ';
Menu
END.
Chapter 11
Drill 11-1
{ ------------------------------ DRILL 11-1 -------------------------------- }
PROGRAM CreateEmployeeDataBase3(INPUT, OUTPUT, PayrollFile, NewFile);
{ This program is used to create a payroll TEXT file PR.TXT
 }
CONST
FileName = 'PR.TXT';
Header = '---------- Creating Payroll File ----------';
Separator = '--------------------------------------';
TYPE
EmployeeRecord = RECORD
ID
 :STRING[5];
Name, Position
 :STRING[20];
SSN
 :STRING[11];
CASE Category
 :CHAR OF
'1'
 :(MonthlySalary :REAL);
'2'
 :(HourlyRate
 :REAL);
302
 n
 Appendix C
'3'
END;
:(Commission,
BasicSalary
Area
EmployeePointer = ^EmployeeRecord;
:REAL;
:STRING[20])
VAR
PF :TEXT;
RecPointer
Title
:EmployeePointer;
:ARRAY [1..9] OF STRING[20];
BEGIN
{ Assign titles }
Title[1] := 'ID: ';
Title[2] := 'Name: ';
Title[3] := 'Position: ';
Title[4] := 'SSN: ';
Title[5] := 'Salary: ';
Title[6] := 'Rate: ';
Title[7] := 'Commission: ';
Title[8] := 'Basic Salary: ';
Title[9] := 'Area: ';
ASSIGN(PF, FileName);
REWRITE(PF);
WRITELN(Header);
WITH RecPointer^ DO
BEGIN
WRITE('Please enter Employee ID: '); READLN(ID);
WRITELN(PF,ID);
WRITE('Name: ');
 READLN(Name);
WRITELN(PF,Name);
WRITE('Position: ');
 READLN(Position);
WRITELN(PF,Position);
WRITE('SSN (xxx-xx-xxxx): ');
 READLN(SSN);
WRITELN(PF,SSN);
WRITE('Payroll category: ');
 READLN(Category);
CASE Category OF
'1' : BEGIN
WRITE('Monthly Salary: ');
READLN(MonthlySalary);
WRITELN(PF,MonthlySalary)
END;
'2' : BEGIN
WRITE('Hourly Rate: ');
READLN(HourlyRate);
WRITELN(PF,HourlyRate)
END;
'3' : BEGIN
WRITE('Commission Rate: ');
Answers to Drills
 n
 303
READLN(Commission);
WRITELN(PF,Commission);
WRITE('Basic Salary: ');
READLN(BasicSalary);
WRITELN(PF,BasicSalary);
WRITE('Area: ');
READLN(Area);
WRITELN(PF,Area)
END
END
END;
CLOSE(PF);
WRITELN(Separator);
WRITELN('Payroll file has been created. Press any key');
READLN
END.
Drill 11-2
{ ----------------------------- DRILL 11-2 --------------------------------- }
PROGRAM EmployeeDataBase2(INPUT, OUTPUT, PayrollFile, NewFile);
{ This program uses the employee data base file payroll.txt to process records
using pointers. }
CONST
FileName = 'payroll.txt';
TempFile = 'temp.txt';
Header = '------------- Main Menu --------------';
Header1 = '--------- Employee DataBase ----------';
Header2 = '---------- Employee Record -----------';
Separator = '--------------------------------------';
TYPE
EmployeeRecord = RECORD
ID
 :STRING[5];
Name, Position
 :STRING[20];
SSN
 :STRING[11];
CASE Category
 :CHAR OF
'1'
 :(MonthlySalary :REAL);
'2'
 :(HourlyRate
 :REAL);
'3'
 :(Commission,
BasicSalary
 :REAL;
Area
 :STRING[20])
END;
SSNstring = STRING[11];
EmployeePointer = ^EmployeeRecord;
304
 n
 Appendix C
VAR
NewFile, PayrollFile
 :TEXT;
EmployeeRec
 :EmployeePointer;
Title
 :ARRAY [1..9] OF STRING[20];
OneLine
 :STRING[80];
{ ----------------- Procedure SearchRec ------------------- }
PROCEDURE SearchRec(VAR PayrollFile :TEXT;
Employee :EmployeePointer;
SSNumber :SSNstring;
VAR Found :INTEGER);
BEGIN
Found := 0;
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee^ DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1' : READLN(PayrollFile, MonthlySalary);
'2' : READLN(PayrollFile, HourlyRate);
'3' : BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber = SSN THEN
Found := 1;
END { End of WITH block }
END;
CLOSE(PayrollFile);
END;
{ ------------------ Procedure ReadRec -------------------- }
PROCEDURE ReadRec(VAR PayrollFile :TEXT;
Employee :EmployeePointer);
VAR
SSNumber :STRING[11];
Found
 :INTEGER;
BEGIN
WRITELN;
WRITE('Please enter the SSN of the employee: ');
Answers to Drills
 n
 305
READLN(SSNumber);
SearchRec(PayrollFile, Employee, SSNumber, Found);
IF Found =1 THEN
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee^ DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1' : READLN(PayrollFile, MonthlySalary);
'2' : READLN(PayrollFile, HourlyRate);
'3' : BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber = SSN THEN
BEGIN
WRITELN(Header2);
WRITELN(Title[1],ID);
WRITELN(Title[2],Name);
WRITELN(Title[3],Position);
WRITELN(Title[4], SSN);
CASE Category OF
'1' : WRITELN(Title[5], MonthlySalary:0:2);
'2' : WRITELN(Title[6], HourlyRate:0:2);
'3' : BEGIN
WRITELN(Title[7], Commission:0:2);
WRITELN(Title[8], BasicSalary:0:2);
WRITELN(Title[9], Area)
END
END; { End of CASE structure }
END
END { End of WITH block }
END;
CLOSE(PayrollFile)
END
ELSE
 { If not found }
BEGIN
WRITELN('SSN not found in file.');
WRITELN('Please try again.');
WRITELN
END
306
 n
 Appendix C
END;
{ ------------------ Procedure DelRec --------------------- }
PROCEDURE DelRec(VAR NewFile, PayrollFile :TEXT;
Employee :EmployeePointer);
VAR
SSNumberFound
:STRING[11];
:INTEGER;
BEGIN
WRITE('Please enter the SSN of the employee to be deleted: ');
READLN(SSNumber);
SearchRec(PayrollFile, Employee, SSNumber, Found);
IF Found =1 THEN
BEGIN
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee^ DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1' : READLN(PayrollFile, MonthlySalary);
'2' : READLN(PayrollFile, HourlyRate);
'3' : BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber<>SSN THEN
BEGIN
WRITELN(NewFile,ID);
WRITELN(NewFile,Name);
WRITELN(NewFile,Position);
WRITELN(NewFile,SSN);
WRITELN(NewFile,Category);
CASE Category OF
'1' : WRITELN(NewFile,MonthlySalary:0:2);
'2' : WRITELN(NewFile,HourlyRate:0:2);
'3' : BEGIN
WRITELN(NewFile,Commission:0:2);
WRITELN(NewFile,BasicSalary:0:2);
Answers to Drills
WRITELN(NewFile,Area)
END
END;
 { End of CASE structure }
END;
END { End of WITH block }
END; {End of DO }
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile,OneLine);
WRITELN(PayrollFile,OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile);
{ User Messages }
WRITELN('The employee ', SSNumber,
' is removed from file.')
END { End of the "IF Found.." block }
ELSE { IF not found }
BEGIN
WRITELN('The SSN ', SSNumber, ' is not found.');
WRITELN('Check the number and try again.');
WRITELN
END
END;
{ ------------------ Procedure AddRec --------------------- }
PROCEDURE AddRec(VAR NewFile, PayrollFile :TEXT;
Employee: EmployeePointer);
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
{ Copy each record from PayrollFile to the NewFile }
READLN(PayrollFile,OneLine);
WRITELN(NewFile,OneLine)
END;
{ Accept a new record from the keyboard }
WITH Employee^ DO
BEGIN
n
 307
308
 n
 Appendix C
WRITE('Please enter Employee ID: ');
READLN(ID);
WRITE('Name: ');
 READLN(Name);
WRITE('Position: ');
 READLN(Position);
WRITE('SSN (xxx-xx-xxxx): '); READLN(SSN);
WRITE('Payroll category: ');
 READLN(Category);
CASE Category OF
'1' : BEGIN
WRITE('Monthly Salary: ');
READLN(MonthlySalary)
END;
'2' : BEGIN
WRITE('Rate: ');
READLN(HourlyRate)
END;
'3' : BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITE('Basic salary: ');
READLN(BasicSalary);
WRITE('Area: ');
READLN(Area)
END
END;
{ Store the information in NewFile }
WRITELN(NewFile, ID);
WRITELN(NewFile, Name);
WRITELN(NewFile, Position);
WRITELN(NewFile, SSN);
WRITELN(NewFile, Category);
CASE Category OF
'1' : WRITELN(NewFile, MonthlySalary:0:2);
'2' : WRITELN(NewFile, HourlyRate:0:2);
'3' : BEGIN
WRITELN(NewFile, Commission:0:2);
WRITELN(NewFile, BasicSalary:0:2);
WRITELN(NewFile, Area)
END
END
END;
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile,OneLine);
WRITELN(PayrollFile,OneLine)
Answers to Drills
 n
 309
END;
CLOSE(NewFile);
ERASE(NewFile);
 { Erase the temporary file }
CLOSE(PayrollFile)
END;
{ ---------------- Procedure UpdateRec -------------------- }
PROCEDURE UpdateRec(VAR NewFile, PayrollFile :TEXT;
Employee :EmployeePointer);
VAR
SSNumber
 :STRING[11];
Found
 :INTEGER;
BEGIN
WRITE('Please enter the SSN of the employee to be updated: ');
READLN(SSNumber);
SearchRec(PayrollFile, Employee, SSNumber, Found);
IF Found = 1 THEN
BEGIN
ASSIGN(PayrollFile, FileName);
RESET(PayrollFile);
ASSIGN(NewFile, TempFile);
REWRITE(NewFile);
WHILE NOT EOF(PayrollFile) DO
BEGIN
WITH Employee^ DO
BEGIN
READLN(PayrollFile, ID);
READLN(PayrollFile, Name);
READLN(PayrollFile, Position);
READLN(PayrollFile, SSN);
READLN(PayrollFile, Category);
CASE Category OF
'1' : READLN(PayrollFile, MonthlySalary);
'2' : READLN(PayrollFile, HourlyRate);
'3' : BEGIN
READLN(PayrollFile, Commission);
READLN(PayrollFile, BasicSalary);
READLN(PayrollFile, Area)
END
END; { End of CASE structure }
IF SSNumber<>SSN THEN
BEGIN
WRITELN(NewFile,ID);
WRITELN(NewFile,Name);
WRITELN(NewFile,Position);
WRITELN(NewFile,SSN);
WRITELN(NewFile,Category);
CASE Category OF
'1' : WRITELN(NewFile,MonthlySalary:0:2);
'2' : WRITELN(NewFile,HourlyRate:0:2);

310 n Appendix C

'3' : BEGIN
WRITELN(NewFile,Commission:0:2);
WRITELN(NewFile,BasicSalary:0:2);
WRITELN(NewFile,Area)
END
END { End of CASE structure }
END { End of IF block }
ELSE
BEGIN
WRITELN('Please enter the updated information:');
WRITE('ID: ');
 READLN(ID);
WRITELN(NewFile,ID);
WRITE('Name: ');
 READLN(Name);
WRITELN(NewFile,Name);
WRITE('Position: ');
 READLN(Position);
WRITELN(NewFile,Position);
WRITELN(NewFile,SSN);
WRITE('Category: ');
 READLN(Category);
WRITELN(NewFile,Category);
CASE Category OF
'1' : BEGIN
WRITE('Salary: ');
READLN(MonthlySalary);
WRITELN(NewFile,MonthlySalary:0:2)
END;
'2' : BEGIN
WRITE('Hourly Rate: ');
READLN(HourlyRate);
WRITELN(NewFile,HourlyRate:0:2)
END;
'3' : BEGIN
WRITE('Commission: ');
READLN(Commission);
WRITELN(NewFile,Commission:0:2);
WRITE('Basic Salary: ');
READLN(BAsicSalary);
WRITELN(NewFile,BasicSalary:0:2);
WRITE('Area: ');
READLN(Area);
WRITELN(NewFile,Area)
END
END
 { End of CASE structure }
END { End of ELSE block }
END { End of WITH block }
END; { End of DO }
CLOSE(NewFile);
CLOSE(PayrollFile);
{ Copy NewFile back to Payroll File }
ASSIGN(PayrollFile, FileName);
REWRITE(PayrollFile);
ASSIGN(NewFile, TempFile);
Answers to Drills
RESET(NewFile);
WHILE NOT EOF(NewFile) DO
BEGIN
READLN(NewFile,OneLine);
WRITELN(PayrollFile,OneLine)
END;
CLOSE(NewFile);
ERASE(NewFile); { Erase the temporary file }
CLOSE(PayrollFile);
{ User Messages }
WRITELN('The employee ', SSNumber, ' is updated.')
END { End of IF block }
ELSE
BEGIN
WRITELN('The SSN ', SSNumber, ' is not found.');
WRITELN('Check the number and try again.');
WRITELN
END
END;
{ -------------------- Procedure Menu --------------------- }
PROCEDURE Menu;
VAR
Option:INTEGER;
BEGIN
WRITELN(Header);
WRITELN;
WRITELN('1. Display an employee record.');
WRITELN('2. Add a new employee.');
WRITELN('3. Delete an employee.');
WRITELN('4. Update an employee record.');
WRITELN('5. Exit.');
WRITELN(Separator);
WRITE('Make a choice and press a number: ');
READLN(Option);
CASE Option OF
1 : ReadRec(PayrollFile, EmployeeRec);
2 : AddRec(NewFile, PayrollFile, EmployeeRec);
3 : DelRec(NewFile, PayrollFile, EmployeeRec);
4 : UpdateRec(NewFile, PayrollFile, EmployeeRec);
5 : Exit
END;
Menu
END;
{ --------------------- Main Program ---------------------- }
BEGIN
{ Assign titles }
n 311 312 n Appendix C
Title[1] := 'ID: ';
Title[2] := 'Name: ';
Title[3] := 'Position: ';
Title[4] := 'SSN: ';
Title[5] := 'Salary: ';
Title[6] := 'Rate: ';
Title[7] := 'Commission: ';
Title[8] := 'Basic Salary: ';
Title[9] := 'Area: ';
Menu
END.

Drill 11-3

{ ----------------------------- DRILL 11-3 --------------------------------- }
PROGRAM LinkedListDemo(INPUT, OUTPUT, NamesFile);
{ This program initializes a linked list that stores strings. It
adds data to the list, displays its contents, and stores it in
the file namelist.bin. It also reads the file and adds its
contents to the list }
CONST
FileName = 'namelist.bin';
Header = '------------- Main Menu --------------';
Separator = '--------------------------------------';
TYPE
DataString = STRING[30];
ListPointer = ^ListRecord;
ListRecord = RECORD
DataField :DataString;
NextField :ListPointer
END;
NamesFile = FILE OF DataString;
VAR
FirstPointerMyListFile
:ListPointer;
:NamesFile;
{ ---------------- Procedure BuildList -------------------- }
PROCEDURE BuildList(VAR FirstPointer :ListPointer;
DataItem :DataString);
{Note: The FirstPointer is passed using the VAR keyword as
it will be updated by this procedure.
 }
VAR
ToolPointer :ListPointer;
BEGIN
NEW(ToolPointer);
Answers to Drills
ToolPointer^.DataField := DataItem;
ToolPointer^.NextField := FirstPointer;
FirstPointer := ToolPointer
END;
{ ----------------- Procedure ReadList -------------------- }
PROCEDURE ReadList(FirstPointer :ListPointer);
VAR
CurrentPointer:ListPointer;
BEGIN
CurrentPointer := FirstPointer;
WHILE CurrentPointer<>NIL DO
BEGIN
WRITELN(CurrentPointer^.DataField);
CurrentPointer := CurrentPointer^.NextField
END;
WRITELN
END;
{ ----------------- Procedure GetData --------------------- }
PROCEDURE GetData(VAR FirstPointer :ListPointer);
VAR
Name:DataString;
BEGIN
WRITELN('Enter the names to add to the list,',
' when finished hit ENTER.');
{ Read the first data item }
READLN(Name);
{ Check for end-of-data }
WHILE LENGTH(Name)<>0 DO
BEGIN
BuildList(FirstPointer, Name);
READLN(Name)
END
END;
{ ----------------- Procedure DisplayInfo ----------------- }
PROCEDURE DisplayInfo(FirstPointer :ListPointer);
BEGIN
WRITELN(Separator);
WRITELN('The contents of the list: ');
ReadList(FirstPointer);
WRITE('Hit any key to continue...');
READLN
END;
n
 313
314
 n
 Appendix C
{ ---------------- Procedure SaveList --------------------- }
PROCEDURE SaveList(FirstPointer :ListPointer;
VAR MyListFile: NamesFile);
VAR
CurrentPointer :ListPointer;
BEGIN
ASSIGN(MyListFile, FileName);
REWRITE(MyListFile);
CurrentPointer := FirstPointer;
WHILE CurrentPointer<>NIL DO
BEGIN
WRITE(MyListFile, CurrentPointer^.DataField);
CurrentPointer := CurrentPointer^.NextField
END;
CLOSE(MyListFile)
END;

{ ----------------- Procedure ReadFile -------------------- }
PROCEDURE ReadFile(VAR FirstPointer :ListPointer;
VAR MyListFile: NamesFile);
VAR Name :DataString;
BEGIN
  ASSIGN(MyListFile, FileName);
  RESET(MyListFile);
  WHILE NOT EOF (MyListFile) DO
    BEGIN
      READ(MyListFile, Name);
      BuildList(FirstPointer, Name);
    END;
  CLOSE(MyListFile)
END;

{ ------------------ Procedure Menu ----------------------- }
PROCEDURE Menu;
VAR
  Option :INTEGER;
BEGIN
  WRITELN(Header);
  WRITELN('1. Add data from the keyboard.');
  WRITELN('2. Display the list.');
  WRITELN('3. Add data from file.');
  WRITELN('4. Save the list to a file.');
  WRITELN('5. Exit.');
  WRITELN(Separator);
  WRITE('Make a choice and press a number: ');
  READLN(Option);
  
  CASE Option OF
  
  Answers to Drills n 315
  
  1 : GetData(FirstPointer);
  2 : DisplayInfo(FirstPointer);
  3 : ReadFile(FirstPointer, MyListFile);
  4 : SaveList(FirstPointer, MyListFile);
  5 : Exit
  END;
  Menu
END;

{ --------------------- Main Program ---------------------- }
BEGIN
  { Initialize an empty List }
  FirstPointer := NIL;
  menu
END.

Drill 11-4

{ ------------------------ Procedure UpdateRec ----------------------------- }
PROCEDURE UpdateRec(FirstPointer :ListPointer);
{ This procedure updates record information for a specific employee.
  It calls the procedure SearchList to search the list using the
  Social Security Number of the employee. The new information is
  accepted from the user, otherwise a message "not found" is issued.}
VAR
  CurrentPointer :ListPointer;
  SSNumber :SSNstring;
  Found :BOOLEAN;
BEGIN
  Found := FALSE;
  WRITELN(Separator);
  WRITE('Enter the SSN of the employee:'); 
  READLN(SSNumber);
  
  SearchList(FirstPointer, CurrentPointer,SSNumber, Found);
  IF NOT Found THEN
    WRITELN('SSN: ', SSNumber, ' Not Found')
  ELSE
    WITH CurrentPointer^.DataField DO
      BEGIN
        WRITELN('Please enter the now information of',' the employee (SSN: ', SSNumber,'):');
        WRITE('ID: ');
        READLN(ID);
        WRITE('Name: ');
        READLN(Name);
        WRITE('Position: ');
        READLN(Position);
        WRITE('Hourly Rate: ');
        READLN(Rate);
        WRITELN('Record updated.')
      END;
    WRITE('Hit any key to continue...');
    READLN
END;

(-------------------------------------::==x*x==::-------------------------------------)
