PASCAL Programming Fundamentals
P. S. Grover
ISBN 81-7764-193-X
ALLIED PUBLISHERS LIMITED
(c) P. S. Grover, 1988. 8th Reprint, 2001.

CONTENTS

PREFACE
CHAPTER  1  INTRODUCTION
CHAPTER  2  PROBLEM SOLVING AND PASCAL
CHAPTER  3  ELEMENTARY CONCEPTS AND PRIMITIVE DATA TYPES
CHAPTER  4  EXPRESSIONS
CHAPTER  5  SIMPLE STATEMENTS AND PROGRAMS
CHAPTER  6  ENUMERATED AND SUBRANGE DATA TYPES
CHAPTER  7  PROGRAM EXECUTION CONTROL
CHAPTER  8  REPETITIVE COMPUTATIONS
CHAPTER  9  STRUCTURED DATA TYPE: ARRAYS
CHAPTER 10  SUBPROGRAMS: FUNCTIONS AND PROCEDURES
CHAPTER 11  RECORD DATA TYPES
CHAPTER 12  FILE TYPES
CHAPTER 13  SET OPERATIONS AND DATA TYPES
CHAPTER 14  POINTERS AND DYNAMIC DATA STRUCTURES
CHAPTER 15  STRUCTURED PROGRAM DESIGN CONCEPTS
APPENDIX   I: PASCAL OPERATORS AND THEIR PRECEDENCE
APPENDIX  II: STANDARD IDENTIFIERS AND PASCAL RESERVED WORDS
APPENDIX III: PASCAL SUPPLIED FUNCTIONS AND PROCEDURES
APPENDIX  IV: SYNTAX OF PASCAL
APPENDIX   V: SYNTAX DIAGRAMS
APPENDIX  VI: ASCII & EBCDIC CHARACTER SETS
BIBLIOGRAPHY
INDEX
{* ///::<+>::\\\ *}

PASCAL PROGRAMMING
P. RADHA GANESHAN
ISBN 81-224-1096-0
NEW AGE INTERNATIONAL(P) LIMITED, PUBLISHERS
Copywright(c) 1997, Reprint 1999

[CONTENTS]
PREFACE
ACKNOWLADGEMENT
CHAPTER  1  INTRODUCTION
CHAPTER  2  FUNDAMENTALS OF PASCAL
CHAPTER  3  INPUT OUTPUT STATEMENTS
CHAPTER  4  CONTROL STATEMENTS
CHAPTER  5  ARRAYS
CHAPTER  6  PROCEDURES AND FUNCTIONS
CHAPTER  7  RECORDS
CHAPTER  8  FILES
CHAPTER  9  USER DEFINED DATA TYPES, SETS AND UNITS
CHAPTER 10  POINTERS
CHAPTER 11  GRAPHICS
CHAPTER 12  AN INTRODUCTION TO OBJECT ORIENTED PROGRAMMING
APPENDIX A  RESERVED WORDS
APPENDIX B  PREDEFINED IDENTIFIERS
BIBLIOGRAPHY
INDEX

{* ::\\\~ *}
{* ///::~::\\\ *}
{* ::\\\~///:: *}

SCHAUM'S OUTLINE SERIES
THEORY AND PROBLEMS OF
PROGRAMMING with PASCAL
BYRON S. GOTTFRIED

INCLUDING 391 SOLVED PROBLEMS AND
35 COMPLETE PROGRAMMING EXAMPLES

SCHAUM'S OUTLINE SERIES IN COMPUTERS
McGRAW HILL BOOK COMPANY

CONTENT

Chapter  1    INTRODUCTORY CONCEPTS
Chapter  2    PASCAL FUNDAMENTALS
Chapter  3    SCALAR-TYPE DATA
Chapter  4    DATA INPUT AND OUTPUT
Chapter  5    CREATING AND RUNNING A PASCAL PROGRAMMING
Chapter  6    CONTROL STRUCTURES
Chapter  7    PROCEDURES AND FUNCTIONS
Chapter  8    USER-DEFINED SIMPLE-TYPE DATA
Chapter  9    ARRAYS
Chapter 10    RECORDS
Chapter 11    FILES
Chapter 12    SETS
Chapter 13    LISTS AND POINTERS
Appendix A    RESERVED WORDS
Appendix B    STANDARD IDENTIFIERS
Appendix C    STANDARD PROCEDURES
Appendix D    STANDARD FUNCTIONS
Appendix E    OPERATORS
Appendix F    DATA TYPES
Appendix G    CONTROL STRUCTURES
Appendix H    THE ASCII CHARACTER SET
ANSWER TO SELECTED PROBLEMS
INDEX

[CONTENT]

Chapter  1    INTRODUCTORY CONCEPTS
Chapter  2    PASCAL FUNDAMENTALS
Chapter  3    SCALAR-TYPE DATA
Chapter  4    DATA INPUT AND OUTPUT
Chapter  5    CREATING AND RUNNING A PASCAL PROGRAMMING
Chapter  6    CONTROL STRUCTURES
Chapter  7    PROCEDURES AND FUNCTIONS
Chapter  8    USER-DEFINED SIMPLE-TYPE DATA
Chapter  9    ARRAYS
Chapter 10    RECORDS
Chapter 11    FILES
Chapter 12    SETS
Chapter 13    LISTS AND POINTERS
Appendix A    RESERVED WORDS
Appendix B    STANDARD IDENTIFIERS
Appendix C    STANDARD PROCEDURES
Appendix D    STANDARD FUNCTIONS
Appendix E    OPERATORS
Appendix F    DATA TYPES
Appendix G    CONTROL STRUCTURES
Appendix H    THE ASCII CHARACTER SET
ANSWER TO SELECTED PROBLEMS
INDEX


{::\\\~}

Complete Programming Examples

  1. Area of a Circle - Examples 1.6 - 
  2. Roots of Quadratic Equations 
  3. Finding a Palindrom
  4. Averaging a list of Numbers
  5. Repeated Averaging of a List of Numbers
  6. 
  7. 
  8. Solution of an Algebraic Equation
  9. Calculating Depriciations
 10. Averageing a List of Nonnegetive Numbers
 11. Maximum of Three Inegers
 12. Search for a Minimum
 13. Calculating Factorials
 16. The Tower of Hanoi
 20. Names and Address
 21. Table Multiplication
 22. Adding Two Table of Salary
 23. A Piglatin Generator
 24. A Customer Billing System
 25. Inventory Control
 26. Creating a File of Customer Records
 28. Reading a File of Customer Records
 30. Copying a File
 31. Appending a File
 32. Displaying a File
 33. Displaying a Customer Billing System
 41. 
{\\\::~}

Problem Solving and Structured Programming in Pascal
Second Edition, December 1984
Elliot B. Koffman
ISBN 0-201-11736-3
ISBN 0-201-21450-4 School
June  1985

[CONTENTS]

Chapter  1  Introduction to Computer and Programming    1
Chapter  2  Problem Solving    45
Chapter  3  Control Statements    95
Chapter  4  Simple Data Types    159
Chapter  5  More Control Statements    217
Chapter  6  Arrays    263
Chapter  7  Records    325
Chapter  9  Recursion, Searching and Sorting    425
Chapter 10  Pointer Variables and Dynamic Data Structures    475
Appendix  A:  Reserved Words, Standard Identifiers, Operators, Functions and Procedures  Ap-1
Appendix  B:  Additions and Extensions to Pascal  A5-5
Appendix  C:  Pascal Syntax Diagrams  Ap19
Appendix  D:  Character Sets  Ap-29
Appendix  E:  Error Number Summary  Ap-31
Answer to Selected Exercises  Ans-1
Index  I-1


[CONTENTS]

Chapter  1  Introduction to Computer and Programming    1

            1.1  Electronic Computers Then and Now 2
            1.2  Components of a Computer 3
            1.3  Problem Solving and Programming 6
            1.4  Programming Languages 7
            1.5  Processing a High-level Language Program 9
            1.6  Introduction to Pascal 11
            1.7  General Form of a Pascal Program 22
            1.8  Using the Computer 26
            1.9  Formatting Program Output 29
            1.10 Introduction to Data Types 34
            1.11 Common Programming Errors 36
            1.12 Chapter Review 39

Chapter  2  Problem Solving    45

            2.1  Representing and Refining Algorithms 46
            2.2  Using Procedures for Subproblems 52
            2.3  Decision Steps in Algorithms 59
            2.4  Tracing a Program or Algorithm 67
            2.5  Problem Solving Strategies 69
            2.6  Repetition in Programs 72
            2.7  Generalizing a Solution 79
            2.8  Repeating a Program Body 83
            2.9  Debugging and Testing Programs 87
            2.10 Common Programming Errors 88
            2.11 Chapter Review 89

Chapter  3  Control Statements    95

            3.1  Syntax Diagrams 96
            3.2  The if Statement Revisited 97
            3.3  The while Statement 104
            3.4  Procedure Parameters 111
            3.5  Adding Data Flow Information to Structure Charts 128
            3.6  Nested Procedures and Scope of Identifiers 132
            3.7  Case Studies 136
            3.8  Debugging a Program System 150
            3.9  Common Programming Errors 151
            3.10 Chapter Review 152

Chapter  4  Simple Data Types    159

            4.1  Constant Declarations Types 160
            4.2  Numeric Data Types-REAL and INTEGER 161
            4.3  Functions in Arithmetic Expressions 169
            4.4  BOOLEAN Variables, Expressions, and Operators 175
            4.5  Character Variables and Functions 180
            4.6  Introduction to Programmer-defined Data Types 188
            4.7  Input or Output Revisited 193
            4.8  Case Study 201
            4.9  Common Programming Errors 206
            4.10 Chapter Review 207

Chapter  5  More Control Statements    217

            5.1  The case Statement  218
            5.2  Set Values in Decisions 221
            5.3  The General for Statement 223
            5.4  The repeat Statement 225
            5.5  Nested Loops 229
            5.6  User-defined Functions 234
            5.7  Case Studies 240
            5.8  Common Programming Errors 251
            5.9  Chapter Review 252

Chapter  6  Arrays    263

            6.1  Declaring and Referencing Arrays 264
            6.2  Arrays with Integer Subscripts 266
            6.3  Case Study 270
            6.4  Manipulating Entire Arrays 276
            6.5  Reading Part of an Array 282
            6.6  General Arrays 283
            6.7  Character Strings 288
            6.8  Multidimensional Arrays 295
            6.9  Case Study 302
            6.10 Common Programming Errors 313
            6.11 Chapter Review 313

Chapter  7  Records    325

            7.1  Declaring a Record 326
            7.2  Manipulating Individual Fields of a Record 328
            7.3  Manipulating an Entire Record 331
            7.4  Arrays of Records 334
            7.5  Case Study 335
            7.6  Searching an Array 342
            7.7  Sorting an Array 344
            7.8  General Data Structures 348
            7.9  Record Variants 352
            7.10 Manipulating Strings Stored in Records 357
            7.11 Common Programming Errors 363
            7.12 Chapter Review 364

Chapter  8  Sets and Files    371

            8.1  Sets Data Type and Set Operators 372
            8.2  RESET, REWRITE, and the File Position Pointer 379
            8.3  TEXT Files 381
            8.4  Case Studies 385
            8.5  User-defined File Types 396
            8.6  Case Study-File Merge 401
            8.7  Case Study-Data Base Inquiry 405
            8.8  File Buffer Variable 411
            8.9  Common Programming Errors 416
            8.10 Chapter Review 417

Chapter  9  Recursion, Searching and Sorting    425

            9.1  The Nature of Recursion 426
            9.2  Recursive Procedures 432
            9.3  Recursive Functions 439
            9.4  Binary Search of an Array 449
            9.5  Searching by Hashing 453
            9.6  Additional Sorting Algorithms 457
            9.7  Case Study-The Quicksort Algorithm 462
            9.8  Common Programming Errors 467
            9.9  Chapter Review 468

Chapter 10  Pointer Variables and Dynamic Data Structures    475

            10.1  The Variables NEW Statement and and ointer Variables 476
            10.2  Understanding Dynamic Allocation 480
            10.3  Introduction to Linked Lists 481
            10.4  Manipulating Linked Lists Using Pointer Variables 483
            10.5  Case Study-Maintaining a Linked List 487
            10.6  Stacks and Queues 500
            10.7  Multiple-linked Lists and Trees 506
            10.8  Case Study-Maintaining a Binary Search Tree 511
            10.9  Common Programming Errors 518
            10.10 Chapter Review 519

Appendix  A:  Reserved Words, Standard Identifiers, Operators, Functions and Procedures  Ap-1
Appendix  B:  Additions and Extensions to Pascal  A5-5
              B.1  Additional Features of ANSI/IEEE Pascal
              B.2  ISO Pascal
              B.3  USCD Pascal
              B.4  TURBO Pascal
Appendix  C:  Pascal Syntax Diagrams  Ap19
Appendix  D:  Character Sets  Ap-29
Appendix  E:  Error Number Summary  Ap-31
Answer to Selected Exercises  Ans-1
Index  I-1

[Contents]

CHAPTER  1  Introduction to Computers and Programming
1.1  Electronic Computers Then and Now 2
1.2  Components of a Computer 3
1.3  Problem Solving and Programming 6
1.4  Programming Languages 7
1.5  Processing a High-level Language Program
1.6  Introduction to Pascal 11
1.7  General Form of a Pascal Program 22
1.8  Using the Computer 26
1.9  Formatting Program Output 29
1.10 Introduction to Data Types 34
1.11 Common Programming Errors 36
1.12 Chapter Review 39

CHAPTER  2 Electronic Computers Then and Now 2
2.1  Representing and Refining Algorithms 46
2.2  Using Procedures for Subproblems 52
2.3  Decision Steps in Algorithms 59
2.4  Tracing a Program or Algorithm 67
2.5  Problem Solving Strategies 69
2.6  Repetition in Programs 72
2.7  Generalizing a Solution 79
2.8  Repeating a Program Body 83
2.9  Debugging and Testing Programs 87
2.10 Common Programming Errors 88
2.11 Chapter Review 89

CHAPTER  3  Control Statements 95
3.1  Syntax Diagrams 96
3.2  The if Statement Revisited 97
3.3  The while Statement 104
3.4  Procedure Parameters 111
3.5  Adding Data Flow Information to Structure Charts 128
3.6  Nested Procedures and Scope of Identifiers 132
3.7  Case Studies 136
3.8  Debugging a Program System 150
3.9  Common Programming Errors 151
3.10 Chapter Review 152

CHAPTER 4 Simple Data Types 159
4.1  Constant Declarations 160
4.2  Numeric Data Types-REAL and INTEGER 161
4.3  Functions in Arithmetic Expressions 169
4.4  BOOLEAN Variables, Expressions, and Operators 175
4.5  Character Variables and Functions 180
4.6  Introduction to Programmer-defined Data Types 188
4.7  Input/Output Revisited 193
4.8  Case Study 201
4.9  Common Programming Errors 206
4.10 Chapter Review 207

CHAPTER 5 More Control Statement 217
5.1  The case Statements 218
5.2  Set Values in Decisions 221
5.3  The General for Statement 223
5.4  The repeat Statement 225
5.5  Nested Loops 229
5.6  User-defined Functions 234
5.7  Case Studies 240
5.8  Common Programming Errors 251
5.9  Chapter Review 252

CHAPTER 6 Arrays 263
6.1  Declaring  and  Referencing Arrays 264
6.2  Arrays with Integer Subscripts 266
6.3  Case Study 270
6.4  Manipulating Entire Arrays 276
6.5  Reading Part of an Array 282
6.6  General Arrays 283
6.7  Character Strings 288
6.8  Multidimensional Arrays 295
6.9  Case Study 302
6.10 Common Programming Errors 313
6.11 Chapter Review 313

CHAPTER 7 Records 325
7.1  Declaring a Record 326
7.2  Manipulating Individual Fields of a Record 328
7.3  Manipulating an Entire Record 331
7.4  Arrays of Records 334
7.5  Case Study 335
7.6  Searching an Array 342
7.7  Sorting an Array 344
7.8  General Data Structures 348
7.9  Record Variants 352
7.10 Manipulating Strings Stored in Records 357
7.11 Common Programming Errors 363
7.12 Chapter Review 364

CHAPTER 8 Sets and Files 371
8.1  Set Data Type and Set Operators 372
8.2  RESET, REWRITE, and the File Position Pointer 379
8.3  TEXT Files 381
8.4  Case Studies 385
8.5  User-defined File Types 396
8.6  Case Study-File Merge 401
8.7  Case Study-Data Base Inquiry 405
8.8  File Buffer Variable 411
8.9  Common Programming Errors 416
8.10 Chapter Review 417

CHAPTER 9 Recursion, Searching, and Sorting 425
9.1  The Nature of Recursion  426
9.2  Recursive Procedures 432
9.3  Recursive Functions 439
9.4  Binary Search of an Array 449
9.5  Searching by Hashing 453
9.6  Additional Sorting Algorithms 457
9.7  Case Study-The Quicksort Algorithm 462
9.8  Common Programming Errors 467
9.9  Chapter Review 468

CHAPTER 10 Pointer Variables and Dynamic Data Structures 475
10.1  The NEW Statement and Pointer Variables 476
10.2  Understanding Dynamic Allocation 480
10.3  Introduction to Linked Lists 481
10.4  Manipulating Linked Lists Using Pointer Variables 483
10.5  Case Study-Maintaining a Linked List 487
10.6  Stacks and Queues 500
10.7  Multiple-linked Lists and Trees 506
10.8  Case Study-Maintaining a Binary Search Tree 511
10.9  Common Programming Errors 518
10.10 Chapter Review 519

Appendix A: Reserved Words, Identifiers, Operators, Functions, Standard and Procedures Ap-1
Appendix B: Additions and Extensions to Pascal Ap-5
B.1 Additional Features of ANSI/IEEE Pascal
B.2 ISO Pascal
B.3 UCSD Pascal
B.4 TURBO Pascal
Appendix C: Pascal Syntax Diagrams Ap-19
Appendix D: Character Sets Ap-29
Appendix E: Error Number Summary Ap-31
Answers to Selected Exercises Ans-1
Index I-1

 ===============================
 = HOW TO SOLVE IT BY COMPUTER =
 ===============================
How to Solve It by Computer by R. G. Dromey PDF
Name: How to Solve It by Computer: Prentice-Hall International Series in Computer Science
Authors: R. G. Dromey
Publish Date: July 1, 1982
Language: English
Genre: Software Development
Format: PDF
Size:
Pages: 442
Price: Paperback $30.25, 4 Used from $30.81, 6 New from $26.72
ISBN: 0134340019

[CONTENTS]

   PREFACE                                  xiii
   ACKNOWLEDGEMENTS                          xxi
1  INTRODUCTION TO COMPUTER PROBLEM-SOLVING    1
2  FUNDAMENTAL ALGORITHMS                     42
3  FACTORING METHODS                          85
4  ARRAY TECHNIQUES                          139
5  MERGING, SORTING AND SEARCHING            181
6  TEXT PROCESSING AND PATTERN SEARCHING     248
7  DYNAMIC DATA STRUCTURE ALGORITHMS         304
8  RECURSIVE ALGORITHMS                      367
   INDEX                                     435


[Table of Content]

   PREFACE      xiii
   ACKNOWLEDGEMENTS      xxi
1  INTRODUCTION TO COMPUTER PROBLEM-SOLVING    1
   1.1  Introduction    1
   1.2  The Problem-solving Aspect    3
   1.3  Top-down Design    7
   1.4  Implementation of Algorithms    14
   1.5  Program Verification    19
   1.6  The Efficiency of Algorithms    29
   1.7  The Analysis of Algorithms    33
   Bibliography    39
   
2  FUNDAMENTAL ALGORITHMS    42
   Introduction    42
   Algorithm 2.1  Exchanging the Values of Two Variables    43
   Algorithm 2.2  Counting    47
   Algorithm 2.3  Summation of a Set of Numbers    51
   Algorithm 2.4  Factorial Computation    56
   Algorithm 2.5  Sine Function Computation    60
   Algorithm 2.6  Generation of the Fibonacci Sequence    64
   Algorithm 2.7  Reversing the Digits of an Integer    69
   Algorithm 2.8  Base Conversion    74
   Algorithm 2.9  Character to Number Conversion  80
   Bibliography    84
   
3  FACTORING METHODS    85
   Introduction    85
   Algorithm 3.1  Finding the Squar Root of a Number    86
   Algorithm 3.2  The Smallest Divisor of an Integer    92
   Algorithm 3.3  The Greatest Common Divisor of Two Integers    97
   Algorithm 3.4  Generating Prime Numbers    105
   Algorithm 3.5  Computing the Prime Factors of an Integer    116
   Algorithm 3.6  Generation of Pseudo-random Numbers    124
   Algorithm 3.7  Raising a Number to a Large Power    124
   Algorithm 3.8  Computing the nth Fibonacci Number    132
   Bibliography    138
   
4  ARRAY TECHNIQUES    139
   Introduction    139
   Algorithm 4.1  Array Order Reversal    140
   Algorithm 4.2  Array Counting or Histogramming    144
   Algorithm 4.3  Finding the Maximum Number in a Set    147
   Algorithm 4.4  Removal of Duplicates from an Ordered Array    152
   Algorithm 4.5  Partitioning an Array    156
   Algorithm 4.6  Finding the kth Smallest Element    166
   Algorithm 4.7  Longest Monotone Subsequence    174
   Bibliography    180
   
5  MERGING, SORTING AND SEARCHING    181
   Introduction    181
   Algorithm 5.1  The Two-way Merge    182
   Algorithm 5.2  Sorting by Selection    192
   Algorithm 5.3  Sorting by Exchange    192
   Algorithm 5.4  Sorting by Insertion    204
   Algorithm 5.5  Sorting by Diminishing Increment    209
   Algorithm 5.6  Sorting by Partitioning    216
   Algorithm 5.7  Binary Search    227
   Algorithm 5.8  Hash Searching  237
   Bibliography    246
   
6  TEXT PROCESSING AND PATTERN SEARCHING    248
   Introduction    248
   Algorithm 6.1  Text Line Length Adjustment    249
   Algorithm 6.2  Left and Right Justification in Text    256
   Algorithm 6.3  Keyword Searching in Text    267
   Algorithm 6.4  Text Line Editing    274
   Algorithm 6.5  Linear Pattern Search    282
   Algorithm 6.6  Sublinear Pattern Search    293
   Bibliography    303
   
7  DYNAMIC DATA STRUCTURE ALGORITHMS  304
   Introduction    304
   Algorithm 7.1  Stack Operations    306
   Algorithm 7.2  Queue Addition and Deletion    314
   Algorithm 7.3  Linked List Search    325
   Algorithm 7.4  Linked List Insertion and Deletion    331
   Algorithm 7.5  Binary Tree Search    342
   Algorithm 7.6  Binary Tree Insertion and Deletion    349
   Bibliography    366

8  RECURSIVE ALGORITHMS   367
   Introduction    367
   Algorithm 8.1  Binary Tree Traversal    373
   Algorithm 8.2  Recursive Quick sort    383
   Algorithm 8.3  Towers of Hanoi Problem    391
   Algorithm 8.4  Sample Generation    414
   Algorithm 8.5  Combination Generation    414
   Algorithm 8.6  Permutation Generation    422
   Bibliography    433
   
INDEX    435

   =================================================================
   [ 50 ALGORITHMS ]
   =================================================================
   Algorithm 2.1  Exchanging the Values of Two Variables          43
   Algorithm 2.2  Counting                                        47
   Algorithm 2.3  Summation of a Set of Numbers                   51
   Algorithm 2.4  Factorial Computation                           56
   Algorithm 2.5  Sine Function Computation                       60
   Algorithm 2.6  Generation of the Fibonacci Sequence            64
   Algorithm 2.7  Reversing the Digits of an Integer              69
   Algorithm 2.8  Base Conversion                                 74
   Algorithm 2.9  Character to Number Conversion                  80
   Algorithm 3.1  Finding the Squar Root of a Number              86
   Algorithm 3.2  The Smallest Divisor of an Integer              92
   Algorithm 3.3  The Greatest Common Divisor of Two Integers     97
   Algorithm 3.4  Generating Prime Numbers                       105
   Algorithm 3.5  Computing the Prime Factors of an Integer      116
   Algorithm 3.6  Generation of Pseudo-random Numbers            124
   Algorithm 3.7  Raising a Number to a Large Power              124
   Algorithm 3.8  Computing the nth Fibonacci Number             132
   Algorithm 4.1  Array Order Reversal                           140
   Algorithm 4.2  Array Counting or Histogramming                144
   Algorithm 4.3  Finding the Maximum Number in a Set            147
   Algorithm 4.4  Removal of Duplicates from an Ordered Array    152
   Algorithm 4.5  Partitioning an Array                          156
   Algorithm 4.6  Finding the kth Smallest Element               166
   Algorithm 4.7  Longest Monotone Subsequence                   174
   Algorithm 5.1  The Two-way Merge                              182
   Algorithm 5.2  Sorting by Selection                           192
   Algorithm 5.3  Sorting by Exchange                            192
   Algorithm 5.4  Sorting by Insertion                           204
   Algorithm 5.5  Sorting by Diminishing Increment               209
   Algorithm 5.6  Sorting by Partitioning                        216
   Algorithm 5.7  Binary Search                                  227
   Algorithm 5.8  Hash Searching                                 237
   Algorithm 6.1  Text Line Length Adjustment                    249
   Algorithm 6.2  Left and Right Justification in Text           256
   Algorithm 6.3  Keyword Searching in Text                      267
   Algorithm 6.4  Text Line Editing                              274
   Algorithm 6.5  Linear Pattern Search                          282
   Algorithm 6.6  Sublinear Pattern Search                       293
   Algorithm 7.1  Stack Operations                               306
   Algorithm 7.2  Queue Addition and Deletion                    314
   Algorithm 7.3  Linked List Search                             325
   Algorithm 7.4  Linked List Insertion and Deletion             331
   Algorithm 7.5  Binary Tree Search                             342
   Algorithm 7.6  Binary Tree Insertion and Deletion             349
   Algorithm 8.1  Binary Tree Traversal                          373
   Algorithm 8.2  Recursive Quick sort                           383
   Algorithm 8.3  Towers of Hanoi Problem                        391
   Algorithm 8.4  Sample Generation                              414
   Algorithm 8.5  Combination Generation                         414
   Algorithm 8.6  Permutation Generation                         422
   =================================================================

{\\\::~}



ALGORITHMS
ROBERT SEDGEWICK
BROWN UNNERSITY
ISBN 0-201-06672-6
February, 1985
Copyright 1983 by Addison-Wesley Publishing Company, Inc.


[Contents]


    PART 1 MATHEMATICAL ALGORITHMS
    PART 2 SORTING
    PART 3 SEARCHING
    PART 4 STRING PROCESSING
    PART 5 GEOMETRIC ALGORITHMS
    PART 6 GRAPH ALGORITHMS
    PART 7 ADVANCED TOPICS



[Contents]

    Introduction . . . . . . . . . . . . . . . . . . . . . . . . . 3
        Algorithms, Outline of Topics
        
1. Preview. . . . . . . . . . . . . . . . . . . . . . . . . . . 9
        Pascal, Euclid’s Algorithm, Recursion, Analysis of Algorithms
        Implementing Algorithms

MATHEMATICAL ALGORITHMS
***********************

2. Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . 21
        Polynomials, Matrices, Data Structures

3. Random Numbers . . . . . . . . . . . . . . . . . . . . . . . 33
        Applications, Linear Congruential Method, Additive
        Congruential Method, Testing Randomness, Implementation Notes

4. Polynomials . . . . . . . . . . . . . . . . . . . . . . . . . . 45
        Evaluation, Interpolation, Multiplication, Divide-and-conquer
        Recurrences, Matriz Multiplication

5. Gaussian Elimination . . . . . . . . . . . . . . . . . . . . . . 57
        A Simple Example, Outline of the Method, Variations and Extensions

6. Curve Fitting . . . . . . . . . . . . . . . . . . . . . . . . . 67
        Polynomaal Interpolation, Spline Interpolation, Method of Least Squares

7. Integration . . . . . . . . . . . . . . . . . . . . . . . . . . 79
        Symbolac Integration, Simple Quadrature Methods, Compound Methods,
        Adaptive Quadrature

SORTING
*******

8. Elementary Sorting Methods . . . . . . . . . . . . . . . . . . 91
        Rules of the Game, Selection Sort, Insertion Sort, Shellsort,
        Bubble Sort, Distribution Counting, Non-Random Files

9. Quicksort . . . . . . . . . . . . . . . . . . . . . . . . . . 103
        The Baszc Algorithm, Removing Recursion, Small Subfiles,
        Median-of- Three Partitioning

10. Radix Sorting . . . . . . . . . . . , . . . . . . . . . . . . 115
        Radiz Ezchange Sort, Straight Radix Sort, A Linear Sort

11. Priority Queues . . . . . . . . . . . . . . . . . . . . . . 127
        Elementary Implementations, Heap Data Structure, Algorithms
        on Heaps, Heapsort, Indirect Heaps, Advanced Implementations

12. Selection and Merging . . . . . . . . . . . . . . . . . . . . 143
        Selection, Mergang, Recursion Revisited

13. External Sorting . . . . . . . . . . . . . . . . . . . . . . 155
        Sort-Merge, Balanced Multiway Merging, Replacement Selectzon,
        Practical Considerations, Polyphase Merging, An Easier Way

SEARCHING
*********

14. Elementary Searching Methods . . . . . . . . . . . . . . . .171
        Sequential Searching, Sequential List Searchang, Binary Search,
        Binary Tree Search, Indirect Binary Search Trees

15. Balanced Trees . . . . . . . . . . . . . . . . . . . . . .187
        Top-Down 2-9-4 Trees, Red-Black Trees, Other Algorithms

16. Hashing . . . . . . . . . . . . . . . . . , . . . . . . .201
        Hash Functions, Separate Chaining, Open Addresszng, Analytic Results

17. Radix Searching . . . . . . . . . . . . . . . . . . . . . .213
        Digital Search Trees, Radix Search Trees, Multiway Radar Searching,
        Patricia

18. External Searching . . . . . . . . ,, . . . . . . . . . . . . . 225
        Indexed Sequential Access, B- nees, Extendible Hashing, Virtual Memory

STRING PROCESSING
*****************

19. String Searching . . . . . . . . . . . . . . . . . . . . . . 241
        A Short History, Brute-Force Algorithm, Knuth-Morris-Pratt Algorzthm,
        Bayer-Moore Algorithm, Rabin-Karp Algorithm, Multiple Searches

20. Pattern Matching . . . . . . . . . . . . . . . . . . . . . 257
        Describing Patterns, Pattern Matching Machznes, Representzng
        the Machine, Simulating the Machine

21. Parsing . . . . . . . . . . . . . . . . . . . . . . . . . . 269
        Conteti-Free Grammars, Top-Down Parsing, Bottom-Up Parsing,
        Compilers, Compiler-Compilers

22. File Compression . . . . . . . . . . . . . . . . . . . . . . 283
        Run-Length Encoding, Variable-Length Encoding

23. Cryptology . . . . . . . . . . . . . . . . . . . . . . . . . 295
        Rules of the Game, Simple Methods, Encrypt:!on/Decryption
        Machines, Public-Key Cryptosystems

GEOMETRIC ALGORITHMS
********************

24. Elementary Geometric Methods . . . . . . . . . . . . . . . . 307
        Poznts, Lines, and Polygons, Line Intersection, Simple
        Closed Path, Inclusaon in 4 Polygon, Perspective

25. Finding the Convex Hull . . . . . . . . . . . . . . . . . . . 321
        Rules of the Game, Package Wrapping, The Graham Scan,
        Hull Selection, Performance Issues

26. Range Searching . . . . . . . . . . . . . . . . . . . . . . . 335
        Elementary Methods, Grad Method, 2D Trees,
        Multidimensaonal Range Searching

27. Geometric Intersection . , . . . . . . . . . . . . . . . . . . 349
        Horizontal and Vertical Lines, General Line Intersection

28. Closest Point Problems . . . . . . . . . . . . . . . . . . . 361
        Closest Paar, Voronoi Diagrams

GRAPH ALGORITHMS
****************

29. Elementary Graph Algorithms . . . . . . . . . . . . . . . . . 373
        Glossary, Representation, Depth-First Search, Mazes, Perspectzve

30. Connectivity . . . . . . . . . . . . . . . . . . . . . . . 389
        Biconnectivity, Graph Traversal Algorzthms, Union-Find Algorithms

31. Weighted Graphs . . . . . . . . . . . . . . . . . . . . . 407
        Mmimum Spanning Tree, Shortest Path, Dense Graphs, Geometrzc Problems

32. Directed Graphs . . . . . . . . . . . . . . . . . . . . 421
        Depth-Farst Search, Transitwe Closure, Topological Sorting,
        Strongly Connected Components

33. Network Flow . . . . . . . . . . . . . . . . . . . . . 433
        The Network Flow Problem, Ford-Adkerson
        Method, Network Searching

34. Matching . . . . . . . . . . . . . . . . . . . . . . . . . . 443
        Bapartite Graphs, Stable Marriage Problem, Advanced Algorathms

ADVANCED TOPICS
***************

35. Algorithm Machines . . . . . . . . . . . . . . . . . . . . .457
        General Approaches, Perfect Shuffles, Systolic Arrays

36. The Fast Fourier Transform . . . . . . . . . . . . . . . . .471
        Evaluate, Multiply, Interpolate, Complez Roots of Unity, Evaluation
        at the Roots of Unity, Interpolatzon at the Roots of Unity, Implementation

37. Dynamic Programming . . . . . . . . . . . . . . . . . . . . 483
        Knapsack Problem, Matriz Chain Product, Optimal Binary Search Trees,
        Shortest Paths, Time and Space Requirements

38. Linear Programming . . . . . . . . . . . . . . . . . . . . 497
        Linear Programs, Geometric Interpretation, The Simplex Method,
        Implementation

39. Exhaustive Search . . . . . . . . . . . . . . . . . . . . . 513
        Exhaustive Search in Graphs, Backtrackzng,
        Permutation Generation, Approximation Algorithms

40. NP-complete Problems . . . . . . . . . . . . . . . . . . 527
        Deterministic and Nondeterministic Polynomial- Time Algorzthms,
        NP-Completeness, Cook’s Theorem, Some NP-Complete Problems
{::\\\~}




PROGRAM {Name of the program}
USES {Comma delimited names of libraries you use}
CONST {Global constant declaration block}
VAR {global variable declaration block}

FUNCTION {Function declarations, if any}
{ Local variables }
BEGIN
 .
 .
 .
END;

PROCEDURE { Procedure declarations, if any}
{ Local variables }
BEGIN
 .
 .
 .
END;

BEGIN { Main program block starts}
.
.
.
END. { The end of main program block }

{
{ File name: hello.pas }
program HelloWorld;
uses crt;

(* Here the main program block starts *)
begin
writeln('Hello, World!');
readkey;
end.

{
$ fpc hello.pas
Free Pascal Compiler version 2.6.0 [2011/12/23] for x86_64
Copyright (c) 1993-2011 by Florian Klaempfl and others
Target OS: Linux for x86-64
Compiling hello.pas
Linking hello
8 lines compiled, 0.1 sec
$ ./hello
Hello, World!
}
}


{-------------------------------------------------}

PROGRAM  hello;
BEGIN
WRITELN('Hello world!')
END.

Output: Hello world!

View ROM for sub details!


PROGRAM  sample;
CONST x=2;
VAR   y:INTEGER;
BEGIN y:=x*x;
      WRITELN(y)
END.

Output: 4


PROGRAM  w_INTEGER;
CONST a=400;
VAR   b,s:INTEGER;
BEGIN b:=3;
      s:=a+b; s:=s DIV 2;
      WRITELN(s)
END.

Output: 201


PROGRAM  w_INT64;
CONST a=400000;
VAR   b,s:INT64;
BEGIN b:=3;
      s:=a+b; s:=s DIV 2;
      WRITELN(s)
END.

Output: 200001


PROGRAM  w_DOUBLE;
CONST a=4.0;
VAR   b:REAL; s:DOUBLE;
BEGIN b:=3.5;
      s:=a+b; s:=s/2.0;
{try also     s:=s/2;}
      WRITELN(s)
END.

Output: 0.375000000e1


PROGRAM  INTEGERtypes;
CONST c=100000; d=200; 
VAR   a:INT64;  b:INTEGER;
BEGIN WRITE(c); WRITE(' ');
WRITELN(d);
a:=c; WRITE(a); WRITE(' ');
a:=d; WRITELN(a);
b:=d; WRITELN(b);
{a:=c;} {b:=a; WRITELN(b);}
a:=b+c; WRITELN(a);
END.
see compiler options!!!
Output: 100000 200
        100000 200
        200
        100200


PROGRAM  INT_DOUBLE;
CONST i=-2;    r=4.75;
VAR   a:INT64; b:DOUBLE;
BEGIN b:=1; WRITELN(b);
      b:=r+i; WRITELN(b);
      a:=TRUNC(r); WRITELN(a);
      a:=ROUND(r); WRITELN(a)
END.

Output: 0.100000000e1
        0.275000000e1
        4
        5


PROGRAM  calc_SQR;
VAR   a:INTEGER; b:DOUBLE;
BEGIN a:=2; a:=SQR(a);
      WRITELN(a);
      b:=2.0; b:=SQR(b);
      WRITELN(b)
END.

Output: 4
        0.400000000e1


PROGRAM  calc;
VAR  a,b,c:INTEGER;
BEGIN a:=3; b:=a+2;
b:=SQR(b);b:=b-2;
c:=b mod a;
writeln(c);
END.

Output: 2


PROGRAM  fallibility;
CONST e=1e-2;
VAR   a,s:REAL; 
      i,n:INT64;
BEGIN a:=1/e; n:=TRUNC(a);
      WRITELN(n);
      s:=0;
      FOR i:=1 TO n DO s:=s+e;
      a:=1-s;
      WRITELN(a)
END.

Output: 100
        -0.666133814e-15


PROGRAM  w_BOOLEAN;
CONST t=TRUE; f=FALSE;
VAR   b:BOOLEAN;
BEGIN b:=f; WRITELN(b);
      WRITELN(t)
END.

Output: FALSE
        TRUE


PROGRAM logic;
CONST a=FALSE; b=FALSE;
VAR   c,d,e,f:BOOLEAN;
BEGIN c:=a AND b;
      WRITELN(c);
      d:=NOT a; e:=NOT b;
      f:=e OR d; f:=NOT f;
      WRITE(f); WRITE(' xor ');
      f:=c XOR f; WRITELN(f)
END.

Output: FALSE
        FALSE xor FALSE


PROGRAM char_func;
CONST e='1';
VAR   i:INTEGER;
      c:CHAR;
BEGIN
i:=ORD(e); WRITELN(i);
c:=CHR(49);WRITELN(c);
c:=SUCC(e);WRITELN(c);
c:=PRED(e);WRITELN(c);
END.

Output: 49
        1
        2
        0


PROGRAM  TypConst;
CONST n=4;
      t:INTEGER=5;
VAR   w:INTEGER;
BEGIN w:=t-n; t:=w+1;
WRITELN(t);
END.

Output: 2


PROGRAM  VarPos1;
VAR d:DOUBLE;
    b:BOOLEAN;
    i:INTEGER;
    l:INT64;
    c:CHAR;
BEGIN i:=0
END.


PROGRAM VarPos2;
{more rational}
VAR d:DOUBLE;
    l:INT64;
    b:BOOLEAN; c:CHAR;
    i:INTEGER;
BEGIN i:=0
END.


PROGRAM  Array1;
CONST a=2005;    b='3';
VAR   c:INTEGER; d:CHAR;
e:ARRAY [1999..a] OF CHAR;
f:ARRAY ['0'..b] 
        OF INTEGER;
BEGIN c:=a-2; e[c]:=SUCC(b);
WRITELN(e[2003]);
d:=PRED(b); f[d]:=3*a;
WRITELN(f['2'])
END.

Output: 4
        6015


PROGRAM  Array2;
CONST c=1;
VAR   i:INT64;
f:ARRAY [c..5] OF DOUBLE;
BEGIN i:=c+2;
f[i]:=20.2; WRITELN(f[3])
END.

Output: 0.202000000e2


PROGRAM  Array3;
CONST t=TRUE;
VAR b:BOOLEAN;
m:ARRAY [BOOLEAN]
        OF INTEGER;
BEGIN
m[FALSE]:=0; m[TRUE]:=1;
b:=TRUE; WRITELN(m[FALSE]);
WRITE(m[b]); WRITE('  ');
WRITELN(m[t]);
END.

Output: 0
        1  1


PROGRAM digits;
CONST n=5;
      k:INTEGER=13524;
VAR   i:INTEGER;
c:ARRAY [1..n] OF INTEGER;
BEGIN  i:=n;
REPEAT c[i]:=k MOD 10;
       k:=k DIV 10;
       i:=i-1
UNTIL k=0;
FOR i:=1 TO n DO
BEGIN  WRITE(c[i]);WRITE(' ')
END
END.

Output: 1 3 5 2 4


PROGRAM  IfInt;
VAR   x,s:INTEGER;
BEGIN x:=2;
if x<0 then s:=-1
       else s:=1;
writeln(s)
END.

Output: 1


PROGRAM  IfBool;
VAR i:INT64;
    b:BOOLEAN;
    c:CHAR;
BEGIN 
i:=1; b:=i=0;
if b then c:='0'
     else c:='1';
writeln(c)
END.

Output: 1


PROGRAM  Sign;
CONST x=2;
VAR   s:INTEGER;
BEGIN
IF x<0 THEN s:=-1
       ELSE s:=1;
IF x=0 THEN s:=0;
writeln(s)
END.

Output: 1


PROGRAM StepMinEdin;
CONST n:INTEGER=3;
VAR   r,e:INTEGER;
BEGIN r:=n MOD 2;
IF r=0 THEN e:=1
       ELSE e:=-1;
WRITELN(e);
END.

Output: -1


PROGRAM number;
CONST c:CHAR='3';
VAR   i:INTEGER;
      l,r,w:BOOLEAN;
BEGIN l:=c>='0'; r:=c<='9';
      w:=l AND r;
IF w 
  THEN WRITELN('number')
  ELSE WRITELN('not number');
END.

Output: number


PROGRAM example;
CONST a:INTEGER=2;
      b:INTEGER=15;
VAR   c:INTEGER;
BEGIN c:=0;
      WHILE a<b DO
            BEGIN a:=a+5;
                  c:=c+1
            END;
      WRITELN(c)
END.

Output:  3


PROGRAM search;
VAR i:INTEGER;
t:ARRAY [1..11] OF CHAR;
BEGIN FOR i:=1 TO 10 DO
          READ(t[i]);
WRITELN('.');
t[11]:='A'; i:=1;
WHILE t[i]<>'A' DO i:=i+1; 
IF i<11 THEN WRITELN(i)
        ELSE WRITELN('no');
END.


PROGRAM SQRT;
VAR x,y,s:INTEGER;
BEGIN
READLN(x); y:=0;
REPEAT
      y:=y+1; 
      s:=SQR(y);
UNTIL s>=x;
WRITELN(y)
END.


PROGRAM text;
VAR i:INTEGER;
t:ARRAY [1..10] OF CHAR;
BEGIN  i:=0;
REPEAT i:=i+1;
       READ(t[i])
UNTIL  t[i]='.'
END.


PROGRAM  cycle_FOR1;
VAR  i:INTEGER;
BEGIN
FOR i:=1 TO 9
    DO WRITELN(i)
END.

Output: 1
        2
...
        9


PROGRAM  cycle_FOR2;
VAR  i:INTEGER;
BEGIN
FOR i:=9 DOWNTO 1
    DO WRITELN(i)
END.

Output: 9
        8
...
        1


PROGRAM  cycle_FOR3;
VAR  c:CHAR;
BEGIN
FOR c:='A' TO 'Z'
    DO WRITE(c)
END.

Output: ABCD..Z


PROGRAM  cycle_FOR4;
VAR  c:CHAR;
BEGIN
FOR c:='Z' DOWNTO 'A'
    DO WRITE(c)
END.

Output: ZYX..A


PROGRAM  cycle_FOR5;
VAR  b:BOOLEAN;
BEGIN
FOR b:=FALSE TO TRUE
    DO WRITELN(b)
END.

Output: FALSE
        TRUE


PROGRAM  cycle_FOR6;
VAR  b:BOOLEAN;
BEGIN
FOR b:=TRUE DOWNTO FALSE
    DO WRITELN(b)
END.

Output: TRUE
        FALSE


PROGRAM  cycle_FOR7;
VAR  i:INT64;
BEGIN
FOR i:=100001 TO 100009
    DO WRITELN(i)
END.

Output: 100000
        100001
...
        100009


PROGRAM  cycle_FOR8;
VAR  i:INT64;
BEGIN
FOR i:=100009 DOWNTO 100001
    DO WRITELN(i)
END.

Output: 100009
        100008
...
        100001


PROGRAM  factor_WHILE;
VAR   i,n,f:INTEGER;
BEGIN n:=3;
      f:=1; i:=1;
WHILE i<=n DO
BEGIN f:=f*i;
      i:=i+1
END;
writeln(f)
END.

Output: 6


PROGRAM  factor_REPEAT;
VAR  i,n,f:INTEGER;
BEGIN  n:=3;
       f:=1; i:=1;
REPEAT f:=f*i;
       i:=i+1
UNTIL  i>n;
writeln(f)
END.

Output: 6


PROGRAM  factor_FOR;
VAR   i,n,f:INTEGER;
BEGIN n:=3;
      f:=1;
FOR i:=1 TO n DO f:=f*i;
writeln(f)
END.

Output: 6


PROGRAM  factor_INT;
VAR   i,n,f:INTEGER;
      l:INT64;
BEGIN n:=7; f:=1;
FOR i:=1 TO n DO f:=f*i;
writeln(f);
n:=20; l:=1;
FOR i:=1 TO n DO l:=l*i;
writeln(l)
END.

Output: 5040
        2432902008176640000


PROGRAM Gauss;
CONST n=100;
VAR   i,s:INTEGER;
BEGIN s:=0;
FOR i:=1 TO n DO s:=s+i;
WRITELN(s);
END.

Output: 5050


PROGRAM bool;
VAR  b,n:BOOLEAN;
BEGIN
FOR b:=FALSE TO TRUE DO
   BEGIN WRITE('b=');
         WRITE(b);
         n:=not b;
         WRITE(' not(b)=');
         WRITELN(n)
   END;
END.

Output: b=FALSE  not(b)=TRUE
        b=TRUE  not(b)=FALSE


PROGRAM summa;
CONST n=5;
VAR   i,s:INTEGER;
m:ARRAY [1..n] OF INTEGER;
BEGIN
FOR i:=1 TO n DO
    readln(m[i]); s:=0;
FOR i:=1 TO n DO s:=s+m[i];
WRITELN(s);
END.


PROGRAM OtrElem;
CONST n=5;
VAR i:INTEGER; a,b:BOOLEAN;
m:ARRAY [1..n] OF INTEGER;
BEGIN FOR i:=1 TO n DO
       readln(m[i]);  i:=0; 
REPEAT i:=i+1; a:=m[i]<0; 
b:=i=n; b:=a OR b UNTIL b;
IF a THEN WRITELN(m[i])
     ELSE WRITELN('no -')
END.


PROGRAM  Hex;
VAR i:INTEGER; s:CHAR;
h:ARRAY [0..15] OF CHAR;
BEGIN s:='0';
FOR i:=0 TO 9 DO
 BEGIN h[i]:=s; s:=SUCC(s);
 END;  s:='A';
FOR i:=10 TO 15 DO
 BEGIN h[i]:=s; s:=SUCC(s);
 END;  WRITELN(h[13]);
END.

Output:  D


PROGRAM text;
CONST n=10; e='.';
VAR   i,j:INTEGER;
t:ARRAY [1..n] OF CHAR;
BEGIN i:=0;
REPEAT i:=i+1;READ(t[i]);
UNTIL t[i]=e;          
FOR j:=1 TO i DO
    WRITE(t[j]);
END.


PROGRAM OutText;
BEGIN
WRITELN('Text example')
END.

Output:  Text example


PROGRAM OutVar;
VAR 
m:ARRAY [1..3] OF CHAR;
i:INTEGER;
BEGIN m[3]:='Q'; i:=3;
WRITELN(m[i])
END.

Output:  Q


PROGRAM OutputExample;
VAR   c:CHAR;
BEGIN c:='3';
WRITE('Example');
WRITELN(' of output');
WRITE('c=');
WRITELN(c)
END.

Output:  Example of output
         c=3


PROGRAM read_int;
VAR a,b:INTEGER;
BEGIN READLN(a);
      READLN(b);
      WRITE(a); WRITE(' ');
      WRITELN(b)
END.


PROGRAM read_char;
VAR a,b:CHAR;
BEGIN READ(a);
      READ(b);
      WRITE('=>');
      WRITE(a); WRITELN(b)
END.


PROGRAM oform;
VAR   a:INTEGER;
BEGIN WRITE('A=');
      READLN(a);
      WRITE('A=');
      WRITELN(a)
END.


{::\\\~}

